{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../../types.js","../../../functions.js","../../../parser.js","../../../util.js","../../src/Cell.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value' || descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group) {\n    const value = [];\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.push(group[i].__value);\n    }\n    return value;\n}\nfunction to_number(value) {\n    return value === '' ? undefined : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j];\n                if (attributes[attribute.name]) {\n                    j++;\n                }\n                else {\n                    node.removeAttribute(attribute.name);\n                }\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    if (value != null || input.value) {\n        input.value = value;\n    }\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    const z_index = (parseInt(computed_style.zIndex) || 0) - 1;\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', `display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ` +\n        `overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: ${z_index};`);\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    let unsubscribe;\n    if (is_crossorigin()) {\n        iframe.src = `data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>`;\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        detach(iframe);\n        if (unsubscribe)\n            unsubscribe();\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(html, anchor = null) {\n        this.e = element('div');\n        this.a = anchor;\n        this.u(html);\n    }\n    m(target, anchor = null) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(target, this.n[i], anchor);\n        }\n        this.t = target;\n    }\n    u(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    p(html) {\n        this.d();\n        this.u(html);\n        this.m(this.t, this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(`Function called outside component initialization`);\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            info.blocks[i] = null;\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next, lookup.has(block.key));\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error(`Cannot have duplicate keys in a keyed each`);\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += \" \" + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += \" \" + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${String(value).replace(/\"/g, '&#34;').replace(/'/g, '&#39;')}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : ``;\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const prop_values = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, prop_values, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if ($$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set() {\n            // overridden by instance, if it has props\n        }\n    };\n}\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set() {\n        // overridden by instance, if it has props\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.22.2' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev(\"SvelteDOMRemove\", { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? [\"capture\"] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev(\"SvelteDOMAddEventListener\", { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev(\"SvelteDOMRemoveEventListener\", { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev(\"SvelteDOMRemoveAttribute\", { node, attribute });\n    else\n        dispatch_dev(\"SvelteDOMSetAttribute\", { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev(\"SvelteDOMSetProperty\", { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev(\"SvelteDOMSetDataset\", { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev(\"SvelteDOMSetData\", { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(`'target' is a required option`);\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn(`Component was already destroyed`); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error(`Infinite loop detected`);\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","export const CELL = Symbol(\"CELL\");\r\nexport const STR_ESCAPED = Symbol(\"STR_ESCAPED\");\r\nexport const STR_PLAIN = Symbol(\"STR_PLAIN\");\r\nexport const AGGREGATE = Symbol(\"AGGREGATE\");\r\nexport const SUBTOTAL = Symbol(\"SUBTOTAL\");\r\nexport const NUMBER = Symbol(\"NUMBER\");\r\nexport const COMPLEX_NUMBER = Symbol(\"COMPLEX_NUMBER\");\r\nexport const LIST = Symbol(\"LIST\");\r\nexport const MATRIX = Symbol(\"MATRIX\");\r\nexport const STRING = Symbol(\"STRING\");\r\nexport const ANY = Symbol(\"ANY\");\r\nexport const BOOLEAN = Symbol(\"BOOLEAN\");\r\nexport const FUNCTION = Symbol(\"FUNCTION\");\r\nexport const ARGUMENTS = Symbol(\"ARGUMENTS\");\r\nexport const NULL = Symbol(\"NULL\"); // Blank cell\r\nexport const ARRAY = Symbol(\"ARRAY\"); // return value of a array formula aka multiple return values\r\nexport const ERROR = Symbol(\"ERROR\");\r\nexport const DATE = Symbol(\"DATE\");\r\nexport const TIME = Symbol(\"TIME\");\r\nexport const DATETIME = Symbol(\"DATETIME\");\r\nexport const TRACE = Symbol(\"_TRACE\");\r\nexport const CELL_TRACE = Symbol(\"_CELL_TRACE\");\r\nexport const HYPERLINK = Symbol(\"HYPERLINK\");\r\nexport const NAVALUE = Symbol(\"#N/A\");\r\nexport const VVALUE = Symbol(\"#VALUE!\");\r\nexport const REFVALUE = Symbol(\"#REF!\");\r\nexport const NUMVALUE = Symbol(\"#NUM\");\r\nexport const DIV0 = Symbol(\"#DIV/0!\");\r\nexport const NULLE= Symbol(\"#NULL!\");\r\nexport const NAMEE = Symbol(\"#NAME?\");\r\nexport const GETTINGDATA= Symbol(\"#GETTING_DATA\");\r\nexport const INLINE = Symbol(\"INLINE\");\r\nexport const HIDDEN = Symbol(\"HIDDEN\"); // cell visibility, set meta:{visibility:HIDDEN} when cell is hidden; effects some functions\r\nexport const NATURALREF = Symbol(\"NATURAL_REFERENCE\");\r\nexport const CIRCULAR = Symbol(\"CIRCULAR_REFERENCE\");\r\n\r\nexport const CC2Currency = {\r\n    AD: \"EUR\",\r\n    AE: \"AED\",\r\n    AF: \"AFN\",\r\n    AG: \"XCD\",\r\n    AI: \"XCD\",\r\n    AL: \"ALL\",\r\n    AM: \"AMD\",\r\n    AN: \"ANG\",\r\n    AO: \"AOA\",\r\n    AQ: \"AQD\",\r\n    AR: \"ARS\",\r\n    AS: \"EUR\",\r\n    AT: \"EUR\",\r\n    AU: \"AUD\",\r\n    AW: \"ANG\",\r\n    AX: \"EUR\",\r\n    AZ: \"AZN\",\r\n    BA: \"BAM\",\r\n    BB: \"BBD\",\r\n    BD: \"BDT\",\r\n    BE: \"EUR\",\r\n    BF: \"XOF\",\r\n    BG: \"BGN\",\r\n    BH: \"BHD\",\r\n    BI: \"BIF\",\r\n    BJ: \"XOF\",\r\n    BL: \"EUR\",\r\n    BM: \"BMD\",\r\n    BN: \"BND\",\r\n    BO: \"BOB\",\r\n    BR: \"BRL\",\r\n    BS: \"BSD\",\r\n    BT: \"INR\",\r\n    BV: \"NOK\",\r\n    BW: \"BWP\",\r\n    BY: \"BYR\",\r\n    BZ: \"BZD\",\r\n    CA: \"CAD\",\r\n    CC: \"AUD\",\r\n    CD: \"CDF\",\r\n    CF: \"XAF\",\r\n    CG: \"XAF\",\r\n    CH: \"CHF\",\r\n    CI: \"XOF\",\r\n    CK: \"NZD\",\r\n    CL: \"CLP\",\r\n    CM: \"XAF\",\r\n    CN: \"CNY\",\r\n    CO: \"COP\",\r\n    CR: \"CRC\",\r\n    CU: \"CUP\",\r\n    CV: \"CVE\",\r\n    CX: \"AUD\",\r\n    CY: \"CYP\",\r\n    CZ: \"CZK\",\r\n    DE: \"EUR\",\r\n    DJ: \"DJF\",\r\n    DK: \"DKK\",\r\n    DM: \"XCD\",\r\n    DO: \"DOP\",\r\n    DZ: \"DZD\",\r\n    EC: \"ECS\",\r\n    EE: \"EEK\",\r\n    EG: \"EGP\",\r\n    EH: \"MAD\",\r\n    ER: \"ETB\",\r\n    ES: \"EUR\",\r\n    ET: \"ETB\",\r\n    FI: \"EUR\",\r\n    FJ: \"FJD\",\r\n    FK: \"FKP\",\r\n    FM: \"USD\",\r\n    FO: \"DKK\",\r\n    FR: \"EUR\",\r\n    GA: \"XAF\",\r\n    GB: \"GBP\",\r\n    GD: \"XCD\",\r\n    GE: \"GEL\",\r\n    GF: \"EUR\",\r\n    GG: \"GGP\",\r\n    GH: \"GHS\",\r\n    GI: \"GIP\",\r\n    GL: \"DKK\",\r\n    GM: \"GMD\",\r\n    GN: \"GNF\",\r\n    GP: \"EUR\",\r\n    GQ: \"XAF\",\r\n    GR: \"EUR\",\r\n    GS: \"GBP\",\r\n    GT: \"GTQ\",\r\n    GU: \"USD\",\r\n    GW: \"XOF\",\r\n    GY: \"GYD\",\r\n    HK: \"HKD\",\r\n    HM: \"AUD\",\r\n    HN: \"HNL\",\r\n    HR: \"HRK\",\r\n    HT: \"HTG\",\r\n    HU: \"HUF\",\r\n    ID: \"IDR\",\r\n    IE: \"EUR\",\r\n    IL: \"ILS\",\r\n    IM: \"GBP\",\r\n    IN: \"INR\",\r\n    IO: \"USD\",\r\n    IQ: \"IQD\",\r\n    IR: \"IRR\",\r\n    IS: \"ISK\",\r\n    IT: \"EUR\",\r\n    JE: \"GBP\",\r\n    JM: \"JMD\",\r\n    JO: \"JOD\",\r\n    JP: \"JPY\",\r\n    KE: \"KES\",\r\n    KG: \"KGS\",\r\n    KH: \"KHR\",\r\n    KI: \"AUD\",\r\n    KM: \"KMF\",\r\n    KN: \"XCD\",\r\n    KP: \"KPW\",\r\n    KR: \"KRW\",\r\n    KW: \"KWD\",\r\n    KY: \"KYD\",\r\n    KZ: \"KZT\",\r\n    LA: \"LAK\",\r\n    LB: \"LBP\",\r\n    LC: \"XCD\",\r\n    LI: \"CHF\",\r\n    LK: \"LKR\",\r\n    LR: \"LRD\",\r\n    LS: \"LSL\",\r\n    LT: \"LTL\",\r\n    LU: \"EUR\",\r\n    LV: \"LVL\",\r\n    LY: \"LYD\",\r\n    MA: \"MAD\",\r\n    MC: \"EUR\",\r\n    MD: \"MDL\",\r\n    ME: \"EUR\",\r\n    MF: \"ANG\",\r\n    MG: \"MGA\",\r\n    MH: \"USD\",\r\n    MK: \"MKD\",\r\n    ML: \"XOF\",\r\n    MM: \"MMK\",\r\n    MN: \"MNT\",\r\n    MO: \"MOP\",\r\n    MP: \"USD\",\r\n    MQ: \"EUR\",\r\n    MR: \"MRO\",\r\n    MS: \"XCD\",\r\n    MT: \"MTL\",\r\n    MU: \"MUR\",\r\n    MV: \"MVR\",\r\n    MW: \"MWK\",\r\n    MX: \"MXN\",\r\n    MY: \"MYR\",\r\n    MZ: \"MZN\",\r\n    NA: \"NAD\",\r\n    NC: \"XPF\",\r\n    NE: \"XOF\",\r\n    NF: \"AUD\",\r\n    NG: \"NGN\",\r\n    NI: \"NIO\",\r\n    NL: \"EUR\",\r\n    NO: \"NOK\",\r\n    NP: \"NPR\",\r\n    NR: \"AUD\",\r\n    NU: \"NZD\",\r\n    NZ: \"NZD\",\r\n    OM: \"OMR\",\r\n    PA: \"PAB\",\r\n    PE: \"PEN\",\r\n    PF: \"XPF\",\r\n    PG: \"PGK\",\r\n    PH: \"PHP\",\r\n    PK: \"PKR\",\r\n    PL: \"PLN\",\r\n    PM: \"EUR\",\r\n    PN: \"NZD\",\r\n    PR: \"USD\",\r\n    PS: \"JOD\",\r\n    PT: \"EUR\",\r\n    PW: \"USD\",\r\n    PY: \"PYG\",\r\n    QA: \"QAR\",\r\n    RE: \"EUR\",\r\n    RO: \"RON\",\r\n    RS: \"RSD\",\r\n    RU: \"RUB\",\r\n    RW: \"RWF\",\r\n    SA: \"SAR\",\r\n    SB: \"SBD\",\r\n    SC: \"SCR\",\r\n    SD: \"SDG\",\r\n    SE: \"SEK\",\r\n    SG: \"SGD\",\r\n    SH: \"GBP\",\r\n    SI: \"EUR\",\r\n    SJ: \"NOK\",\r\n    SK: \"SKK\",\r\n    SL: \"SLL\",\r\n    SM: \"EUR\",\r\n    SN: \"XOF\",\r\n    SO: \"SOS\",\r\n    SR: \"SRD\",\r\n    ST: \"STD\",\r\n    SV: \"SVC\",\r\n    SY: \"SYP\",\r\n    SZ: \"SZL\",\r\n    TC: \"USD\",\r\n    TD: \"XAF\",\r\n    TF: \"EUR\",\r\n    TG: \"XOF\",\r\n    TH: \"THB\",\r\n    TJ: \"TJS\",\r\n    TK: \"NZD\",\r\n    TM: \"TMT\",\r\n    TN: \"TND\",\r\n    TO: \"TOP\",\r\n    TP: \"IDR\",\r\n    TR: \"TRY\",\r\n    TT: \"TTD\",\r\n    TV: \"AUD\",\r\n    TW: \"TWD\",\r\n    TZ: \"TZS\",\r\n    UA: \"UAH\",\r\n    UG: \"UGX\",\r\n    UM: \"USD\",\r\n    US: \"USD\",\r\n    USAF: \"USD\",\r\n    UY: \"UYU\",\r\n    UZ: \"UZS\",\r\n    VA: \"EUR\",\r\n    VC: \"XCD\",\r\n    VE: \"VEF\",\r\n    VG: \"USD\",\r\n    VI: \"USD\",\r\n    VN: \"VND\",\r\n    VU: \"VUV\",\r\n    WF: \"XPF\",\r\n    WS: \"EUR\",\r\n    YE: \"YER\",\r\n    YT: \"EUR\",\r\n    ZA: \"ZAR\",\r\n    ZM: \"ZMK\",\r\n    ZW: \"ZWD\",\r\n  };\r\n\r\n\r\nexport default {\r\n    CELL,\r\n    STR_ESCAPED,\r\n    STR_PLAIN,\r\n    AGGREGATE,\r\n    SUBTOTAL,\r\n    NUMBER,\r\n    COMPLEX_NUMBER,\r\n    LIST,\r\n    MATRIX,\r\n    STRING,\r\n    ANY,\r\n    BOOLEAN,\r\n    FUNCTION,\r\n    ARGUMENTS,\r\n    NULL,\r\n    ARRAY,\r\n    ERROR,\r\n    DATE,\r\n    TIME,\r\n    DATETIME,\r\n    TRACE,\r\n    CELL_TRACE,\r\n    HYPERLINK,\r\n    NAVALUE,\r\n    VVALUE,\r\n    REFVALUE,\r\n    NUMVALUE,\r\n    DIV0,\r\n    NULLE,\r\n    NAMEE,\r\n    GETTINGDATA,\r\n    INLINE,\r\n    HIDDEN,\r\n    NATURALREF,\r\n    CIRCULAR,\r\n    CC2Currency\r\n};","import {\r\n    CELL,\r\n    STR_ESCAPED,\r\n    STR_PLAIN,\r\n    AGGREGATE,\r\n    SUBTOTAL,\r\n    NUMBER,\r\n    COMPLEX_NUMBER,\r\n    LIST,\r\n    MATRIX,\r\n    STRING,\r\n    ANY,\r\n    BOOLEAN,\r\n    FUNCTION,\r\n    ARGUMENTS,\r\n    NULL,\r\n    ARRAY,\r\n    ERROR,\r\n    DATE,\r\n    TIME,\r\n    DATETIME,\r\n    TRACE,\r\n    CELL_TRACE,\r\n    HYPERLINK,\r\n    NAVALUE,\r\n    VVALUE,\r\n    REFVALUE,\r\n    NUMVALUE,\r\n    DIV0,\r\n    NULLE,\r\n    NAMEE,\r\n    GETTINGDATA,\r\n    INLINE,\r\n    HIDDEN,\r\n    NATURALREF,\r\n    CIRCULAR,\r\n    CC2Currency,\r\n  } from \"./types\";\r\n\r\n  const BESSEL = {\r\n    /* todo: get from https://github.com/SheetJS/bessel */\r\n    /* or maybe require( '@stdlib/math/base/special/besselj0' );? */\r\n};\r\n\r\n  const romannumeral_classic = {\r\n    \"I\": 1,\r\n    \"IV\": 4,\r\n    \"V\": 5,\r\n    \"IX\": 9,\r\n    \"X\": 10,\r\n    \"XL\": 40,\r\n    \"L\": 50,\r\n    \"XC\": 90,\r\n    \"C\": 100,\r\n    \"CD\": 400,\r\n    \"D\": 500,\r\n    \"CM\": 900,\r\n    \"M\": 1000,\r\n};\r\nconst romannumeral_baseSet = romannumeral_classic;\r\nconst romannumeral_mode1 = {\r\n    ...romannumeral_classic,\r\n    \"LD\": 500-50,\r\n    \"VL\": 50-5,   \r\n}\r\nconst romannumeral_mode2 = {\r\n    ...romannumeral_mode1,\r\n    \"IX\": 10-1,\r\n    \"XD\": 500-10,\r\n}\r\nconst romannumeral_mode3 = {\r\n    ...romannumeral_mode2,\r\n    \"VD\": 500-5,\r\n}\r\nconst romannumeral_simplified = {\r\n    ...romannumeral_baseSet,\r\n    \"ID\": 500-1,\r\n}\r\nconst romannumeral_extended = {\r\n    \"Mↁ\": 4000,\r\n    \"ↁ\": 5000,\r\n    \"Mↂ\": 9000, \r\n    \"ↂ\": 10000,\r\n    \"ↂↇ\": 40000,\r\n    \"ↇ\": 50000,\r\n    \"ↂↈ\" : 90000,\r\n    \"ↈ\": 100000\r\n};\r\nconst romannumeral_romanSymbols = {\r\n    \"Ⅰ\": 1,\r\n    \"Ⅱ\": 2,\r\n    \"Ⅲ\": 3,\r\n    \"Ⅳ\": 4,\r\n    \"Ⅴ\": 5,\r\n    \"Ⅵ\": 6,\r\n    \"Ⅶ\": 7, \r\n    \"Ⅷ\": 8,\r\n    \"Ⅸ\": 9,\r\n    \"Ⅹ\": 10,\r\n    \"Ⅺ\": 11,\r\n    \"Ⅻ\": 12,\r\n    \"ⅩⅬ\": 40,\r\n    \"Ⅼ\": 50,\r\n    \"ⅩⅭ\": 90,\r\n    \"Ⅽ\": 100,\r\n    \"ⅭⅮ\": 400,\r\n    \"Ⅾ\": 500,\r\n    \"ⅭⅯ\": 900,\r\n    \"Ⅿ\": 1000,      \r\n    ...romannumeral_extended\r\n};\r\nconst romannumeralmodes = new Map([\r\n    [ 0, romannumeral_classic ],\r\n    [ 1, romannumeral_mode1 ],\r\n    [ 2, romannumeral_mode2 ],\r\n    [ 3, romannumeral_mode3 ],\r\n    [ 4, romannumeral_simplified ],\r\n    [ true, romannumeral_baseSet ],\r\n    [ false, romannumeral_simplified ],\r\n    [ \"R\", romannumeral_romanSymbols ],\r\n    [ \"0E\", { ...romannumeral_classic, ...romannumeral_extended } ],\r\n    [ \"1E\", { ...romannumeral_mode1, ...romannumeral_extended, \"Dↁ\": 5000-500 } ],\r\n    [ \"2E\", { ...romannumeral_mode2, ...romannumeral_extended,\r\n        \"Dↁ\": 5000-500, \r\n        \"Cↂ\": 10000-100,\r\n        \"Cↁ\": 5000-100,\r\n        \"ↁↇ\": 50000-5000, \r\n        \"ↂↈ\": 100000-1000,\r\n        \"Mↇ\": 50000-1000,\r\n        \r\n    } ],\r\n    [ \"3E\", { ...romannumeral_mode3, ...romannumeral_extended,\r\n        \"Dↁ\": 5000-500, \r\n        \"Cↂ\": 10000-100,\r\n        \"Cↁ\": 5000-100,\r\n        \"Lↁ\": 5000-50,\r\n        \"ↁↇ\": 50000-5000, \r\n        \"ↂↈ\": 100000-1000,\r\n        \"Mↇ\": 50000-1000,\r\n        \"Dↇ\": 50000-500,\r\n    } ],\r\n    [ \"4E\", { ...romannumeral_simplified, ...romannumeral_extended,\r\n        \"Dↁ\": 5000-500, \r\n        \"Cↂ\": 10000-100,\r\n        \"Cↁ\": 5000-100,\r\n        \"Lↁ\": 5000-50,\r\n        \"Xↁ\": 5000-10,\r\n        \"ↁↇ\": 50000-5000, \r\n        \"ↂↈ\": 100000-1000,\r\n        \"Mↇ\": 50000-1000,\r\n        \"Dↇ\": 50000-500,\r\n        \"Cↇ\": 50000-100,\r\n    } ],\r\n    [ \"EE\", { ...romannumeral_simplified, ...romannumeral_extended,\r\n        \"Dↁ\": 5000-500, \r\n        \"Cↂ\": 10000-100,\r\n        \"Cↁ\": 5000-100,\r\n        \"Lↁ\": 5000-50,\r\n        \"Xↁ\": 5000-10,\r\n        \"Lↁ\": 5000-50, \r\n        \"Xↂ\": 10000-10,\r\n        \"Xↁ\": 5000-10,\r\n        \"Vↁ\": 5000-5,\r\n        \"Iↁ\": 5000-1,\r\n        \"Iↂ\": 10000-1,\r\n        \"Vↂ\": 10000-5,\r\n        \"ↁↇ\": 50000-5000, \r\n        \"ↂↈ\": 100000-1000,\r\n        \"Mↇ\": 50000-1000,\r\n        \"Dↇ\": 50000-500,\r\n        \"Cↇ\": 50000-100,\r\n        \"Lↇ\": 50000-50,\r\n        \"Xↇ\": 50000-10,\r\n        \"Xↈ\": 100000-10,\r\n        \"Lↈ\": 100000-50,\r\n        \"Vↇ\": 50000-5,\r\n        \"Iↇ\": 50000-1,\r\n        \"Iↈ\": 100000-1,\r\n        \"Vↈ\": 100000-5,\r\n        \"IM\": 1000 - 1,\r\n        \"VM\": 1000 - 5,\r\n    } ],\r\n    [ \"R\", romannumeral_romanSymbols ],\r\n    [ \"RE\", {\r\n        ...romannumeral_romanSymbols,\r\n        \"Ⅾↁ\": 5000-500, \r\n        \"Ⅽↂ\": 10000-100,\r\n        \"Ⅽↁ\": 5000-100,\r\n        \"Ⅼↁ\": 5000-50,\r\n        \"Ⅹↁ\": 5000-10,\r\n        \"Ⅼↁ\": 5000-50, \r\n        \"Ⅹↂ\": 10000-10,\r\n        \"Ⅹↁ\": 5000-10,\r\n        \"Ⅴↁ\": 5000-5,\r\n        \"Ⅰↁ\": 5000-1,\r\n        \"Ⅰↂ\": 10000-1,\r\n        \"Ⅴↂ\": 10000-5,\r\n        \"ↁↇ\": 50000-5000, \r\n        \"ↂↈ\": 100000-1000,\r\n        \"Ⅿↇ\": 50000-1000,\r\n        \"Ⅾↇ\": 50000-500,\r\n        \"Ⅽↇ\": 50000-100,\r\n        \"Ⅼↇ\": 50000-50,\r\n        \"Ⅹↇ\": 50000-10,\r\n        \"Ⅹↈ\": 100000-10,\r\n        \"Ⅼↈ\": 100000-50,\r\n        \"Ⅴↇ\": 50000-5,\r\n        \"Ⅰↇ\": 50000-1,\r\n        \"Ⅰↈ\": 100000-1,\r\n        \"Ⅴↈ\": 100000-5,\r\n        \"ⅠⅯ\": 1000 - 1,\r\n        \"ⅤⅯ\": 1000 - 5,\r\n    } ],\r\n    \r\n]);\r\n\r\n  const weight = {\r\n    \"g\": 1,\r\n    \"sg\": 6.85217658567918E-05,\r\n    \"lbm\": 0.00220462262184878,\r\n    \"u\": 6.02214179421676E+23,\r\n    \"ozm\": 0.0352739619495804,\r\n    \"grain\": 15.4323583529414,\r\n    \"cwt\": 2.20462262184878E-05,\r\n    \"shweight\": 2.20462262184878E-05,\r\n    \"uk_cwt\": 1.96841305522212E-05,\r\n    \"lcwt\": 1.96841305522212E-05,\r\n    \"hweight\": 1.96841305522212E-05,\r\n    \"stone\": 0.00015747304441777,\r\n    \"ton\": 1.10231131092439E-06,\r\n    \"uk_ton\": 9.84206527611061E-07,\r\n    \"LTON\": 9.84206527611061E-07,\r\n    \"brton\": 9.84206527611061E-07,\r\n};\r\nconst length = {\r\n    \"m\": 1,\r\n    \"mi\": 0.000621371192237334,\r\n    \"Nmi\": 0.000539956803455724,\r\n    \"in\": 39.3700787401575,\r\n    \"ft\": 3.28083989501312,\r\n    \"yd\": 1.09361329833771,\r\n    \"ang\": 10000000000,\r\n    \"ell\": 0.874890638670166,\r\n    \"ly\": 1.05700083402462E-16,\r\n    \"parsec\": 3.24077928966473E-17,\r\n    \"pc\": 3.24077928966473E-17,\r\n    \"Picapt\": 2834.64566929134,\r\n    \"Pica\": 2834.64566929134,\r\n    \"pica\": 236.220472440945,\r\n    \"survey_mi\": 0.00062136994949495,\r\n};\r\nconst time = {\r\n    \"yr\": 0.0027378507871321,\r\n    \"day\": 1,\r\n    \"d\": 1,\r\n    \"hr\": 24,\r\n    \"mn\": 1440,\r\n    \"min\": 1440,\r\n    \"sec\": 86400,\r\n    \"s\": 86400,\r\n};\r\nconst press = {\r\n    \"Pa\": 1,\r\n    \"p\": 1,\r\n    \"atm\": 9.86923266716013E-06,\r\n    \"at\": 9.86923266716013E-06,\r\n    \"mmHg\": 0.00750063755419211,\r\n    \"psi\": 0.000145037737730209,\r\n    \"Torr\": 0.0075006168270417,\r\n};\r\nconst force = {\r\n    \"N\": 1,\r\n    \"dyn\": 100000,\r\n    \"dy\": 100000,\r\n    \"lbf\": 0.22480894309971,\r\n    \"pond\": 101.971621297793,\r\n};\r\nconst energy = {\r\n    \"J\": 1,\r\n    \"e\": 10000000,\r\n    \"c\": 0.239005736137667,\r\n    \"cal\": 0.238845896627496,\r\n    \"eV\": 6241509647120420000,\r\n    \"ev\": 6241509647120420000,\r\n    \"HPh\": 3.72506135998619E-07,\r\n    \"hh\": 3.72506135998619E-07,\r\n    \"Wh\": 0.000277777777777778,\r\n    \"wh\": 0.000277777777777778,\r\n    \"flb\": 0.737562149277265,\r\n    \"BTU\": 0.000947817120313317,\r\n    \"btu\": 0.000947817120313317,\r\n};\r\nconst power = {\r\n    \"HP\": 0.00134102208959503,\r\n    \"h\": 0.00134102208959503,\r\n    \"PS\": 0.0013596216173039,\r\n    \"W\": 1,\r\n    \"w\": 1,\r\n};\r\nconst magn = {\r\n    \"T\": 1,\r\n    \"ga\": 10000,\r\n};\r\nconst temperature = {\r\n    \"C\": 1,\r\n    \"cel\": 1,\r\n    \"F\": 33.8,\r\n    \"fah\": 33.8,\r\n    \"K\": 274.15,\r\n    \"kel\": 274.15,\r\n    \"Rank\": 493.47,\r\n    \"Reau\": 0.8,\r\n};\r\nconst space = {\r\n    \"tsp\": 202884.136211058,\r\n    \"tspm\": 200000,\r\n    \"tbs\": 67628.045403686,\r\n    \"oz\": 33814.022701843,\r\n    \"cup\": 4226.75283773038,\r\n    \"pt\": 2113.37641886519,\r\n    \"us_pt\": 2113.37641886519,\r\n    \"uk_pt\": 1759.7539863927,\r\n    \"qt\": 1056.68820943259,\r\n    \"uk_qt\": 879.876993196351,\r\n    \"gal\": 264.172052358148,\r\n    \"uk_gal\": 219.969248299088,\r\n    \"l\": 1000,\r\n    \"L\": 1000,\r\n    \"lt\": 1000,\r\n    \"ang3\": 1E+30,\r\n    \"ang^3\": 1E+30,\r\n    \"barrel\": 6.2898107704321,\r\n    \"bushel\": 28.3775932584017,\r\n    \"ft3\": 35.3146667214886,\r\n    \"ft^3\": 35.3146667214886,\r\n    \"in3\": 61023.7440947323,\r\n    \"in^3\": 61023.7440947323,\r\n    \"ly3\": 1.18093498844171E-48,\r\n    \"ly^3\": 1.18093498844171E-48,\r\n    \"m3\": 1,\r\n    \"m^3\": 1,\r\n    \"mi3\": 2.39912758578928E-10,\r\n    \"mi^3\": 2.39912758578928E-10,\r\n    \"yd3\": 1.30795061931439,\r\n    \"yd^3\": 1.30795061931439,\r\n    \"Nmi3\": 1.57426214685811E-10,\r\n    \"Nmi^3\": 1.57426214685811E-10,\r\n    \"Picapt3\": 22776990435.8706,\r\n    \"Picapt^3\": 22776990435.8706,\r\n    \"Pica3\": 22776990435.8706,\r\n    \"Pica^3\": 22776990435.8706,\r\n    \"GRT\": 0.353146667214886,\r\n    \"regton\": 0.353146667214886,\r\n    \"MTON\": 0.882866668037215,\r\n};\r\nconst area = {\r\n    \"uk_acre\": 0.000247105381467165,\r\n    \"us_acre\": 0.000247104393046628,\r\n    \"ang2\": 1E+20,\r\n    \"ar\": 0.01,\r\n    \"ft2\": 10.7639104167097,\r\n    \"ft^2\": 10.7639104167097,\r\n    \"ha\": 0.0001,\r\n    \"in2\": 1550.0031000062,\r\n    \"in^2\": 1550.0031000062,\r\n    \"ly2\": 1.11725076312873E-32,\r\n    \"ly^2\": 1.11725076312873E-32,\r\n    \"m2\": 1,\r\n    \"m^2\": 1,\r\n    \"Morgen\": 0.0004,\r\n    \"mi2\": 3.86102158542446E-07,\r\n    \"mi^2\": 3.86102158542446E-07,\r\n    \"Nmi2\": 2.91553349598123E-07,\r\n    \"Nmi^2\": 2.91553349598123E-07,\r\n    \"Picapt2\": 8035216.07043214,\r\n    \"Pica2\": 8035216.07043214,\r\n    \"Pica^2\": 8035216.07043214,\r\n    \"Picapt^2\": 8035216.07043214,\r\n    \"yd2\": 1.19599004630108,\r\n    \"yd^2\": 1.19599004630108,\r\n};\r\nconst computer = {\r\n    \"bit\": 1,\r\n    \"byte\": 0.125,\r\n};\r\nconst speed = {\r\n    \"admkn\": 0.000539611824837685,\r\n    \"kn\": 0.000539956803455723,\r\n    \"m/h\": 1,\r\n    \"m/hr\": 1,\r\n    \"m/s\": 0.000277777777777778,\r\n    \"m/sec\": 0.000277777777777778,\r\n    \"mph\": 0.000621371192237334,\r\n\r\n}\r\n\r\nconst prefixes = {\r\n  \"Yi\": 1.2089258196146292e+24,\r\n  \"Zi\": 1.1805916207174113e+21,\r\n  \"Ei\": 1152921504606847000,\r\n  \"Pi\": 1125899906842624,\r\n  \"Ti\": 1099511627776,\r\n  \"Gi\": 1073741824,\r\n  \"Mi\": 1048576,\r\n  \"ki\": 1024,\r\n  \"Y\": 1e+24,\r\n  \"Z\": 1e+21,\r\n  \"E\": 1000000000000000000,\r\n  \"P\": 1000000000000000,\r\n  \"T\": 1000000000000,\r\n  \"G\": 1000000000,\r\n  \"M\": 1000000,\r\n  \"k\": 1000,\r\n  \"h\": 100,\r\n  \"da\": 10,\r\n  \"e\": 10,\r\n  \"d\": 0.1,\r\n  \"c\": 0.01,\r\n  \"m\": 0.001,\r\n  \"u\": 0.000001,\r\n  \"n\": 1e-9,\r\n  \"p\": 1e-12,\r\n  \"f\": 1e-15,\r\n  \"a\": 1e-18,\r\n  \"z\": 1.0000000000000001e-21,\r\n  \"y\": 1.0000000000000001e-24,\r\n};\r\n\r\nconst functions = {\r\n    _TOSEARCHSTRING: ([string, start=true, end=true, casesensitive=false], context) => new RegExp((start?\"^\":\"\")+\r\n        string.replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&') // escape characters with special meaning to js regex\r\n                .replace(/([^~](~~))*\\*/g,\"$1.*\") // match non-escaped *\r\n                .replace(/([^~](~~))*\\?/g,\"$1.\") // match non-escaped ?\r\n                .replace(/~([?*])/g,\"\\\\$1\") // match escaped ? and *\r\n                .replace(/~~/g, \"~\") + // convert ~~ as per excel spec\r\n             (end?\"$\":\"\"), casesensitive?\"\":'i'),\r\n    _GREATER: ([a,b], context) => a>b,\r\n    _SMALLER: ([a,b], context) => a<b,\r\n    _EQUAL: ([a,b], context) => a==b,\r\n    _GREATER_OR_EQUAL: ([a,b], context) => context.functions._GREATER([a,b], context) || context.functions._EQUAL([a,b], context),\r\n    _SMALLER_OR_EQUAL: ([a,b], context) => context.functions._SMALLER([a,b], context) || context.functions._EQUAL([a,b], context),\r\n    SUM: (allargs, context) => {\r\n      const result = allargs.reduce((sum, { value, type }) => {\r\n          switch(type) {\r\n              case NULL:\r\n                return sum;\r\n            case NUMBER:\r\n              return sum + value;\r\n            case LIST:\r\n              const {value:s} = context.functions.SUM(value, context);\r\n              return sum+s;\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in SUM\");\r\n          }\r\n      }, 0);\r\n      return { type: NUMBER, value: result };\r\n    },\r\n    AVERAGE: (allargs, context) => {\r\n        console.log(\"allargs\", allargs);\r\n      const [result,ccount] = allargs.reduce(([sum,count], { value, type }) => {\r\n          switch(type) {\r\n              case NULL:\r\n                return [sum,count];\r\n            case NUMBER:\r\n              return [sum + value,count+1];\r\n            case LIST:\r\n              const { result, ccount } = context.functions.AVERAGE(value).meta;\r\n              return [sum+result, count+ccount ];\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in AVERAGE\");\r\n          }\r\n      }, [0,0]);\r\n      return { type: NUMBER, value: result/ccount, meta: { result, ccount } };\r\n    },\r\n    _CELL_COUNT: (allargs, _context) => {\r\n      const result = allargs.reduce((sum, { value, type }) => {\r\n          switch(type) {\r\n              case NULL:\r\n            case ERROR:\r\n            case BOOLEAN:\r\n                return sum;\r\n            case NUMBER:\r\n            case DATE:\r\n              return sum + 1;\r\n            case LIST:\r\n                const {value:count} = _context.functions._CELL_COUNT(value, _context);\r\n                  return sum + count;\r\n            case STRING:\r\n                return Number.isNaN(parseFloat(value)) ? sum : sum + 1; \r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in SUM\");\r\n          }\r\n      }, 0);\r\n      return { type: NUMBER, value: result };\r\n    },\r\n    _CELL_COUNTA: (allargs, _context) => {\r\n      const result = allargs.reduce((sum, { value, type }) => {\r\n          switch(type) {\r\n              case NULL:\r\n                return sum;\r\n            case NUMBER:\r\n            case DATE:\r\n            case STRING:\r\n            case ERROR:\r\n            case BOOLEAN:\r\n              return sum + 1;\r\n            case LIST:\r\n                const {value:count} = _context.functions._CELL_COUNTA(value, _context);\r\n                  return sum + count;\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in SUM\");\r\n          }\r\n      }, 0);\r\n      return { type: NUMBER, value: result };\r\n    },\r\n    COUNT: (args, _context) => {\r\n      return _context.functions._CELL_COUNT(args, _context);\r\n    },\r\n    COUNTA: (args, _context) => {\r\n      return _context.functions._CELL_COUNTA(args, _context);\r\n    },\r\n    COUNTBLANK: ([range], context) => {\r\n      if(range.type !== LIST) {\r\n          throw new Error(\"COUNTA must be supplied a LIST, found value \"+String(range.value)+\" of type \"+String(range.type));\r\n      }\r\n      return { type: NUMBER, value: range.value.filter(({ value, type }) => type === NULL || value === \"\").length };\r\n    },\r\n    IF: ([iff, thenn, elsee], context) => {\r\n      if(iff.type !== BOOLEAN) {\r\n          throw new Error(\"iff must be supplied a BOOLEAN as first argument, found value \"+String(iff.value)+\" of type \"+String(iff.type));\r\n      }\r\n      return iff.value ? thenn : elsee;\r\n    },\r\n    TRIM: ([v], context) => {\r\n      if(v.type !== STRING) {\r\n          throw new Error(\"TRIM must be supplied a STRING, found value \"+String(v.value)+\" of type \"+String(v.type));\r\n      }\r\n      const result = v.value.trim().replace(/[ ][ ]+/g, \" \")\r\n      return { type: STRING, value: result };\r\n    },\r\n    MAX: (allargs, context) => {\r\n      const result = allargs.reduce((max, { value, type }) => {\r\n          switch(type) {\r\n            case STRING:\r\n            case NULL:\r\n    return max;\r\n            case NUMBER:\r\n              return max < value ? value : max;\r\n            case LIST:\r\n              const {value:v} = context.functions.MAX(value,context);\r\n              return max < v? v: max;\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in MAX\");\r\n          }\r\n      }, -Infinity);\r\n      return { type: NUMBER, value: result };\r\n    },\r\n    MIN: (allargs, context) => {\r\n      const result = allargs.reduce((max, { value, type }) => {\r\n          switch(type) {\r\n            case STRING:\r\n            case NULL:\r\n    return max;\r\n            case NUMBER:\r\n              return max > value ? value : max;\r\n            case LIST:\r\n              const {value:v} = context.functions.MIN(value,context);\r\n              return max > v? v: max;\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in MIN\");\r\n          }\r\n      }, Infinity);\r\n      return { type: NUMBER, value: result };\r\n    },\r\n    CONCATENATE: (allargs, context) => ({ type: STRING, value: allargs.map(i => i.value||\"\").join(\"\") }),\r\n    SUBSTITUTE: ([{ value: text }, { value: oldText }, { value: newText }, { value: nthAppearance  }={}], context) => {\r\n        let i = 0;\r\n        return ({ type: STRING, value: text.replace(new RegExp(oldText, \"g\"), nthAppearance ? (match, pos, original) => {\r\n          i++;\r\n          return (i == nthAppearance) ? newText : match;\r\n          } : newText)\r\n        });\r\n    },\r\n    VALUE: ([arg], context) => ({ type: NUMBER, value: parseFloat(arg.value) }),\r\n    EXACT: ([a, b], context) => ({ type: BOOLEAN, value: a.value === b.value && a.type === b.type }),\r\n    UPPER: ([arg], context) => ({ type: STRING, value: arg.value.toUpperCase() }),\r\n    LOWER: ([arg], context) => ({ type: STRING, value: arg.value.toLowerCase() }),\r\n    PROPER: ([arg], context) => ({ type: STRING, value: arg.value.toLowerCase()\r\n      .split(' ')\r\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\r\n      .join(' ') }),\r\n    LEFT: ([{ value: text }, { value: numChars = 1 } = { numChars: 1 }], context) =>\r\n        ({ type: STRING, value: text.slice(0, numChars) }),\r\n    RIGHT: ([{ value: text }, { value: numChars = 1 } = { numChars: 1 }], context) =>\r\n        ({ type: STRING, value: text.slice(text.length - numChars) }),\r\n    MID: ([{ value: text }, { value: startNum}, { value: numChars}], context) =>\r\n        ({ type: STRING, value: text.slice(startNum, startNum+numChars) }),\r\n    AND: (allargs, context) => ({ type: BOOLEAN, value: allargs.reduce((p, i) => i.value && p, true) }),\r\n    OR: (allargs, context) => ({ type: BOOLEAN, value: allargs.reduce((p, i) => i.value || p, true) }),\r\n    XOR: (allargs, context) => ({ type: BOOLEAN, value: allargs.reduce((p, i) => (i.value && !p) || (!i.value && p), false) }),\r\n    NOT: ([arg], context) => ({ type: BOOLEAN, value: !arg.value }),\r\n    IFERROR: ([iserror, valueiferror], context) => iserror.type === ERROR ? valueiferror : iserror,\r\n    IFNA: ([iserror, valueiferror], context) => iserror.type === ERROR && iserror.value === NAVALUE ? valueiferror : iserror,\r\n    // sumif, sumifs\r\n    SUMPRODUCT: ([{ value: arg0 }, ...args], context) => args.every(i => i.value.length === arg0.length) ?\r\n        { type: NUMBER, value: arg0.reduce((p, { value }, idx) => p + args.reduce((p, { value: arg }) => arg[idx].value * p, value), 0) }:\r\n        { type: ERROR, value: VVALUE },\r\n    RAND: () => ({ type: NUMBER, value: Math.random() }),\r\n    RANDBETWEEN: ([{value:min}, {value:max}], context) => ({ type: NUMBER, value: Math.floor(Math.random() * (max - min + 1) + min) }),\r\n    ROUND: ([{value:num}, {value: dec}], context) => ({ type: NUMBER, value: \r\n        dec < 0 ?\r\n        Math.round(num * Math.pow(10, dec)) * Math.pow(10, -dec) : // Avoid rounding errors\r\n        Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec) // Avoid rounding errors\r\n    }),\r\n    ROUNDUP: ([{value:num}, {value: dec}], context) => ({ type: NUMBER, value: Math.ceil(num * Math.pow(10, dec)) / Math.pow(10, dec) }),\r\n    ROUNDDOWN: ([{value:num}, {value: dec}], context) => ({ type: NUMBER, value: Math.floor(num * Math.pow(10, dec)) / Math.pow(10, dec) }),\r\n    \r\n    MROUND: ([{value}, {value: dec}], context) => ({ type: NUMBER, value: dec*Math.round(value/dec) }),\r\n    FLOOR: ([{value}, {value: dec}], context) => ({ type: NUMBER, value: dec*Math.floor(value/dec) }),\r\n    CEILING: ([{value}, {value: dec}], context) => ({ type: NUMBER, value: dec*Math.ceil(value/dec) }),\r\n    INT: ([{value}, {value: dec}], context) => ({ type: NUMBER, value: Math.floor(value) }),\r\n    TRUNC: ([{value}, {value: dec}], context) => {\r\n      const m = (value+\"\").match(new RegExp(\"(\\\\d+\\\\.\\\\d{\" + dec + \"})(\\\\d)\"));\r\n      return { type: NUMBER, value: m ? parseFloat(m[1]) : value };\r\n    },\r\n    EVEN: ([{value}], context) => ({ type: NUMBER, value: 2*Math.round(value/2) }),\r\n    ODD: ([{value}], context) => ({ type: NUMBER, value: value<0 ? 2*Math.ceil(value/2)-1 : 2*Math.floor(value/2)+1 }),\r\n    MOD: ([{value:n}, {value:d}], context) => ({ type: NUMBER, value: n - d*Math.floor(n/d) }),\r\n    SMALL: ([{value}, {value:k}], context) => ({ type: NUMBER, value: value.sort(({value:a},{value:b}) => a-b)[k-1] }),\r\n    LARGE: ([{value}, {value:k}], context) => ({ type: NUMBER, value: value.sort(({value:a},{value:b}) => b-a)[k-1] }),\r\n    COUNTIF: ([{value:range,type:t1},{value:criteria,type}], context) => {\r\n        if(t1 !== LIST) {\r\n          throw new Error(\"COUNTIF must be supplied a LIST, found value \"+String(value)+\" of type \"+String(t1));\r\n        }\r\n        const f = context.functions._CRITMATCHER([{value:criteria,type}], context);\r\n        return { type: NUMBER, value: range.filter(f).length };\r\n    },\r\n    _CRITMATCHER: ([{value:criterium,type}], context) => {\r\n        if(type!==STRING) {\r\n            const f = ({value}) => value == criterium;\r\n            f.criterium = criterium;\r\n            return f;\r\n        }\r\n        const cf = {\r\n          \">=\": u => u >= parseFloat(criterium.substring(2)),\r\n          \"<=\": u => u <= parseFloat(criterium.substring(2)),\r\n          \"<>\": u => u != parseFloat(criterium.substring(2))\r\n        }[criterium.substring(0,2)] ||\r\n        {\r\n          \">\": u => u > parseFloat(criterium.substring(1)),\r\n          \"<\": u => u < parseFloat(criterium.substring(1)),\r\n          \"=\": u => u == parseFloat(criterium.substring(1)) || (\"\"+u) === criterium.substring(1),\r\n        }[criterium.substring(0,1)];\r\n        \r\n        if(cf) {\r\n            const f = ({value}) => cf(value);\r\n            f.criterium = criterium;\r\n            return f;\r\n        }\r\n        \r\n        const matcher = context.functions._TOSEARCHSTRING([criterium]);\r\n        // new RegExp(\"^\"+criterium.replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&').replace(/\\*/g,\".*\").replace(/\\?/g,\".\")+\"$\");\r\n        const f = ({value}) => matcher.test(value);\r\n        f.criterium = criterium;\r\n        return f;\r\n    },\r\n    COUNTIFS: (args, context) => {\r\n        if(args.length < 2) {\r\n            throw new Error(\"Excepted 'criteria_range1, criteria1', but found \"+(args.length?\"'criteria_range1'\":\"no arguments\"));\r\n        }\r\n        if(args.length % 2) { // if 1\r\n            throw new Error(\"Wrong number of arguments, excepted 'criteria_range1, criteria1, [criteria_range2, criteria2]...', but found \"+\r\n            args.map((i, idx) => idx%2?\"criteria\"+Math.ceil((idx+1)/2):\"criteria_range\"+Math.ceil((idx+1)/2)).join(\", \"));\r\n        }\r\n        const [ranges, criteria] = args.reduce(([l1,l2],arg,idx) => \r\n            idx%2?[l1,[...l2, arg]]:[[...l1, arg], l2], // sort into 2 lists, so that [a,1,b,2,c,3]->[[a,b,c],[1,2,3]]\r\n        [[],[]]);\r\n        if(!ranges.every((i,idx,arr) => i.length === arr[0].length)) {\r\n            throw new Error(\"All defined ranges need to have the same length\");\r\n        }\r\n        \r\n        const cfunctions = criteria.map(({value:criterium,type}) => {\r\n          return context.functions._CRITMATCHER([{value:criterium,type}], context);\r\n        });\r\n        return {\r\n            type: NUMBER,\r\n            value: ranges[0].value.reduce((count, _, idx) => // pick any range, they're all same length\r\n             // if in every range at current index (idx) the function for the current 'row' (jdx), add 1\r\n                count+ranges.every(({value:r},jdx) => cfunctions[jdx](r[idx])),\r\n            0)\r\n        };\r\n    },\r\n    VLOOKUP: ([lookup_value,table_array,col_index_num,range_lookup={ type: BOOLEAN, value: true }], context) => {\r\n        if(table_array.type === LIST) {\r\n            table_array = { type: MATRIX, value: [table_array.value] }\r\n        }\r\n        if(table_array.type !== MATRIX) {\r\n            throw new Error(\"Expected table_array to be a MATRIX but found \"+String(table_array.value)+\" (\"+String(table_array.type)+\")\");\r\n        }\r\n        \r\n        const idx = table_array.value[0].findIndex(i => lookup_value.value == i.value ||\r\n            (lookup_value.type === STRING && i.type === STRING && lookup_value.value.toLowerCase() === i.value.toLowerCase())\r\n        );\r\n        if(idx > -1) {\r\n            // Exact match\r\n            return table_array.value[col_index_num.value-1][idx];\r\n        }\r\n        if(!range_lookup.value) {\r\n            return { type: ERROR, value: NAVALUE };\r\n        }\r\n        // Range lookup: Return last values of values that are smaller than criteria\r\n        const searchr = [].concat(table_array.value[0]);\r\n        const { _GREATER } = context.functions;\r\n        let item = { type: ERROR, value: NAVALUE };\r\n        while(searchr.length) {\r\n            if(_GREATER(searchr[0].value, lookup_value.value)) {\r\n                return item;\r\n            }\r\n            const idx = table_array.value[0].length - searchr.length;// 0, 1, 2, 3, ....\r\n            item = table_array.value[col_index_num.value-1][idx];\r\n            searchr.shift();\r\n        }\r\n        return item;\r\n    },\r\n    INDEX: ([array,{value:row_num},{value:column_num}={value:1}], context) => {\r\n        if(array.type === LIST) {\r\n            array = { type: MATRIX, value: [array.value] }\r\n        }\r\n        if(array.type !== MATRIX) {\r\n            throw new Error(\"Expected table_array to be a MATRIX but found \"+String(array.value)+\" (\"+String(array.type)+\")\");\r\n        }\r\n        return array.value[row_num-1][column_num-1];\r\n    },\r\n    MATCH: ([lookup_value, lookup_array, {value:match_type}={type:NUMBER, value:1}], context) => {\r\n        if(table_array.type !== LIST) {\r\n            throw new Error(\"Expected table_array to be a LIST but found \"+String(table_array.value)+\" (\"+String(table_array.type)+\")\");\r\n        }\r\n        if([-1,0,1,\"-1\",\"0\",\"1\"].indexOf(match_type) === -1) {\r\n            throw new Error(\"Expected match_type to be one of [-1,0,1] but found \"+String(match_type.value)+\" (\"+String(match_type.type)+\")\");\r\n        }\r\n        const idx = table_array.value.findIndex(i => lookup_value.value == i.value ||\r\n            (lookup_value.type === STRING && i.type === STRING && lookup_value.value.toLowerCase() === i.value.toLowerCase())\r\n        );\r\n        if(idx > -1) {\r\n            return table_array.value[idx];\r\n        }\r\n        if(match_type === 0 || match_type === \"0\") {\r\n            return { type: ERROR, value: NAVALUE };\r\n        }\r\n        // Range lookup: Return last values of values that are smaller than criteria\r\n        const searchr = [].concat(table_array.value[0]);\r\n        let item = { type: ERROR, value: NAVALUE };\r\n        const { _GREATER, _SMALLER } = context.functions;\r\n        while(searchr.length) {\r\n            if((match_type === 1 || match_type === \"1\") && _GREATER(searchr[0].value, lookup_value.value)) {\r\n                return item;\r\n            }\r\n            if((match_type === -1 || match_type === \"-1\") && _SMALLER(searchr[0].value, lookup_value.value)) {\r\n                return item;\r\n            }\r\n            const idx = table_array.value[0].length - searchr.length;// 0, 1, 2, 3, ....\r\n            item = table_array.value[col_index_num.value-1][idx];\r\n            searchr.shift();\r\n        }\r\n        return item;\r\n    },\r\n    INDIRECT: ([ref_text, a1={value:true, type:BOOLEAN}], context) => {\r\n        const parsed = context.parser(ref_text.value, context);\r\n        if(!parsed) {\r\n            return { type: ERROR, value: REFVALUE };\r\n        }\r\n        // todo: validate with parsed.meta.type !== CELL\r\n        return parsed;\r\n    },\r\n    OFFSET: ([reference, {value:offsetrows}, {value:offsetcols}, height={}, width={}], functioncontext) => {\r\n        let topleft = reference;\r\n        if(reference.type === MATRIX) {\r\n            topleft = reference.value[0][0];\r\n        }\r\n        if(reference.type === LIST) {\r\n            topleft = reference.value[0];\r\n        }\r\n        if(topleft.meta.type !== CELL) {\r\n            throw new Error(\"Expected CELL, LIST<CELL> or MATRIX<CELL> as first argument of OFFSET, found \"+String(reference.value)+\" (\"+String(reference.type)+\") /\"+String(topleft.value)+\" (\"+String(topleft.meta.type)+\")\");\r\n        }\r\n        const top = topleft.meta.row + offsetrows;\r\n        const left = topleft.meta.col + offsetcols;\r\n        const heightvalue = height.value || reference.rowspan || 1;\r\n        const widthvalue = width.value || reference.colspan || 1;\r\n        const results = [];\r\n        let errorflag = false;\r\n        for(let row = top; row <= top+heightvalue-1; row++) {\r\n          const t = [];\r\n          for(let col = left; col <= left+widthvalue-1; col++) {\r\n              const v = context.getRow(row-1).getCol(col-1) || { value: REFVALUE, type: ERROR };\r\n              if(!v) { errorflag=true; }\r\n              t.push({ ...v, meta: { type: CELL, row, col } });\r\n          }\r\n          results.push(t);\r\n        }\r\n        if(errorflag) {\r\n            return { type: ERROR, value: REFVALUE, meta: { partial_results: results } };\r\n        }\r\n        if(results.length === 1 && results.every(r => r.length === 1)) {\r\n            return results[0][0]; // Single cell\r\n        }\r\n        if(results.length === 1) {\r\n            return { type: LIST, value: results[0], rowspan: 1, colspan: results[0].length }\r\n        }\r\n        if(results.every(r => r.length === 1)) {\r\n            return { type: LIST, value: results.map(i => i[0]), rowspan: results.length, colspan: 1 }\r\n        }\r\n        return {\r\n            type: MATRIX,\r\n            value: results,\r\n            get rowspan() { return results.length }, \r\n            get colspan() { return results[0].length },\r\n       };\r\n    },\r\n    TRANSPOSE: ([array], _context) => {\r\n        console.log(\"array\", array);\r\n        const { col: ccol, row: crow } = _context.currentcell;\r\n        if(array.type === LIST) {\r\n            return {\r\n                values: array.value.map((value, idx) => ({\r\n                    row: crow+(array.colspan>1 ? idx : 0)+1,\r\n                    col: ccol+(array.rowspan>1 ? idx : 0)+1,\r\n                    value\r\n                })),\r\n                type: ARRAY\r\n            };\r\n        }\r\n        if(array.type === MATRIX) {\r\n            const results = array.value[0].map((__, idx) => array.value.map((row, jdx) => ({\r\n                row: crow+idx+1,\r\n                col: ccol+jdx+1,\r\n                value: row[idx]\r\n            })));\r\n            return {\r\n              type: ARRAY,\r\n              value: results,\r\n              get rowspan() { return results.length }, \r\n              get colspan() { return results[0].length }, // always square selection\r\n            };\r\n        }\r\n        throw new Error(\"Expected LIST or MATRIX as first argument to TRANSPOSE, found \"+String(array.value)+\" (\"+String(array.type)+\")\");\r\n    },\r\n    HYPERLINK: ([{value:link_location}, {value:friendly_name}], _context) => ({\r\n        type: HYPERLINK,\r\n        meta: { href: link_location },\r\n        value: friendly_name || link_location\r\n    }),\r\n    FV: ([{value:rate}, {value:nper}, {value:pmt}={value:0}, {value:pv}={value:0}, {value:type}={value:0}], _context) => {\r\n        // pv *   (1+rate)^nper   +   pmt*(1+rate*type) * ( (1+rate)^nper -1 ) / rate) + FV = 0\r\n        // If rate =0 then (Pmt * Nper)+PV+FV=0\r\n        if(rate === 0) {\r\n            return { type: NUMBER, value: 0-pv-pmt*nper };\r\n        }\r\n        return { type: NUMBER, value: 0-(\r\n            pv *   Math.pow((1+rate), nper) +\r\n            pmt * (1+rate*type)  * ( Math.pow((1+rate), nper) - 1 ) / rate\r\n        ) };\r\n    },\r\n    DATE: ([{value:YEAR}, {value:MONTH}, {value:DAY}], _context) => ({\r\n        type: DATE,\r\n        meta: { YEAR, MONTH, DAY },\r\n        value: new Date(YEAR, MONTH-1, DAY)\r\n    }),\r\n    DATEVALUE: ([{value:TEXT}], _context) => ({\r\n        type: DATE,\r\n        value: new Date(TEXT)\r\n    }),\r\n    TODAY: ([], _context) => ({\r\n        type: DATE,\r\n        value: new Date()\r\n    }),\r\n    NOW: (__, _context) => ({\r\n        type: DATETIME,\r\n        value: new Date()\r\n    }),\r\n    DAY: ([{value: date}], _context) => ({\r\n        type: NUMBER,\r\n        value: date.getDate()\r\n    }),\r\n    MONTH: ([{value: date}], _context) => ({\r\n        type: NUMBER,\r\n        value: date.getMonth()\r\n    }), \r\n    YEAR: ([{value: date}], _context) => ({\r\n        type: NUMBER,\r\n        value: date.getFullYear()\r\n    }), \r\n    EOMONTH: ([{value: date}, {value: monthsdiff}={value: 0}], _context) => ({\r\n        type: NUMBER,\r\n        value: (new Date(date.getFullYear(), date.getMonth() + 1 + monthsdiff, 0)).getDate()\r\n    }), \r\n    WEEKDAY: ([{value: date,type}, {value: return_type}={value:1}], _context) => {\r\n      const modes = {\r\n          \"1\": v => v+1,\r\n          \"2\": v => (v+7-1)%7+1,\r\n          \"3\": v=>(v+7-1)%7,\r\n          \"11\": v => (v+7-1)%7+1,\r\n          \"12\": v => (v+6-1)%7+1,\r\n          \"13\": v => (v+5-1)%7+1,\r\n          \"14\": v => (v+4-1)%7+1,\r\n          \"15\": v => (v+3-1)%7+1,\r\n          \"16\": v => (v+2-1)%7+1,\r\n          \"17\": v => v+1,\r\n      };\r\n      if(type === NUMBER) {\r\n          // weird things, where excel parses the number in mode 1 and returns whatever mode is set\r\n         return {\r\n            type: NUMBER,\r\n            meta: { return_type: return_type+\"\" },\r\n            value: modes[return_type+\"\"](date-1)\r\n        }\r\n      }\r\n      return {\r\n          type: NUMBER,\r\n          meta: { return_type: return_type+\"\" },\r\n          value: modes[return_type+\"\"](date.getDay())\r\n      }\r\n    }, \r\n    WEEKNUM: ([{value: date},{value:return_type}={value:1}], _context) => {\r\n        if(return_type===21) {\r\n          const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));\r\n          const dayNum = d.getUTCDay() || 7;\r\n          d.setUTCDate(d.getUTCDate() + 4 - dayNum);\r\n          const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));\r\n          return {\r\n              type: NUMBER,\r\n              value: Math.ceil((((d - yearStart) / 86400000) + 1)/7)\r\n          }\r\n        }\r\n        const modemap = {\r\n          \"1\": 0,\r\n          \"2\": 1,\r\n          \"11\": 1,\r\n          \"12\": 2,\r\n          \"13\": 3,\r\n          \"14\": 4,\r\n          \"15\": 5,\r\n          \"16\": 6,\r\n          \"17\": 0\r\n        };\r\n        const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));\r\n        const dayNum = d.getUTCDay() || 7;\r\n        d.setUTCDate(d.getUTCDate() + modemap[return_type] - dayNum);\r\n        const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));\r\n        const dayNum2 = d.getUTCDay() || 7;\r\n        yearStart.setUTCDate(yearStart.getUTCDate() + modemap[return_type] - dayNum2);\r\n          return {\r\n          type: NUMBER,\r\n          value: Math.ceil((((d - yearStart) / 86400000) + 1)/7)\r\n        };\r\n    },\r\n    DATEDIF: ([{value: start_date}, {value: end_date}, {value: unit}], _context) => end_date<start_date ? {\r\n        type: ERROR,\r\n        value: NUMVALUE\r\n    } : {\r\n        type: NUMBER,\r\n        value: {\r\n            \"Y\": (s,e) => Math.ceil(Math.abs(e - s) / (1000 * 60 * 60 * 24 * 365.2425)),\r\n            \"M\": (s,e) => Math.ceil(Math.abs(e - s) / (1000 * 60 * 60 * 24 * 30.436875)),\r\n            \"D\": (s,e) => Math.ceil(Math.abs(e - s) / (1000 * 60 * 60 * 24)),\r\n            \"MD\": (s,e) => e.getDate() - s.getDate(),\r\n            \"YM\": (s,e) => e.getMonth() - s.getMonth(),\r\n            \"YD\": (s,e) => {\r\n                e.setUTCDate(2019); // ignore Year\r\n                s.setUTCDate(2019); // set to year without leap\r\n                return Math.ceil(Math.abs(e - s) / (1000 * 60 * 60 * 24));\r\n            }\r\n        }[unit](new Date(start_date.valueOf()), new Date(end_date.valueOf()))\r\n    },\r\n    EDATE: ([{value: d}, {value: months}], _context) =>\r\n        { const t = new Date(d.valueOf()); t.setMonth(d.getMonth() + months); return { type:DATE, value: t }; },\r\n    YEARFRAC: ([{value: s}, {value: e}, {value: base}={value:0}], _context) => {\r\n        // ISO/IEC 29500-1:2008\r\n      const m = {\r\n        \"0\": (s,e) => {\r\n          // see https://en.wikipedia.org/wiki/Day_count_convention#30/360_US\r\n          const sFeb = (new Date(s.getFullYear(), s.getMonth() + 1, 0)).valueOf() === s.valueOf();\r\n          const eFeb = (new Date(e.getFullYear(), e.getMonth() + 1, 0)).valueOf() === e.valueOf();\r\n          let Y1 = s.getFullYear(), Y2 = e.getFullYear(), M1 = s.getMonth(), M2 = e.getMonth(), D1 = s.getDate(), D2 = e.getDate();\r\n          if(sFeb && eFeb) { D2 = 30; }\r\n          if(sFeb) { D1 = 30; }\r\n          if(D2 === 31 && D1 >= 30) { D2 = 30; }\r\n          if(D1 === 31) { D1 = 30; }\r\n          return { type: NUMBER, value: (360*(Y2-Y1)+30*(M2-M1)+(D2-D1))/360 };\r\n        },\r\n        \"1\": (s,e) => {\r\n          let startYear = Math.min(s.getFullYear(), e.getFullYear());\r\n          const endYear = Math.max(s.getFullYear(), e.getFullYear());\r\n          let div = 365;\r\n          while(startYear <= endYear) {\r\n              if(startYear % 400 === 0 || (startYear % 100 !== 0 && startYear % 4 === 0)) {\r\n                div = 366;\r\n                break;\r\n            }\r\n            startYear++;\r\n          }\r\n          return {\r\n              type: NUMBER, value: (Math.abs(e - s) / (1000 * 60 * 60 * 24)) / div\r\n          }\r\n        },\r\n        \"Actual/actual\": (s,e) => m[\"1\"](s,e),\r\n        \"2\": (s,e) => ({ type: NUMBER, value: (Math.abs(e - s) / (1000 * 60 * 60 * 24)) / 360 }),\r\n        \"Actual/360\": (s,e) => m[\"2\"](s,e),\r\n        \"3\": (s,e) => ({ type: NUMBER, value: (Math.abs(e - s) / (1000 * 60 * 60 * 24)) / 365 }),\r\n        \"Actual/365\": (s,e) => m[\"3\"](s,e),\r\n        \"4\": (s,e) => {\r\n          // see https://en.wikipedia.org/wiki/Day_count_convention#30E/360\r\n          let Y1 = s.getFullYear(), Y2 = e.getFullYear(), M1 = s.getMonth(), M2 = e.getMonth(), D1 = s.getDate(), D2 = e.getDate();\r\n          if(D2 === 31) { D2 = 30; }\r\n          if(D1 === 31) { D1 = 30; }\r\n          return { type: NUMBER, value: (360*(Y2-Y1)+30*(M2-M1)+(D2-D1))/360 };\r\n        },\r\n        \"European 30/360\": (s,e) => m[\"4\"](s,e),\r\n        \"30/360\": (s,e) => {\r\n          let Y1 = s.getFullYear(), Y2 = e.getFullYear(), M1 = s.getMonth(), M2 = e.getMonth(), D1 = s.getDate(), D2 = e.getDate();\r\n          return { type: NUMBER, value: (360*(Y2-Y1)+30*(M2-M1)+(D2-D1))/360 };\r\n        },\r\n        \"30/360 Bond Basis\": (s,e) => {\r\n          let Y1 = s.getFullYear(), Y2 = e.getFullYear(), M1 = s.getMonth(), M2 = e.getMonth(), D1 = s.getDate(), D2 = e.getDate();\r\n          D1 = Math.min(D1, 30);\r\n          if(D1 >= 30) { D2 = Math.min(D2, 30); }\r\n          return { type: NUMBER, value: (360*(Y2-Y1)+30*(M2-M1)+(D2-D1))/360 };\r\n        },\r\n        \"30A/360\": (s,e) => m[\"30/360 Bond Basis\"](s,e),\r\n        \"30/360 US\": (s,e) => m[\"0\"](s,e),\r\n        \"30U/360\": (s,e) => m[\"0\"](s,e),\r\n        \"30/360\": (s,e) => {\r\n          let Y1 = s.getFullYear(), Y2 = e.getFullYear(), M1 = s.getMonth(), M2 = e.getMonth(), D1 = s.getDate(), D2 = e.getDate();\r\n          return { type: NUMBER, value: (360*(Y2-Y1)+30*(M2-M1)+(D2-D1))/360 };\r\n        },\r\n        \"30E/360\": (s,e) => m[\"4\"](s,e),\r\n        \"30/360 ICMA\": (s,e) => m[\"4\"](s,e),\r\n        \"30S/360\": (s,e) => m[\"4\"](s,e),\r\n        \"Eurobond basis (ISDA 2006)\": (s,e) => m[\"4\"](s,e),\r\n        \"Special German\": (s,e) => m[\"4\"](s,e),\r\n        \"30E/360 ISDA\": (s,e) => {\r\n          let Y1 = s.getFullYear(), Y2 = e.getFullYear(), M1 = s.getMonth(), M2 = e.getMonth(), D1 = s.getDate(), D2 = e.getDate();\r\n          if(D1 === (new Date(e.getFullYear(), e.getMonth() + 1, 0)).getDate()) { D1 = 30; }\r\n          if(D2 === (new Date(s.getFullYear(), s.getMonth() + 1, 0)).getDate()) { D2 = 30; }\r\n          return { type: NUMBER, value: (360*(Y2-Y1)+30*(M2-M1)+(D2-D1))/360 };\r\n        },\r\n        \"Eurobond basis (ISDA 2000)\": (s,e) => m[\"30E/360 ISDA\"](s,e),\r\n        \"Actual/Actual ISDA\": (s,e) => {\r\n          let currentYear = Math.min(s.getFullYear(), e.getFullYear());\r\n          const endYear = Math.max(s.getFullYear(), e.getFullYear());\r\n          let leapDays = 0;\r\n          let regularDays = 0;\r\n          while(currentYear <= endYear) {\r\n              const s0 = Math.max(new Date(currentYear, 1, 1), s);\r\n             const e0 = Math.min(new Date(currentYear+1, 1, 0), e);\r\n             const days = Math.ceil(Math.abs(e0 - s0) / (1000 * 60 * 60 * 24));\r\n              if(currentYear % 400 === 0 || (currentYear % 100 !== 0 && currentYear % 4 === 0)) {\r\n                // Leap\r\n                leapDays += days;\r\n            } else {\r\n                regularDays += days;\r\n            }\r\n            currentYear++;\r\n          }\r\n          return {\r\n              type: NUMBER, value: leapDays/366 + regularDays/365\r\n          }\r\n        },\r\n        \"Actual/Actual\": (s,e) => m[\"Actual/Actual ISDA\"](s,e),\r\n        \"Act/Act\": (s,e) => m[\"Actual/Actual ISDA\"](s,e),\r\n        \"Actual/365\": (s,e) => m[\"Actual/Actual ISDA\"](s,e),\r\n        \"Act/365\": (s,e) => m[\"Actual/Actual ISDA\"](s,e),\r\n        \"Act/365 Fixed\": (s,e) => m[\"Actual/365\"](s,e),\r\n        \"A/365 Fixed\": (s,e) => m[\"Actual/365\"](s,e),\r\n        \"A/365F\": (s,e) => m[\"Actual/365\"](s,e),\r\n        \"English\": (s,e) => m[\"Actual/365\"](s,e),\r\n        \"Act/360\": (s,e) => m[\"Actual/360\"](s,e),\r\n        \"A/360\": (s,e) => m[\"Actual/360\"](s,e),\r\n        \"French\": (s,e) => m[\"Actual/360\"](s,e),\r\n        \"Actual/364\": (s,e) => ({ type: NUMBER, value: (Math.abs(e - s) / (1000 * 60 * 60 * 24)) / 364 }),\r\n        \"Actual/Actual AFB\": (s,e) => {\r\n          const start = new Date(s.valueOf());\r\n          const sy = start.getFullYear();\r\n          const end = new Date(e.valueOf());\r\n          let fullYears = 0;\r\n          while(end.getFullYear() > start.getFullYear()) {\r\n              fullYears++;\r\n              end.setFullYear(end.getFullYear() - 1)\r\n          }\r\n          end.setFullYear(end.getFullYear() + 1);\r\n          const div = sy % 400 === 0 || (sy % 100 !== 0 && sy % 4 === 0) ? 366 : 365;\r\n          return {\r\n              type: NUMBER, value: fullYears - 1 + (Math.abs(end - start) / (1000 * 60 * 60 * 24)) / div,\r\n              meta: { years: fullYears - 1, days: (Math.abs(end - start) / (1000 * 60 * 60 * 24)) }\r\n          }\r\n        },\r\n        \"1/1\": (s,e) => {\r\n          let Y1 = s.getFullYear(), Y2 = e.getFullYear(), M1 = s.getMonth(), M2 = e.getMonth(), D1 = s.getDate(), D2 = e.getDate();\r\n          return { type: NUMBER, value: (360*(Y2-Y1)+30*(M2-M1)+(D2-D1))/365.25 };\r\n        },\r\n      };\r\n      return m[base+\"\"](s,e);\r\n    },\r\n    WORKDAY: ([{value:start},{value:days},holidays]) => {\r\n        let count = 0;\r\n        const d = new Date(start.valueOf());\r\n        const hollidaylist = holidays && holidays.type === LIST ? holidays.value.map(i => i.value) : [];\r\n        while(count < days) {\r\n            d.setDate(d.getDate()+1);\r\n            const day = d.getDay();\r\n            if(day === 0 || day === 6) {\r\n                continue;\r\n            }\r\n            if(hollidaylist.some(dt => dt.valueOf() === d.valueOf())) {\r\n                continue;\r\n            }\r\n            count++;\r\n        }\r\n        return ({\r\n          type: DATE,\r\n          value: d\r\n      })\r\n    },\r\n    \"WORKDAY.INTL\": ([{value:start},{value:days},weekend={value:1},holidays={value:[]}]) => {\r\n        let count = 0;\r\n        const d = new Date(start.valueOf());\r\n        let weekenddays = [6,0];\r\n        const weekendmap = {\r\n          \"1\": [6,0],\r\n          \"2\": [0,1],\r\n          \"3\": [1,2],\r\n          \"4\": [2,3],\r\n          \"5\": [3,4],\r\n          \"6\": [4,5],\r\n          \"7\": [5,6],\r\n          \"11\": [0],\r\n          \"12\": [1],\r\n          \"13\": [2],\r\n          \"14\": [3],\r\n          \"15\": [4],\r\n          \"16\": [5],\r\n          \"17\": [6],\r\n        };\r\n        if(weekend.type === LIST) {\r\n            weekenddays = weekend.value.map(({value}) => value).filter(i => i < 7);\r\n        }\r\n        if((weekend.value+\"\").length === \"7\") {\r\n            weekenddays = weekend.value.split(\"\").map((i, idx) => i === \"1\" ? (idx+1)%7 : -1).filter(i => i!== -1);\r\n        }\r\n        if(weekendmap[weekend.value+\"\"]) {\r\n            weekenddays = weekendmap[weekend.value+\"\"];\r\n        }\r\n        if(weekendmap.length >= 7) {\r\n            return { type: ERROR, value: VVALUE, meta: { message: \"Invalid value for 'weekend' \"+String(weekend)+\": Can't exclude all weekdays!\" } }\r\n        }\r\n        const hollidaylist = holidays && holidays.type === LIST ? holidays.value.map(i => i.value) : [];\r\n        while(count < days) {\r\n            d.setDate(d.getDate()+1);\r\n            const day = d.getDay();\r\n            if(weekenddays.indexOf(day) > -1) {\r\n                continue;\r\n            }\r\n            if(hollidaylist.some(dt => dt.valueOf() === d.valueOf())) {\r\n                continue;\r\n            }\r\n            count++;\r\n        }\r\n        return ({\r\n          type: DATE,\r\n          value: d\r\n          });\r\n    },\r\n    NETWORKDAYS: ([{value:start},{value:end},holidays]) => {\r\n        let count = 0;\r\n        const d = new Date(start.valueOf());\r\n        const hollidaylist = holidays && holidays.type === LIST ? holidays.value.map(i => i.value) : [];\r\n        while(d < end) {\r\n            d.setDate(d.getDate()+1);\r\n            const day = d.getDay();\r\n            if(day === 0 || day === 6) {\r\n                continue;\r\n            }\r\n            if(hollidaylist.some(dt => dt.valueOf() === d.valueOf())) {\r\n                continue;\r\n            }\r\n            count++;\r\n        }\r\n        return ({\r\n          type: NUMBER,\r\n          value: count\r\n      })\r\n    },\r\n    \"NETWORKDAYS.INTL\": ([{value:start},{value:end},weekend={value:1},holidays={value:[]}]) => {\r\n        let count = 0;\r\n        const d = new Date(start.valueOf());\r\n        let weekenddays = [6,0];\r\n        const weekendmap = {\r\n          \"1\": [6,0],\r\n          \"2\": [0,1],\r\n          \"3\": [1,2],\r\n          \"4\": [2,3],\r\n          \"5\": [3,4],\r\n          \"6\": [4,5],\r\n          \"7\": [5,6],\r\n          \"11\": [0],\r\n          \"12\": [1],\r\n          \"13\": [2],\r\n          \"14\": [3],\r\n          \"15\": [4],\r\n          \"16\": [5],\r\n          \"17\": [6],\r\n        };\r\n        if(weekend.type === LIST) {\r\n            weekenddays = weekend.value.map(({value}) => value).filter(i => i < 7);\r\n        }\r\n        if((weekend.value+\"\").length === \"7\") {\r\n            weekenddays = weekend.value.split(\"\").map((i, idx) => i === \"1\" ? (idx+1)%7 : -1).filter(i => i!== -1);\r\n        }\r\n        if(weekendmap[weekend.value+\"\"]) {\r\n            weekenddays = weekendmap[weekend.value+\"\"];\r\n        }\r\n        if(weekendmap.length === \"1111111\") {\r\n            return { type: NUMBER, value: 0, meta: { message: \"Shortcut for trivial value '1111111'\" } }\r\n        }\r\n        const hollidaylist = holidays && holidays.type === LIST ? holidays.value.map(i => i.value) : [];\r\n        while(d < end) {\r\n            d.setDate(d.getDate()+1);\r\n            const day = d.getDay();\r\n            if(weekenddays.indexOf(day) > -1) {\r\n                continue;\r\n            }\r\n            if(hollidaylist.some(dt => dt.valueOf() === d.valueOf())) {\r\n                continue;\r\n            }\r\n            count++;\r\n        }\r\n        return ({\r\n          type: NUMBER,\r\n          value: count\r\n          });\r\n    },\r\n    TIME: ([{value:hours},{value:minutes},{value:seconds}]) => ({ type: TIME, value: new Date(1970, 1, 1, hours, minutes, seconds, 0) }),\r\n    TIMEVALUE: ([{value:time_text}]) => ({ type: TIME, value: new Date(time_text) }),\r\n    NOW: () => ({ type: TIME, value: new Date() }),\r\n    HOUR: ([{value:date}]) => ({ type: NUMBER, value: date.getHours() }),\r\n    MINUTE: ([{value:date}]) => ({ type: NUMBER, value: date.getMinutes() }),\r\n    SECOND: ([{value:date}]) => ({ type: NUMBER, value: date.getSeconds() }),\r\n    \r\n    ABS: ([{value}]) => ({ type: NUMBER, value: Math.abs(value) }),\r\n    ACCRINT: ([{value:issue},{value:first_interest},{value:settlement},{value:rate},{value:par}={value:1000},{value:frequency},{value:basis}={value:0},{value:calc_method}={value: true}], _context) => {\r\n        issue = Math.floor(issue), first_interest = Math.floor(first_interest), settlement = Math.floor(settlement),\r\n        frequency = Math.floor(frequency), basis = Math.floor(basis);\r\n        if(rate <= 0) {\r\n            return {type: ERROR, value: NUMVALUE, meta: { message: \"'rate' must be >=0, but is \"+ String(rate)}};\r\n        }\r\n        if(par <= 0) {\r\n            return {type: ERROR, value: NUMVALUE, meta: { message: \"'par' must be >=0, but is \"+ String(par)}};\r\n        }\r\n        if(frequency !== 1 && frequency !== 2 && frequency !== 4) {\r\n            return {type: ERROR, value: NUMVALUE, meta: { message: \"'frequency' must be 1,2 or 4, but is \"+ String(par)}};\r\n        }\r\n        if(basis < 0 || basis > 4) {\r\n            return {type: ERROR, value: NUMVALUE, meta: { message: \"'basis' must be >0 and <4, but is \"+ String(basis)}};\r\n        }\r\n        if(issue > settlement) {\r\n            return {type: ERROR, value: NUMVALUE, meta: { message: \"'issue' must be >= 'settlement', but is \"+ String(issue)+\"<\"+String(settlement)}};\r\n        }\r\n        // todo: cross-compile (https://fable.io/) and use https://github.com/fsprojects/ExcelFinancialFunctions/blob/master/src/ExcelFinancialFunctions/bonds.fs\r\n        return { type: ERROR, value: \"NOT IMPLEMENTED\" };\r\n    },\r\n    ACCRINTM: ([{value}]) => ({ type: ERROR, value: \"NOT IMPLEMENTED\" }),\r\n    ACOS: ([{value}]) => ({ type: NUMBER, value: Math.acos(value) }),\r\n    ACOSH: ([{value}]) => ({ type: NUMBER, value: Math.acosh(value) }),\r\n    ACOT: ([{value}], _context) => _context.functions.ATAN(1 / value),\r\n    ACOTH: ([{value}]) => _context.functions.ATANH(1 / value),\r\n    AGGREGATE: ([{value:function_num},{value:options=0}={value:0}, ...args], _context) => {\r\n        const m = {\r\n          \"1\": \"AVERAGE\",\r\n          \"2\": \"COUNT\",\r\n          \"3\": \"COUNTA\",\r\n          \"4\": \"MAX\",\r\n          \"5\": \"MIN\",\r\n          \"6\": \"PRODUCT\",\r\n          \"7\": \"STDEV.S\",\r\n          \"8\": \"STDEV.P\",\r\n          \"9\": \"SUM\",\r\n          \"10\": \"VAR.S\",\r\n          \"11\": \"VAR.P\",\r\n          \"12\": \"MEDIAN\",\r\n          \"13\": \"MODE.SNGL\",\r\n          \"14\": \"LARGE\",\r\n          \"15\": \"SMALL\",\r\n          \"16\": \"PERCENTILE.INC\",\r\n          \"17\": \"QUARTILE.INC\",\r\n          \"18\": \"PERCENTILE.EXC\",\r\n          \"19\": \"QUARTILE.EXC\"\r\n        };\r\n        const ufunction = _context.functions[m[function_num+\"\"]];\r\n        const uarguments = args.filter(({type,value, meta={}}) => {\r\n            switch(options+\"\") {\r\n                case \"1\": // \"Ignore hidden rows, nested SUBTOTAL and AGGREGATE functions\"\r\n                    return !meta.hidden && meta.type!==AGGREGATE && meta.type!==SUBTOTAL;\r\n                case \"2\": // \"Ignore error values, nested SUBTOTAL and AGGREGATE functions\"\r\n                    return type!==ERROR && meta.type!==AGGREGATE && meta.type!==SUBTOTAL;\r\n                case \"3\": // \"Ignore hidden rows, error values, nested SUBTOTAL and AGGREGATE functions\"\r\n                    return !meta.hidden && type!==ERROR && meta.type!==AGGREGATE && meta.type!==SUBTOTAL;\r\n                case \"4\": // \"Ignore nothing\"\r\n                    return true;\r\n                case \"5\": // \"Ignore hidden rows\"\r\n                    return !meta.hidden;\r\n                case \"6\": // \"Ignore error values\"\r\n                    return type!==ERROR;\r\n                case \"7\": // \"Ignore hidden rows and error values\"\r\n                    return !meta.hidden && type!==ERROR;\r\n                case \"0\": // \"Ignore nested SUBTOTAL and AGGREGATE functions\"\r\n                    return meta.type!==AGGREGATE && meta.type!==SUBTOTAL\r\n                default:\r\n                    throw new Error(\"'AGGREGATE's 'options' must be between 0 and 7, but found \"+String(options));\r\n            }\r\n        });\r\n        try {\r\n            const result = ufunction(uarguments, _context);\r\n            return { ...result, meta: { type: AGGREGATE } }\r\n        } catch(e) {\r\n            const initialError = uarguments.find((e) => e && (e.type === ERROR));\r\n            return {\r\n                type: ERROR,\r\n                value: (initialError && initialError.value) || e.name+' in '+m[function_num+\"\"]+': \"'+e.message+'\"',\r\n                meta: {  error_value: initialError, internal_error: e }\r\n           };\r\n        }\r\n    },\r\n    ADDRESS: ([{value:row_num},{value:column_num},{value:abs_num}={value:1},{value:a1}={value:true},{value:sheet_text}={}], _context) =>\r\n        _context.parser(\r\n            (sheet_text?\"'\"+sheet_text+\"'!\":\"\")+\r\n            (a1?\r\n                ((abs_num===1||abs_num===3)?\"$\":\"\")+String.fromCharCode(column_num+64)+((abs_num===1||abs_num===2)?\"$\":\"\")+row_num:\r\n                \"R\"+((abs_num===1||abs_num===2)?\"[\"+row_num+\"]\":row_num)+\"C\"+((abs_num===1||abs_num===3)?\"[\"+column_num+\"]\":column_num)\r\n            )\r\n       ),\r\n    AMORDEGRC: ([{value}]) => ({ type: NULL, value }),\r\n    AMORLINC: ([{value}]) => ({ type: NULL, value }),\r\n    ARABIC: ([{value}]) => {\r\n        // https://stackoverflow.com/questions/48946083/convert-roman-number-to-arabic-using-javascript\r\n        function romanToArabic(roman){\r\n          if(roman == null)\r\n              return -1;\r\n          var totalValue = 0, \r\n              value = 0, // Initialise!\r\n              prev = 0;\r\n\r\n          for(var i=0;i<roman.length;i++){\r\n              var current = {\r\n                \"I\":1,\r\n                \"V\":5,\r\n                \"X\":10,\r\n                \"L\":50,\r\n                \"C\":100,\r\n                \"D\":500,\r\n                \"M\":1000,\r\n                ...romannumeral_extended,\r\n                ...romannumeral_romanSymbols\r\n              }[roman.charAt(i)];\r\n              if (current > prev) {\r\n                  // Undo the addition that was done, turn it into subtraction\r\n                  totalValue -= 2 * value;\r\n              }\r\n              if (current !== prev) { // Different symbol?\r\n                  value = 0; // reset the sum for the new symbol\r\n              }\r\n              value += current; // keep adding same symbols\r\n              totalValue += current;\r\n              prev = current;\r\n          }\r\n          return totalValue;\r\n      }\r\n      return { type: NUMBER, value: romanToArabic(value) }\r\n    },\r\n    AREAS: ([{value,type}]) => ({ type: NUMBER, value: type===ARGUMENTS?value.length:(\r\n        [LIST, ARRAY].includes(type)?1:0\r\n    ) }),\r\n    ASC: ([{value}]) => ({ type: STRING, value: value.split(\"\").map(i =>\r\n        i.charCodeAt(0) >= 65248 ? String.fromCharCode(i.charCodeAt(0) - 65248) : i\r\n    ).join(\"\") }),\r\n    ASIN: ([{value}]) => ({ type: NUMBER, value: Math.asin(value) }),\r\n    ASINH: ([{value}]) => ({ type: NUMBER, value: Math.asinh(value) }),\r\n    ATAN: ([{value}]) => ({ type: NUMBER, value: Math.atan(value) }),\r\n    ATAN2: ([{value:a},{value:b}]) => ({ type: NUMBER, value: Math.atan2(a,b) }),\r\n    ATANH: ([{value}]) => ({ type: NUMBER, value: Math.atanh(value) }),\r\n    AVEDEV: (_args, _context) => {\r\n        let args = _args;\r\n        const [{type,value}] = args;\r\n        if(type === LIST) {\r\n            args = value;\r\n        }\r\n        const find = args.some(({type}) => type !== NUMBER);\r\n        if(find) {\r\n            return { type: ERROR, value: \"AVEDEV exspects either numbers or a list of numbers as arguments, but found \"+String(find.value)+\" (\"+String(find.type)+\")\" };\r\n        }\r\n        const {value:avg} = _context.functions.AVERAGE(args);\r\n        const derivations = args.map(({value}) => Math.abs(avg - value));\r\n        return { type: NUMBER, value: derivations.reduce((p,i) => p+i, 0)/derivations.length, meta: { avg, length: derivations.length, deviations: derivations } };\r\n    },\r\n    AVERAGEA: (allargs) => {\r\n        const result = allargs.reduce((sum, { value, type }) => {\r\n          switch(type) {\r\n              case NULL:\r\n                return sum;\r\n            case NUMBER:\r\n              return sum + value;\r\n            case LIST:\r\n              return value.reduce((p, s) => {\r\n                  if(s.type !== NUMBER) {\r\n                      throw new Error(\"Disallowed value \"+String(s.value)+\" of type \"+String(s.type)+\" found in LIST supplied to SUM\");\r\n                  }\r\n                  return p+s.value;\r\n              }, sum);\r\n            case BOOLEAN:\r\n                return sum + (+value);\r\n            case STRING:\r\n                return sum;\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in AVERAGEA\");\r\n          }\r\n      }, 0);\r\n      return { type: NUMBER, value: result/allargs.length };\r\n    },\r\n    AVERAGEIF: (args, _context) => ({\r\n        type: NUMBER, value: _context.function.SUMIF(args).value/_context.functions.COUNTIF(args).value\r\n    }),\r\n    AVERAGEIFS: ([arg,...args],_context) => ({\r\n        type: NUMBER, value: _context.function.SUMIFS([arg,...args]).value/_context.functions.COUNTIFS(args).value\r\n    }),\r\n    BAHTTEXT: ([{value}]) => ({ type: STRING, value: new Intl.NumberFormat('th-TH-u-nu-thai', { numberingSystem: \"thai\", style: 'currency', currency: 'THB' }).format(value) }), // https://github.com/antronic/thai-baht-text-js ?\r\n    BASE: ([{value:decimal},{value:base},{value:minlength}={value:0}]) => ({ type: STRING, value: decimal.toString(base).padStart(minlength, \"0\").toUpperCase() }),\r\n    _BESSEL: ([{value:X,type:XT},{value:N,typeNT},{value:bessel}],_context,f) => {\r\n        if(NT !== NUMBER || XT != NUMBER) {\r\n            return { TYPE: ERROR, VALUE: VVALUE }\r\n        }\r\n        if(N < 0) {\r\n            return { TYPE: ERROR, VALUE: NAVALUE }\r\n        }\r\n        const func = BESSEL[f] || BESSEL[bessel] || BESSEL[\"bessel\"+bessel];\r\n        if(!func) {\r\n            throw new Error(\"ILLEGAL INVOCATION, expected bessel to be i, j, k or y but found \"+String(f || bessel));\r\n        }\r\n        return { TYPE: NUMBER, value: func(X, Math.floor(N)) };\r\n    },\r\n    BESSEL: (args,_context) => _context.functions._BESSEL(args,_context),\r\n    BESSELI: (args,_context) => _context.functions._BESSEL(args,_context,\"besseli\"),\r\n    BESSELJ: (args,_context) => _context.functions._BESSEL(args,_context,\"besselj\"),\r\n    BESSELK: (args,_context) => _context.functions._BESSEL(args,_context,\"besselk\"),\r\n    BESSELY: (args,_context) => _context.functions._BESSEL(args,_context,\"bessely\"),\r\n    BETADIST: ([{value:x},{valye:alpha},{value:beta},{value:a}={value:0},{value:b}={value:1}]) => {\r\n        // const Beta = require( '@stdlib/stats/base/dists/beta/ctor' );\r\n        // const beta = new Beta(a,b);\r\n        // const value = beta.cdf(x,alpha,beta);\r\n        return { type: NUMBER, value: \"NOT IMPLEMENTED\" };\r\n    },\r\n    \"BETA.DIST\": ([{value:x},{valye:alpha},{value:beta},{value:cumulative},{value:a}={value:0},{value:b}={value:1}]) => {\r\n        // const Beta = require( '@stdlib/stats/base/dists/beta/ctor' );\r\n        // const beta = new Beta(a,b);\r\n        // const value = cumulative ? beta.cdf(x,alpha,beta) : beta.pdf(x,alpha,beta);\r\n        // or maybe from var { jStat } = require('jstat') ?\r\n        return { type: NUMBER, value: \"NOT IMPLEMENTED\"};\r\n    },\r\n    BETAINV: ([{value:x},{valye:alpha},{value:beta},{value:a}={value:0},{value:b}={value:1}]) => {\r\n        // const { jStat } = require('jstat')\r\n        // const beta = jStat.beta(a,b);\r\n        // const value = beta.inv(x,alpha,beta);\r\n        return { type: NUMBER, value: \"NOT IMPLEMENTED\" };\r\n    },\r\n    \"BETA.INV\": (args, _context) => _context.functions.BETAINV(args, _context),\r\n    BIN2DEC: ([{value}]) => ({ type: NUMBER, value: parseInt(value, 2).toString(10) }),\r\n    BIN2HEX: ([{value},{value:minlength}]) => ({ type: STRING, value: parseInt(value, 2).toString(16).padStart(minlength, \"0\") }),\r\n    BIN2OCT: ([{value},{value:minlength}]) => ({ type: STRING, value: parseInt(value, 2).toString(8).padStart(minlength, \"0\") }),\r\n    BINOMDIST: ([{value:x},{value:n},{value:p},{value:cumulative}]) => {\r\n        // const cdf = require( '@stdlib/stats/base/dists/binomial/cdf' );\r\n        // const pmf = require( '@stdlib/stats/base/dists/binomial/pmf' );\r\n        // const value = cumulative ? cdf( x, n, p ) : pmf( x, n, p );\r\n        // or maybe from var { jStat } = require('jstat') ?\r\n        return { type: NUMBER, value: \"NOT IMPLEMENTED\" };\r\n    },\r\n    \"BINOM.DIST\": (args,_context) => _context.functions.BINOMDIST(args,_context),\r\n    \"BINOM.DIST.RANGE\": ([{value:n},{value:p},{value:x1},{value:x2}], _context) => {\r\n        let chance = 0;\r\n        for(let i = x1; i <= x2; i++) {\r\n            chance += _context.BINOMDIST([{value:i},{value:n},{value:p},{value:false}], _context).value;\r\n        }\r\n        return { type: NUMBER, value: chance };\r\n    },\r\n    \"BINOM.INV\": ([{value:n},{value:p},{value:a}], _context) => {\r\n        for(let i = 0; i < 10e6; i++) {\r\n            if(_context.BINOMDIST([{value:i},{value:n},{value:p},{value:false}], _context).value >= a) {\r\n                return { type: NUMBER, value: i };\r\n            }\r\n        }\r\n        return { type: ERROR, value: \"No value found\" };\r\n    },\r\n    BITAND: ([{value:a},{value:b}]) => ({ type: NUMBER, value: a & b }),\r\n    BITLSHIFT: ([{value:a},{value:b}]) => ({ type: NUMBER, value: a << b  }),\r\n    BITOR: ([{value:a},{value:b}]) => ({ type: NUMBER, value: a | b  }),\r\n    BITRSHIFT: ([{value:a},{value:b}]) => ({ type: NUMBER, value: a >> b  }),\r\n    BITXOR: ([{value:a},{value:b}]) => ({ type: NUMBER, value: a ^ b  }),\r\n    CALL: ([{value:f,type}, ...args], _context) => {\r\n        console.log(_context);\r\n        if(!_context.allowUnsafe) {\r\n            throw new Error(\"[SECURITY VIOLATION] Attempted to call 'call', but 'allowUnsafe'-option is not true\");\r\n        }\r\n        if(type === FUNCTION) {\r\n            const v = f(args.map(({value}) => value));\r\n            return ({ type: (v && v.type) || ANY, value: v });\r\n        }\r\n        const [ff,xtype] = [\r\n            [_context.functions[f], \"_context.functions\"],\r\n            [_context[f], \"_context\"],\r\n            [(self || global || window)[f], \"global\"]\r\n        ].find(([i]) => !!i) || [];\r\n        if(ff) {\r\n            if(typeof ff !== \"function\") {\r\n                return ({ type: NULL || ANY, value: ff, meta: { type: xtype } });\r\n            }\r\n            const v = ff(args);\r\n            const cellTrace = v[CELL_TRACE] || [];\r\n            return ({ type: (v && v.type) || ANY, value: v && v.value || v, [CELL_TRACE]: cellTrace });\r\n        }\r\n        try {\r\n            const argnames = args.map((__, idx) => String.fromCharCode(97+idx));\r\n            const argvalues = args.map((i) => i.value||i);\r\n            const v = new Function(...argnames, f); // NOT SAFE!!\r\n            return ({ type: (v && v.type) || ANY, value: v(...argvalues), meta: { \"exec\": v } });\r\n        } catch(e) {\r\n            return ({ type: ERROR, value: \"Failed to call function \"+f, meta: { f, args, error: e } });\r\n        }\r\n    },\r\n    \"CEILING.MATH\": ([{value:n},{value:dec},{value:m}], _context) => {\r\n        if(m === 1 && n < 0) {\r\n            return { type: NUMBER, value: dec*Math.floor(n/dec) };\r\n        }\r\n        return { type: NUMBER, value: dec*Math.ceil(n/dec) };\r\n    },\r\n    \"CEILING.PRECISE\": ([{value:n},{value:dec}]) => ({ type: NUMBER, value: !n||!dec ? 0 : dec*Math.floor(n/dec) }),\r\n    CELL: ([{value:info_type},o], context) => {\r\n        const {value:reference,type,meta} = o || {meta:{type:CELL,row:context.currentcell.row,col:context.currentcell.col}};\r\n        if(reference && meta.type !== CELL) {\r\n            return { type: ERROR, value: \"CELL function's second argument must be a cell if provided. Found \"+meta.type+\" instead\" }\r\n        }\r\n        const { row, col } = meta;\r\n        switch(info_type.toLowerCase()) {\r\n            case \"address\":\r\n                return { type: STRING, value: \"$\"+String.fromCharCode(64+row+1)+\"$\"+(col+1), meta: { CELL_FUNCTION: \"address\" } };\r\n            case \"col\":\r\n              return { type: NUMBER, value: col+1, meta: { CELL_FUNCTION: \"col\" } };\r\n            case \"color\":\r\n                // The value 1 if the cell is formatted in color for negative values; otherwise returns 0 (zero).\r\n                return { type: NUMBER, value: 0, meta: { error: \"CELL(color) not supported\", CELL_FUNCTION: \"color\" } };\r\n            case  \"contents\":\r\n                return { type: type, value: reference, meta: { ...meta, CELL_FUNCTION: \"contents\" } }\r\n            case \"filename\":\r\n                  return { type: STRING, value: \"\"+window.location, meta: { CELL_FUNCTION: \"filename\" } };\r\n            case \"format\":\r\n                // returns cell formatting\r\n                return { type: STRING, value: \"G\", meta: { error: \"CELL(format) not supported\", CELL_FUNCTION: \"format\" } };\r\n            case \"parentheses\":\r\n                   // The value 1 if the cell is formatted with parentheses for positive or all values; otherwise returns 0.\r\n                return { type: NUMBER, value: 0, meta: { error: \"CELL(parentheses) not supported\", CELL_FUNCTION: \"parentheses\" } };\r\n            case \"prefix\":\r\n                // cell alignment\r\n                return { type: STRING, value: \"\", meta: { error: \"CELL(prefix) not supported\", CELL_FUNCTION: \"prefix\" } };\r\n            case \"protect\":\r\n                // cell alignment\r\n                return { type: NUMBER, value: 0, meta: { error: \"CELL(protect) not supported\", CELL_FUNCTION: \"protect\" } };\r\n            case \"row\":\r\n                return { type: NUMBER, value: row+1, meta: { CELL_FUNCTION: \"row\" } };\r\n            case \"type\":\r\n                if(type === null) {\r\n                    return { type: STRING, value: \"b\", meta: { CELL_FUNCTION: \"type\" } };\r\n                }\r\n                if(type === STRING) {\r\n                    return { type: STRING, value: \"l\", meta: { CELL_FUNCTION: \"type\" } };\r\n                }\r\n                return { type: STRING, value: \"v\", meta: { CELL_FUNCTION: \"type\" } };\r\n            case \"width\":\r\n                // cell width\r\n                return { type: NUMBER, value: 0, meta: { error: \"CELL(width) not supported\", CELL_FUNCTION: \"width\" } };\r\n            default:\r\n                return { type: ERROR, value: \"Unknown info_type \"+info_type+\" supplied to CELL\" }\r\n        }\r\n    },\r\n    CHAR: ([{value}]) => ({ type: STRING, value: String.fromCharCode(value) }),\r\n    CHIDIST: ([{value}]) => ({ type: NULL, value }), // todo from lib\r\n    CHIINV: ([{value}]) => ({ type: NULL, value }), // todo from lib\r\n    CHITEST: ([{value}]) => ({ type: NULL, value }), // todo from lib\r\n    \"CHISQ.DIST\": ([{value}]) => ({ type: NULL, value }), // todo from lib\r\n    \"CHISQ.DIST.RT\": ([{value}]) => ({ type: NULL, value }), // todo from lib\r\n    \"CHISQ.INV\": ([{value}]) => ({ type: NULL, value }), // todo from lib\r\n    \"CHISQ.INV.RT\": ([{value}]) => ({ type: NULL, value }), // todo from lib\r\n    \"CHISQ.TEST\": ([{value}]) => ({ type: NULL, value }), // todo from lib\r\n    CHOOSE: ([{value}, ...args]) => ({ ...args[value-1] }), // NOTE: Must copy, otherwise referes to itself via _trace arguments\r\n    CLEAN: ([{value}]) => ({ type: STRING, value: value.replace(/[\\x00-\\x1F]/g,\"\") }), // values 0 through 31\r\n    CODE: ([{value}]) => ({ type: NUMBER, value: value.charCodeAt(0) }),\r\n    COLUMN: ([{value,type,meta={}}={}], ctx) => {\r\n        if(!value) {\r\n            return { type: NUMBER, value: ctx.currentcell.col+1 };\r\n        }\r\n        if(meta.type === CELL) {\r\n            return { type: NUMBER, value: meta.col };\r\n        }\r\n        throw new Error(\"COLUMN's first argumnet must be a cell-reference (meta.type=CELL)! Found \"+String(value)+\" (\"+String(type)+\"/\"+String(meta.type)+\")\"); // excel actually throws\r\n    },\r\n    COLUMNS: ([{value,type}]) => {\r\n        if(type === LIST) {\r\n            const {meta: {type:st,col:sc}={}} = value[0];\r\n            const {meta: {type:lt,col:lc}={}} = value[value.length-1];\r\n            if(st === CELL && lt === CELL) {\r\n                return { type: NUMBER, value: lc-sc+1 }\r\n            }\r\n            // case of inline list via {...}-Syntax\r\n            return { type: NUMBER, value: value.length };\r\n        }\r\n        if(type === MATRIX) {\r\n            return { type: NUMBER, value: value[0].length };\r\n        }\r\n        throw new Error(\"COLUMNS must be called with LIST or MATRIX. Found \"+String(value)+\" (\"+String(type)+\")\");\r\n    },\r\n    _FACTORIAL_CACHE: [1,1],\r\n    _FACTORIAL_i: 2,\r\n    _FACTORIAL: ([{value:n}], _context) => {\r\n      if (typeof _context.functions._FACTORIAL_CACHE[n] != 'undefined') {\r\n           return _context.functions._FACTORIAL_CACHE[n];\r\n      }\r\n      let result = _context.functions._FACTORIAL_CACHE[Number(_context.functions._FACTORIAL_i-1)];\r\n      for (; _context.functions._FACTORIAL_i <= n; _context.functions._FACTORIAL_i++) {\r\n          _context.functions._FACTORIAL_CACHE[_context.functions._FACTORIAL_i] = result = result * _context.functions._FACTORIAL_i;\r\n      }\r\n      return result;\r\n    },\r\n    COMBIN: ([n,k],_context) => ({ type: NUMBER, value: \r\n        _context.functions._FACTORIAL([n],_context)\r\n            / _context.functions._FACTORIAL([k],_context)\r\n            / _context.functions._FACTORIAL([{type: NUMBER, value: n.value-k.value}],_context)\r\n    }),\r\n    COMBINA: ([{value:n},{value:m}],_context) => _context.functions.COMBIN([{value:n+m-1,type:NUMBER},{value:n-1,type:NUMBER}],_context),\r\n    COMPLEX: ([{value:r,type:t1},{value:i,type:t2},{value:suffix}={value:\"i\"}]) => {\r\n        if(suffix !== \"i\" && suffix !== \"j\") {\r\n            return { type: ERROR, value: VVALUE, meta: { error: \"Suffix supplied to COMPLEX must be either 'i' or 'j', but found \"+String(suffix) } };\r\n        }\r\n        if(t1 !== NUMBER) {\r\n            return { type: ERROR, value: VVALUE, meta: { error: \"n supplied to COMPLEX must be a number but found \"+String(n)+\" (\"+String(t1)+\")\" } };\r\n        }\r\n        if(t2 !== NUMBER) {\r\n            return { type: ERROR, value: VVALUE, meta: { error: \"i supplied to COMPLEX must be a number but found \"+String(i)+\" (\"+String(t2)+\")\" } };\r\n        }\r\n        if(i === 0) {\r\n            return { type: NUMBER, value: r, meta: { type: COMPLEX_NUMBER, r, i, suffix } };\r\n        }\r\n        if(r === 0) {\r\n            return { type: STRING, value: i+suffix, meta: { type: COMPLEX_NUMBER, r, i, suffix } };\r\n        }\r\n        return { type: STRING, value: r+\"+\"+i+suffix, meta: { type: COMPLEX_NUMBER, r, i, suffix } }\r\n    },\r\n    CONCAT: (args) => {\r\n        const rv = args.reduce((p, {value,type}) => {\r\n            if(type === STRING) {\r\n                return p+value;\r\n            }\r\n            if(type === LIST) {\r\n                return p+value.map(i=>i.value).join(\"\");\r\n            }\r\n            if(type === MATRIX) {\r\n                return value.reduce((p0, arr) => p0+arr.map(i=>i.value).join(\"\"),p);\t\r\n            }\r\n            return p+value;\r\n        },\"\");\r\n        return { type: STRING, rv };\r\n    },\r\n    CONFIDENCE: ([{value:a},{value:sd},{value:n}]) => ({ type: NUMBER, value: jstat.normalci( 0, a, sd, n ).pop() }),\r\n    \"CONFIDENCE.NORM\": (args, _context) => _context.functions.CONFIDENCE(args, _context),\r\n    \"CONFIDENCE.T\": ([{value}]) => ({ type: NUMBER, value: jstat.tci( 0, a, sd, n ).pop() }),\r\n    CONVERT: ([{value:n},{value:from},{value:to}]) => {\r\n        \r\n        const matchWithPrefix = (unit, fromto) => Object.keys(prefixes).find(pf => pf+unit === fromto);\r\n        const matchCat = cat => {\r\n            const [[xfrom, xp, xp2], [yfrom, yp, yp2]] = [from, to].map(ft => {\r\n              let ip = \"\";\r\n              const r = Object.keys(cat).find(i => {\r\n                  if(ft === i) {\r\n                      return true;\r\n                  }\r\n                  const o = matchWithPrefix(i, ft);\r\n                  if(o) {\r\n                      ip = o;\r\n                      return true;\r\n                  }\r\n                  return false;\r\n              });\r\n              return [r, prefixes[ip] || 1, ip || \"\"]\r\n            });\r\n            console.log(\"xfrom, yfrom\", xfrom, yfrom)\r\n            if(xfrom && yfrom) {\r\n                // return n * cat[xfrom] * xp / cat[yfrom] / yp;\r\n                return [cat[xfrom] / cat[yfrom] * xp / yp * n, xp, yp, xp2, yp2];\r\n            }\r\n            return [false];\r\n        }\r\n        \r\n        // todo: rather do a loop...\r\n        let result = null;\r\n        const [catname] = Object.entries({\r\n            Speed: speed, \r\n            Information: computer, \r\n            Area: area, \r\n            Volume: space, \r\n            Temperature: temperature, \r\n            Magnetism: magn, \r\n            Power: power,\r\n            Energy: energy,\r\n            Force: force, \r\n            Pressure: press, \r\n            Time: time, \r\n            Distance: length, \r\n            \"Weight and mass\": weight\r\n        }).find(([__, cat]) => {\r\n            const r = matchCat(cat);\r\n            console.log(\"r\",r);\r\n            const [u] = r;\r\n            if(u) {\r\n                result = r; // save the value\r\n                return true;\r\n            }\r\n            return false;\r\n        }) || [];\r\n        \r\n        if(result !== null) {\r\n            return { type: NUMBER, value: result[0], meta: {\r\n                cat: catname,\r\n                multiplicatorFrom: result[1],\r\n                multiplicatorTo: result[2],\r\n                fromUnit: result[3],\r\n                toUnit: result[4],\r\n            } };\r\n        }\r\n        return ({ type: ERROR, value: \"No match found for types '\"+from+\"' - '\"+to+\"'\" });\r\n    },\r\n    CORREL: ([{value:x,type:t1},{value:y,type:t2}], _context) => {\r\n        if(t1 !== LIST || t2 !== LIST) {\r\n            return { type: ERROR, value: \"Both arguments of CORREL must be LIST, but found \"+t1+\"/\"+t2 }\r\n        }\r\n        const [xf,yf] = [x,y].map(i => i.filter(({type}) => type == NUMBER));\r\n        if(xf.length !== yf.length) {\r\n            return { type: ERROR, value: NAVALUE, meta: { error: \"Expected in CORREL(x,y) that x.length===y.length, but found \"+ xf.length + \"!==\" + yf.length } };\r\n        }\r\n        const {value:xbar} = _context.functions.AVERAGE([{type:LIST,value:xf}]);\r\n        const {value:ybar} = _context.functions.AVERAGE([{type:LIST,value:yf}]);\r\n        const a = xf.map(({value:x}) => x-xbar);\r\n        const b = yf.map(({value:y}) => y-ybar);\r\n        const ab = a.map((i, idx) => i*b[idx]);\r\n        const a2 = a.map(i => i*i);\r\n        const b2 = b.map(i => i*i);\r\n        const absum = ab.reduce((a, b) => a + b, 0);\r\n        const a2sum = a2.reduce((a, b) => a + b, 0);\r\n        const b2sum = b2.reduce((a, b) => a + b, 0);\r\n        if(a2sum === 0 || b2sum === 0) {\r\n            return { type: ERROR, value: DIV0, meta: { error: \"Expected CORREL's s to be != 0, but found \"+a2sum+\"/\"+b2sum } };\r\n        }\r\n        return { type: NUMBER, value: absum / Math.sqrt(a2sum*b2sum) };\r\n    },\r\n    COS: ([{value}]) => ({ type: NUMBER, value: Math.cos(value) }),\r\n    COSH: ([{value}]) => ({ type: NUMBER, value: Math.cosh(value) }),\r\n    COT: ([{value}]) => ({ type: NUMBER, value: 1/Math.tan(value) }),\r\n    COTH: ([{value}]) => ({ type: NUMBER, value: 1/Math.tanh(value) }),\r\n    COUPDAYBS: ([{value}]) => ({ type: NULL, value: \"todo: from finacial function\" }),\r\n    COUPDAYS: ([{value}]) => ({ type: NULL, value: \"todo: from finacial function\" }),\r\n    COUPDAYSNC: ([{value}]) => ({ type: NULL, value: \"todo: from finacial function\" }),\r\n    COUPNCD: ([{value}]) => ({ type: NULL, value: \"todo: from finacial function\" }),\r\n    COUPNUM: ([{value}]) => ({ type: NULL, value: \"todo: from finacial function\" }),\r\n    COUPPCD: ([{value}]) => ({ type: NULL, value: \"todo: from finacial function\" }),\r\n    _COVAR: ([{value:x,type:t1},{value:y,type:t2}], _context, sp) => {\r\n        if(t1 !== LIST || t2 !== LIST) {\r\n            return { type: ERROR, value: \"Both arguments of CORREL must be LIST, but found \"+t1+\"/\"+t2 }\r\n        }\r\n        const [xf,yf] = [x,y].map(i => i.filter(({type}) => type == NUMBER));\r\n        if(xf.length !== yf.length) {\r\n            return { type: ERROR, value: NAVALUE, meta: { error: \"Expected in COVAR(x,y) that x.length===y.length, but found \"+ xf.length + \"!==\" + yf.length } };\r\n        }\r\n        if(xf.length === 0 || yf.length === 0) {\r\n            return { type: ERROR, value: DIV0, meta: { error: \"Expected COVAR's x and y to be != 0, but found \"+xf.length+\"/\"+yf.length } };\r\n        }\r\n        const {value:xbar} = _context.functions.AVERAGE([{type:LIST,value:xf}]);\r\n        const {value:ybar} = _context.functions.AVERAGE([{type:LIST,value:yf}]);\r\n        const a = xf.map(({value:x}) => x-xbar);\r\n        const b = yf.map(({value:y}) => y-ybar);\r\n        const ab = a.map((i, idx) => i*b[idx]);\r\n        const absum = ab.reduce((a, b) => a + b, 0);\r\n        return { type: NUMBER, value: absum / (xf.length + sp) };\r\n    },\r\n    COVAR: (args, _context) => _context.functions._COVAR(args, _context, 0),\r\n    \"COVARIANCE.P\": (args, _context) => _context.functions._COVAR(args, _context, 0),\r\n    \"COVARIANCE.S\": (args, _context) => _context.functions._COVAR(args, _context, -1),\r\n    CRITBINOM: (args, _context) => _context.functinos[\"BINOM.INV\"](args, _context),\r\n    CSC: ([{value}]) => ({ type: NUMBER, value: 1/Math.sin(value) }),\r\n    CSCH: ([{value}]) => ({ type: NUMBER, value: 1/Math.sinh(value) }),\r\n    CUBEKPIMEMBER: ([{value}]) => ({ type: NULL, value }), // database query\r\n    CUBEMEMBER: ([{value}]) => ({ type: NULL, value }), // database query\r\n    CUBEMEMBERPROPERTY: ([{value}]) => ({ type: NULL, value }), // database query\r\n    CUBERANKEDMEMBER: ([{value}]) => ({ type: NULL, value }), // database query\r\n    CUBESET: ([{value}]) => ({ type: NULL, value }), // database query\r\n    CUBESETCOUNT: ([{value}]) => ({ type: NULL, value }), // database query\r\n    CUBEVALUE: ([{value}]) => ({ type: NULL, value }), // database query\r\n    CUMIPMT: ([{value}]) => ({ type: NULL, value: \"todo: from finacial function\" }),\r\n    CUMPRINC: ([{value}]) => ({ type: NULL, value: \"todo: from finacial function\" }),\r\n    _DATABASE: ([{value:database},{value:criteria}],_context) => {\r\n        const [headersv, ...data] = database;\r\n        const headers = headersv.map(({ value }) => value);\r\n        const db = data.map(j => j.reduce((p, {value,type}, idx) => ({ ...p, [headers[idx]]: {value,type} }), {}));\r\n        \r\n        const [cheadersv, ...crit] = criteria;\r\n        const cheaders = cheadersv.map(({ value }) => value);\r\n        const critas = crit.map(j => \r\n            j.reduce((p, {value,type}, idx) => ({ ...p, [idx]: {value,type,key:cheaders[idx]} }),\r\n            {})\r\n        );\r\n        \r\n        const op = (value, crit) => {\r\n            const f = _context.functions._CRITMATCHER([crit], _context);\r\n            return f({value});\r\n        };\r\n        const filterf = x => critas.some(cri => Object.entries(cri).every(([k,v]) => op(x[v.key].value, v)));\r\n        return { type: LIST, value: db.filter(filterf), meta: { criteria: critas.map(i => Object.values(i).map(({key,value}) => ({field:key,matches:value}))) } };\r\n    },\r\n    DAVERAGE: ([{value:database},{value:field,type:ft},{value:criteria}],_context) => {\r\n        const {value:selected} = _context.functions._DATABASE([{value:database},{value:criteria}],_context);\r\n        const [headersv] = database;\r\n        const headers = headersv.map(({ value }) => value);\r\n        const fieldname = ft === NUMBER ? headers[field-1] : field;\r\n        if(selected.length===0) {\r\n            return { type: ERROR, value: DIV0, meta: { error: \"No entires matched the search\" } };\r\n        }\r\n        const avg = _context.functions.AVERAGE(selected.map(i => i[fieldname]));\r\n        return { type: NUMBER, value: avg, meta: { matches: selected } };\r\n    },\r\n    DAYS: ([{value:d1,type:t1},{value:d2,type:t2}]) => {\r\n        const date1 = t1 === DATE ? d1 : new Date(d1);\r\n        const date2 = t2 === DATE ? d2 : new Date(d2);\r\n        return { type: NUMBER, value: (date2.getTime() - date1.getTime()) / (1000 * 3600 * 24) }; \r\n    },\r\n    DAYS360: ([{value:d1,type:t1},{value:d2,type:t2},{value:method}={value:false}]) => {\r\n        let d1d = d1.getDate(), d2d = d2.getDate();\r\n        let d1m = d1.getMonth(), d2m = d2.getMonth();\r\n        const lastDayOfD1Month = (new Date(2008, d1m + 1, 0)).getDate(), lastDayOfD2Month = (new Date(2008, d2m + 1, 0)).getDate();\r\n        if(method === false) {\r\n          /*\r\n          U.S. (NASD) method. \r\n          If the starting date is the last day of a month, it becomes equal to the 30th day of the same month. \r\n          If the ending date is the last day of a month and \r\n              the starting date is earlier than the 30th day of a month, \r\n              the ending date becomes equal to the 1st day of the next month;\r\n          otherwise the ending date becomes equal to the 30th day of the same month.\r\n          */\r\n          if(d1d === lastDayOfD1Month) {\r\n              d1d = 30;\r\n          }\r\n          if(d2d === lastDayOfD2Month && d1d < 30) {\r\n              d2d = 1;\r\n              d2m = d2m + 1;\r\n          } else if(d2d === lastDayOfD2Month) {\r\n              d2d = 30;\r\n          }\r\n        } else if(method === true) {\r\n            /*\r\n            European method. \r\n            Starting dates and ending dates that occur on the 31st day of a month \r\n            become equal to the 30th day of the same month.\r\n            */\r\n            if(d2d === 31) {\r\n                d2d = 30;\r\n            }\r\n            if(d1d === 31) {\r\n                d1d = 30;\r\n            }\r\n        } else {\r\n            return { type: ERROR, value: \"DAYS360's method must be either true or false, but found \"+method };\r\n        }\r\n        return { type: NUMBER, value: (d2m - d1m) * 30 + d2d - d1d, meta: { d1d,d2d,d1m,d2m } };\r\n    },\r\n    DB: ([{value:cost},{value:salvage},{value:life},{value:period},{value:month}={value:12}], _context) => {\r\n        const urate = 1 - ((salvage / cost) ** (1 / life));\r\n        const rate = Math.round(urate*1000)/1000; // excel rounds to 3 places\r\n        if(period === 1) {\r\n            return { type: NUMBER, value: cost * rate * month / 12 };\r\n        }\r\n        else if(period === life) { // last\r\n            const {value:totaldepprior} = _context.functions.DB([{value:cost},{value:salvage},{value:life},{value:period-1},{value:month}], _context);\r\n            return { type: NUMBER, value: ((cost - totaldepprior) * rate * (12 - month)) / 12 };\r\n        } \r\n        const {value:totaldepprior} = _context.functions.DB([{value:cost},{value:salvage},{value:life},{value:period-1},{value:month}], _context);\r\n        return { type: NUMBER, value: (cost - totaldepprior) * rate };\r\n    },\r\n    DBCS: ([{value}]) => ({ type: STRING, value: value.split(\"\").map(i =>\r\n        i.charCodeAt(0) < 65248 ? String.fromCharCode(i.charCodeAt(0) + 65248) : i\r\n    ).join(\"\") }),\r\n    DCOUNT: ([{value:database},{value:field,type:ft},{value:criteria}],_context) => {\r\n        const {value:selected,meta:dbmeta} = _context.functions._DATABASE([{value:database},{value:criteria}],_context);\r\n        const [headersv] = database;\r\n        const headers = headersv.map(({ value }) => value);\r\n        const fieldname = ft === NUMBER ? headers[field-1] : field;\r\n        const {value:count} = _context.functions.COUNT(selected.map(i => i[fieldname]),_context);\r\n        return { type: NUMBER, value: count, meta: { ...dbmeta, matches: selected } };\r\n    },\r\n    DCOUNTA: ([{value:database},{value:field,type:ft},{value:criteria}],_context) => {\r\n        const {value:selected,meta:dbmeta} = _context.functions._DATABASE([{value:database},{value:criteria}],_context);\r\n        const [headersv] = database;\r\n        const headers = headersv.map(({ value }) => value);\r\n        const fieldname = ft === NUMBER ? headers[field-1] : field;\r\n        const {value:count} = _context.functions.COUNTA(selected.map(i => i[fieldname]),_context);\r\n        return { type: NUMBER, value: count, meta: { ...dbmeta, matches: selected } };\r\n    },\r\n    DDB: ([{value:cost},{value:salvage},{value:life},{value:period},{value:factor}={value:2}], _context) => {\r\n        if(period <= 0) {\r\n            return { type:NUMBER,value:0 }\r\n        }\r\n        const {value:totaldepprior} = _context.functions.DDB([{value:cost},{value:salvage},{value:life},{value:period-1},{value:factor}], _context);\r\n        return { type: NUMBER, value: Math.min(\r\n            (cost - totaldepprior) * (factor/life),\r\n            (cost - salvage - totaldepprior)\r\n        )};\r\n    },\r\n    _DEC2X: ([{value:a1,type},a2,{value:excel}={value:true}],_context, base) => {\r\n        const r =  _context.functions.BASE([{\r\n            value: (excel && a1 < 0) ? base**10+a1 : a1, // excel has funny counting\r\n            type\r\n        },{type:NUMBER,value:base},a2],_context);\r\n        if(a2 && a2.value > 0 && r.value.length > a2.value) {\r\n            return { type: ERROR, value: NUMVALUE, meta: { result: r } }\r\n        }\r\n        return r;\r\n    },\r\n    DEC2BIN: (args,_context) => _context.functions._DEC2X(args,_context,2),\r\n    DEC2HEX: (args,_context) => _context.functions._DEC2X(args,_context,16),\r\n    DEC2OCT: (args,_context) => _context.functions._DEC2X(args,_context,8),\r\n    DECIMAL: ([{value},{value:base}]) => ({ type: NUMBER, value: parseInt(value,base) }),\r\n    DEGREES: ([{value:r}]) => ({ type: NUMBER, value: r*(180/Math.PI) }),\r\n    DELTA: ([{value:n1,type:t1},{value:n2,type:t2}={value:0,type:NUMBER,meta:{error:\"Expected DELTA n1 and n2 to be both of type NUMBER, but found \"+String(t1)+\"/\"+String(t2)}}]) => (t1 !== NUMBER || t2 !== NUMBER) ? { type: ERROR, value: VVALUE  } : { type: NUMBER, value: +(n1===n2) },\r\n    DEVSQ: (args, _context) => {\r\n        const {value:avg} = _context.functions.AVERAGE(args,_context);\r\n        // const {value:xbar} = _context.functions.AVERAGE([{type:LIST,value:xf}]);\r\n        // const a2 = a.map(i => i*i);\r\n        const result = args.reduce((sum, { value, type }) => {\r\n          switch(type) {\r\n              case NULL:\r\n            case STRING:\r\n                return sum;\r\n            case NUMBER:\r\n              return sum + (value-avg)*(value-avg);\r\n            case LIST:\r\n              return sum + _context.functions.DEVSQ(value,_context).value;\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in AVERAGE\");\r\n          }\r\n      }, 0);\r\n      return { type: NUMBER, value: result, meta: { avg } };\r\n    },\r\n    DGET: ([{value:database},{value:field,type:ft},{value:criteria}],_context) => {\r\n        const {value:selected,meta:dbmeta} = _context.functions._DATABASE([{value:database},{value:criteria}],_context);\r\n        const [headersv] = database;\r\n        const headers = headersv.map(({ value }) => value);\r\n        const fieldname = ft === NUMBER ? headers[field-1] : field;\r\n        if(!selected.length) {\r\n            return {type:ERROR,value:VVALUE};\r\n        }\r\n        if(selected.length>1) {\r\n            return {type:ERROR,value:NUMVALUE};\r\n        }\r\n        return { ...selected[0][fieldname], meta: { ...dbmeta, matches: selected } };\r\n    },\r\n    DISC: ([{value}]) => ({ type: NULL, value }), // todo: financial\r\n    DMAX: ([{value:database},{value:field,type:ft},{value:criteria}],_context) => {\r\n        const {value:selected,meta:dbmeta} = _context.functions._DATABASE([{value:database},{value:criteria}],_context);\r\n        const [headersv] = database;\r\n        const headers = headersv.map(({ value }) => value);\r\n        const fieldname = ft === NUMBER ? headers[field-1] : field;\r\n        if(!selected.length) {\r\n            return {type:ERROR,value:VVALUE};\r\n        }\r\n        const r = _context.functions.MAX(selected.map(i => i[fieldname]),_context);\r\n        return { ...r, meta: { ...dbmeta, matches: selected } };\r\n    },\r\n    DMIN: ([{value:database},{value:field,type:ft},{value:criteria}],_context) => {\r\n        const {value:selected,meta:dbmeta} = _context.functions._DATABASE([{value:database},{value:criteria}],_context);\r\n        const [headersv] = database;\r\n        const headers = headersv.map(({ value }) => value);\r\n        const fieldname = ft === NUMBER ? headers[field-1] : field;\r\n        if(!selected.length) {\r\n            return {type:ERROR,value:VVALUE};\r\n        }\r\n        const r = _context.functions.MIN(selected.map(i => i[fieldname]),_context);\r\n        return { ...r, meta: { ...dbmeta, matches: selected } };\r\n    },\r\n    DOLLAR: ([{value,type},dec={value:2,type:NUMBER}],_context) => {\r\n        const {value:ammount} = _context.functions.ROUND([{value,type},dec],_context);\r\n        const display = \"$\"+ammount;\r\n        \r\n        // use for text maybe?\r\n        /*\r\n        const defaultOptions = (new Intl.NumberFormat()).resolvedOptions();\r\n        const currencycode =\r\n            CC2Currency[defaultOptions.locale] ||\r\n            CC2Currency[defaultOptions.locale.split(\"-\").pop()];\r\n        const r = new Intl.NumberFormat(defaultOptions.locale, {\r\n            style: \"currency\",\r\n            currency: currencycode,\r\n            // currencyDisplay: \"code\",\r\n            //maximumSignificantDigits: 3,\r\n            //minimumSignificantDigits: 3,\r\n            //minimumIntegerDigits: 1,\r\n            minimumFractionDigits: dec.value > 0 ? dec.value : 0,\r\n            useGrouping: true\r\n        }).format(ammount);\r\n        */\r\n        \r\n        if(ammount < 0) {\r\n            return { type:STRING, value: \"(\"+display+\")\" };\r\n        }\r\n        return { type:STRING, value: display };\r\n    },\r\n    DOLLARDE: ([{value},{value:frac}]) => {\r\n        const [intp,fracp] = value.toFixed(2).split(\".\");\r\n        const dec = parseInt(fracp)/frac;\r\n        return { type: NUMBER, value: parseInt(intp)+dec, meta: { intp,fracp } };\r\n    },\r\n    DOLLARFR: ([{value},{value:frac}]) => {\r\n        const [intp] = value.toFixed(0).split(\".\");\r\n        const dec = (value-intp)*frac/100;\r\n        return { type: NUMBER, value: parseInt(intp)+dec, meta: { intp,fracp: value-intp } };\r\n    },\r\n    DPRODUCT: ([{value:database},{value:field,type:ft},{value:criteria}],_context) => {\r\n        const {value:selected,meta:dbmeta} = _context.functions._DATABASE([{value:database},{value:criteria}],_context);\r\n        const [headersv] = database;\r\n        const headers = headersv.map(({ value }) => value);\r\n        const fieldname = ft === NUMBER ? headers[field-1] : field;\r\n        const {value:count} = _context.functions.PRODUCT(selected.map(i => i[fieldname]),_context);\r\n        return { type: NUMBER, value: count, meta: { ...dbmeta, matches: selected } };\r\n    },\r\n    DSTDEV: ([{value:database},{value:field,type:ft},{value:criteria}],_context) => {\r\n        const {value:selected,meta:dbmeta} = _context.functions._DATABASE([{value:database},{value:criteria}],_context);\r\n        const [headersv] = database;\r\n        const headers = headersv.map(({ value }) => value);\r\n        const fieldname = ft === NUMBER ? headers[field-1] : field;\r\n        const {value:count} = _context.functions[\"STDEV.S\"](selected.map(i => i[fieldname]),_context);\r\n        return { type: NUMBER, value: count, meta: { ...dbmeta, matches: selected } };\r\n    },\r\n    DSTDEVP: ([{value:database},{value:field,type:ft},{value:criteria}],_context) => {\r\n        const {value:selected,meta:dbmeta} = _context.functions._DATABASE([{value:database},{value:criteria}],_context);\r\n        const [headersv] = database;\r\n        const headers = headersv.map(({ value }) => value);\r\n        const fieldname = ft === NUMBER ? headers[field-1] : field;\r\n        const {value:count} = _context.functions[\"STDEV.P\"](selected.map(i => i[fieldname]),_context);\r\n        return { type: NUMBER, value: count, meta: { ...dbmeta, matches: selected } };\r\n    },\r\n    DSUM: ([{value:database},{value:field,type:ft},{value:criteria}],_context) => {\r\n        const {value:selected,meta:dbmeta} = _context.functions._DATABASE([{value:database},{value:criteria}],_context);\r\n        const [headersv] = database;\r\n        const headers = headersv.map(({ value }) => value);\r\n        const fieldname = ft === NUMBER ? headers[field-1] : field;\r\n        const {value:count} = _context.functions.SUM(selected.map(i => i[fieldname]),_context);\r\n        return { type: NUMBER, value: count, meta: { ...dbmeta, matches: selected } };\r\n    },\r\n    DURATION: ([{value}]) => ({ type: NULL, value }), // financial\r\n    DVAR: ([{value:database},{value:field,type:ft},{value:criteria}],_context) => {\r\n        const {value:selected,meta:dbmeta} = _context.functions._DATABASE([{value:database},{value:criteria}],_context);\r\n        const [headersv] = database;\r\n        const headers = headersv.map(({ value }) => value);\r\n        const fieldname = ft === NUMBER ? headers[field-1] : field;\r\n        const {value:count} = _context.functions.VAR(selected.map(i => i[fieldname]),_context);\r\n        return { type: NUMBER, value: count, meta: { ...dbmeta, matches: selected } };\r\n    },\r\n    DVARP: ([{value:database},{value:field,type:ft},{value:criteria}],_context) => {\r\n        const {value:selected,meta:dbmeta} = _context.functions._DATABASE([{value:database},{value:criteria}],_context);\r\n        const [headersv] = database;\r\n        const headers = headersv.map(({ value }) => value);\r\n        const fieldname = ft === NUMBER ? headers[field-1] : field;\r\n        const {value:count} = _context.functions.VARP(selected.map(i => i[fieldname]),_context);\r\n        return { type: NUMBER, value: count, meta: { ...dbmeta, matches: selected } };\r\n    },\r\n    EFFECT: ([{value:nominal_rate,type:t1},{value:npery,type:t2}]) => {\r\n        if(t1 !== NUMBER || t2 !== NUMBER) {\r\n            return { type:ERROR, value:VVALUE, meta: {error:\"Espected EFFECT's arguments nominal_rate and npery to be NUMBER, but found \"+String(t1)+\"/\"+String(t2)} };\r\n        }\r\n        if(nominal_rate <= 0) {\r\n            return { type:ERROR, value:NUMVALUE, meta: {error:\"Expected EFFECT's nominal_rate to be <= 0, but found \"+String(nominal_rate)+\" (\"+String(t1)+\")\"} };\r\n        }\r\n        if(npery < 1) {\r\n            return { type:ERROR, value:NUMVALUE, meta: {error:\"Expected EFFECT's npery to be < 1, but found \"+String(npery)+\" (\"+String(t2)+\")\"} };\r\n        }\r\n        return { type: NUMBER, value: (1 + nominal_rate/npery)**npery - 1 };\r\n    },\r\n    ENCODEURL: ([{value}]) => ({ type: STRING, value: window.encodeURIComponent(value) }),\r\n    ERF: ([{value}]) => {\r\n        // var erf = require( '@stdlib/math/base/special/erf' );\r\n        // var y = erf( value );\r\n        return {type:NUMBER, value:\"NOT IMPLEMETNED\"}\r\n    },\r\n    \"ERF.PRECISE\": ([{value}]) => {\r\n        // var erf = require( '@stdlib/math/base/special/erf' );\r\n        // var y = erf( value );\r\n        return {type:NUMBER, value:\"NOT IMPLEMETNED\"}\r\n    },\r\n    ERFC: ([{value}]) => {\r\n        // var erfc = require( '@stdlib/math/base/special/erfc' );\r\n        // var y = erf( value );\r\n        return {type:NUMBER, value:\"NOT IMPLEMETNED\"}\r\n    },\r\n    \"ERFC.PRECISE\": ([{value}]) => {\r\n        // var erfc = require( '@stdlib/math/base/special/erfc' );\r\n        // var y = erf( value );\r\n        return {type:NUMBER, value:\"NOT IMPLEMETNED\"}\r\n    },\r\n    \"ERROR.TYPE\": ([{value,type}]) => {\r\n        const m = {\r\n          NULLE : 1,\r\n          DIV0: 2,\r\n          VVALUE: 3,\r\n          REFVALUE: 4,\r\n          NAMEE: 5,\r\n          NUMVALUE: 6,\r\n          NAVALUE: 7,\r\n          GETTINGDATA: 8,\r\n      };\r\n      const r = m[value] || NAVALUE;\r\n      return { type: (type !== ERROR || r === NAVALUE) ? ERROR : NUMBER, value: r }\r\n    },\r\n    EUROCONVERT: ([{value}]) => ({ type: NULL, value }), //  add-in: todo\r\n    EXP: ([{value}]) => ({ type: NUMBER, value: Math.E**value }),\r\n    \"EXPON.DIST\": ([{value:x},{value:lambda},{value:cumulative}]) => {\r\n        //var cdf = require( '@stdlib/stats/base/dists/exponential/cdf' ); // true\r\n        //var pdf = require( '@stdlib/stats/base/dists/exponential/pdf' ); // false\r\n        // const f = cumulative ? cdf : pdf;\r\n        // f(x,lambda);\r\n        return { type: NUMBER, value: \"NOT implemented\" };\r\n    },\r\n    EXPONDIST: (args,context) => context.functions[\"EXPON.DIST\"](args,context),\r\n    _FACT: (counter,pro=1,neg=1,context) => counter <= 1 ? pro : context.functions._FACT(counter-neg,pro*counter,neg,context), // tail recurisve\r\n    FACT: ([{value}],context) => {\r\n        if(value < 0) {\r\n            return { type: ERROR, value: NUMVALUE };\r\n        }\r\n        return { type: NUMBER, value: context.functions._FACT(value,1,1,context) };\r\n    },\r\n    FACTDOUBLE: ([{value}],context) => {\r\n        if(value < 0) {\r\n            return { type: ERROR, value: NUMVALUE };\r\n        }\r\n        return { type: NUMBER, value: context.functions._FACT(value,1,2,context) };\r\n    },\r\n    FACTN: ([{value},{value:neg}={value:1}],context) => {\r\n        if(value < 0) {\r\n            return { type: ERROR, value: NUMVALUE };\r\n        }\r\n        return { type: NUMBER, value: context.functions._FACT(value,1,neg,context) };\r\n    },\r\n    FALSE: () => ({ type: BOOLEAN, value: false }),\r\n    \"F.DIST\": ([{value}]) => { // todo\r\n        // var cdf = require( '@stdlib/stats/base/dists/f/cdf' ); var y = cdf( 2.0, 1.0, 1.0 ); // true\r\n        // var pdf = require( '@stdlib/stats/base/dists/f/pdf' ); // false\r\n    },\r\n    FDIST: ([{value}]) => ({ type: NULL, value }), // cdf // todo\r\n    \"F.DIST.RT\": ([{value}]) => ({ type: NULL, value }), // 1 - \"F.DIST\" // todo\r\n    FILTER: ([{value:_data,type},{value:boollist,type:bttype},defaultt={type:ERROR}]) => {\r\n        // ({ type: NULL, value }), // requires array functions in formulas\r\n        let data = _data;\r\n        if(type === LIST) {\r\n            data = [data];\r\n        }\r\n        if(type !== MATRIX && type !== LIST) {\r\n            return { type: ERROR, value: \"FILTER expects a LIST or MATRIX as the first argument, but found \"+String(type) };\r\n        }\r\n        if(bttype !== LIST) {\r\n            return { type: ERROR, value: \"FILTER expects a LIST as the second argument, but found \"+String(bttype) };\r\n        }\r\n        const filtereddata = data.filter((__,idx) => boollist[idx].value);\r\n        if(!filtereddata.length) {\r\n            return {...defaultt};\r\n        }\r\n        return {\r\n            type: ARGUMENTS,\r\n            value: filtereddata\r\n        }\r\n    },\r\n    FILTERXML: ([{value:xml},{value:xpath}]) => {\r\n        // todo: insert as dependency to make code worker compadable\r\n        const oParser = new DOMParser();\r\n        const oDOM = oParser.parseFromString(xml, \"application/xml\");\r\n        const evaluator = new XPathEvaluator();\r\n        const attempt = (xpathtype, field, type) => {\r\n            try {\r\n                const expression = evaluator.createExpression(xpath);\r\n                const result = expression.evaluate(oDOM, xpathtype);\r\n                console.log(result, xpath, oDOM, xml)\r\n                return { type: type, value: result[field],  /*meta: { result }*/ }\r\n            } catch(e) {\r\n                return { type: ERROR, result: VVALUE, meta: { error: e } };\r\n            }\r\n        }\r\n        const x  = attempt(XPathResult.STRING_TYPE, \"stringValue\", STRING);\r\n        if(x.type !== ERROR) {\r\n            return x;\r\n        }\r\n        const y  = attempt(XPathResult.NUMBER_TYPE, \"numberValue\", NUMBER);\r\n        if(y.type !== ERROR) {\r\n            return y;\r\n        }\r\n        const z  = attempt(XPathResult.BOOLEAN_TYPE, \"booleanValue\", BOOLEAN);\r\n        if(z.type !== ERROR) {\r\n            return z;\r\n        }\r\n           return { type: ERROR, result: VVALUE, meta: { x, y, z } };\r\n    },\r\n    FIND: ([{value:find_text},{value:within_text},{value:start_num}={}]) => {\r\n         // indexOf in strings\r\n        return { type: NUMBER, value: within_text.indexOf(find_text,start_num)+1 };\r\n    },\r\n    FINDB: ([{value:find_text},{value:within_text},{value:start_num}={}]) => {\r\n        const idx = within_text.indexOf(find_text,start_num);\r\n        const r = (new TextEncoder().encode(within_text.substring(0,idx))).length;\r\n        return { type: NUMBER, value: r };\r\n    },\r\n    \"F.INV\": ([{value:p},{value:n},{value:m}]) => {\r\n        // var betaincinv = require( '@stdlib/math/base/special/betaincinv' );\r\n        // B = (Beta(n/2,m/2)**-1)\r\n        // f(m,n)**-1 = n/m * (1/B(1-p) - 1)\r\n        // see https://stats.stackexchange.com/questions/18843/how-to-obtain-the-inverse-of-the-f-cumulative-distribution-based-on-the-f-cumula\r\n        // betaincinv(p, n,m)\r\n        // const result = (1/betaincinv(1-p, n/2, m/2) - 1) / m * n\r\n        // return { type: NUMBER, value: result };\r\n        return { type: ERROR, value: \"NOT IMPLEMENTED\" };\r\n    },\r\n    \"F.INV.RT\": ([{value:p},{value:n},{value:m}]) => {\r\n        // var betaincinv = require( '@stdlib/math/base/special/betaincinv' );\r\n        // B = (Beta(n/2,m/2)**-1)\r\n        // f(m,n)**-1 = n/m * (1/B(1-p) - 1)\r\n        // see https://stats.stackexchange.com/questions/18843/how-to-obtain-the-inverse-of-the-f-cumulative-distribution-based-on-the-f-cumula\r\n        // betaincinv(p, n,m)\r\n        // const result = (1/betaincinv(1-p, n/2, m/2, true) - 1) / m * n\r\n        // return { type: NUMBER, value: result };\r\n        return { type: ERROR, value: \"NOT IMPLEMENTED\" };\r\n    },\r\n    FINV: (args,context) => context.FUNCTIONS[\"F.INV\"](args, context),\r\n    FISHER: ([{value:x}]) => ({ type: NUMBER, value: 0.5*Math.log( (1+x)/(1-x) ) }),\r\n    FISHERINV: ([{value:y}]) => ({ type: NUMBER, value: (Math.E**(2*y)-1) / (Math.E**(2*y)+1) }),\r\n    FIXED: ([number,dec={value:2},{value:nocomma}={value:false}],context) => {\r\n        const defaultOptions = (new Intl.NumberFormat()).resolvedOptions();\r\n        const r = new Intl.NumberFormat(defaultOptions.locale, {\r\n            style: \"decimal\",\r\n          useGrouping: !nocomma\r\n        }).format(context.functions.ROUNDDOWN([number,dec],context).value);\r\n        return { type: STRING, value: r };\r\n    },\r\n    \"FLOOR.MATH\": ([{value:n},{value:dec},{value:m}], _context) => {\r\n        if(m === 1 && n < 0) {\r\n            return { type: NUMBER, value: dec*Math.ceil(n/dec) };\r\n        }\r\n        return { type: NUMBER, value: dec*Math.floor(n/dec) };\r\n    },\r\n    \"FLOOR.PRECISE\": ([{value:n},{value:dec}]) => ({ type: NUMBER, value: !n||!dec ? 0 : dec*Math.ceil(n/dec) }),\r\n    FORECAST: (args,context) => context.functions[\"FORECAST.LINEAR\"](args,context),\r\n    \r\n    \"FORECAST.ETS\": ([{value}]) => ({ type: NULL, value }), // todo\r\n    \"FORECAST.ETS.CONFINT\": ([{value}]) => ({ type: NULL, value }),\r\n    \"FORECAST.ETS.SEASONALITY\": ([{value}]) => ({ type: NULL, value }),\r\n    \"FORECAST.ETS.STAT\": ([{value}]) => ({ type: NULL, value }),\r\n    \r\n    \"FORECAST.LINEAR\": ([{value:t,type},{type:t1,value:x},{type:t2,value:y}]) => {\r\n        if(t1 !== LIST || t2 !== LIST) {\r\n            return { type: ERROR, value: \"Expected x and y of FORECAST.LINEAR to be LIST, but found \"+t1+\"/\"+t2 }\r\n        }\r\n        if(type !== NUMBER) {\r\n            return { type: ERROR, value: \"Expected FORECAST.LINEAR's first param to be NUMBER, found \"+t+\"(\"+type+\")\" }\r\n        }\r\n        const kx = x.map(({value}) => value);\r\n        const ky = y.map(({value}) => value);\r\n        const avg = ar => {\r\n            const [sum,count] = ar.reduce(([sum,count],v) => [sum+v,count+1],[0,0]);\r\n            return sum/count;\r\n        };\r\n        const ax = avg(kx);\r\n        const ay = avg(ky);\r\n        const [nr,dr] = kx.reduce(([nr,dr],x,idx) => [\r\n            nr + ((x-ax) * (ky[idx]-ay)),\r\n            dr + ((x-ax)*(kx[idx]-ax))\r\n        ],[0,0])\r\n        const b = nr/dr;\r\n        const a = ay-b*ax;\r\n        return { type: NUMBER, value: a+b*t, meta: { m:b, b:a } };\r\n    }, \r\n    FORMULATEXT: ([{type:t1,meta:{type},formula,value}]) => {\r\n        if(type === CELL) {\r\n            return { type: (formula ? STRING : ERROR), value: (formula || NAVALUE)  };\r\n        }\r\n        if(t1 === LIST && value[0].meta.type === CELL) {\r\n            const { formula } = value[0];\r\n            return { type: (formula ? STRING : ERROR), value: (formula || NAVALUE)  };\r\n        }\r\n        if(t1 === MATRIX && value[0][0].meta.type === CELL) {\r\n            const { formula } = value[0][0];\r\n            return { type: (formula ? STRING : ERROR), value: (formula || NAVALUE)  };\r\n        }\r\n        return { type: ERROR, value: VVALUE  }\r\n    },\r\n    FREQUENCY: ([{type:t1,value:data_array},{type:t2,value:bins_array}]) => {\r\n        if(t1 !== LIST || t2 !== LIST) {\r\n            return { type: ERROR, value: \"Expected both arguments of FREQUENCY to be LIST but found \"+t1+\"/\"+t2 }\r\n        }\r\n        if(bins_array.length === 0) {\r\n            return { type: NUMBER, value: data_array.length };\r\n        }\r\n        const rev = bins_array.sort().reverse(); // reverse for findLast\r\n        const [results,cats] = data_array\r\n          .filter(({type}) => type !== NULL)\r\n          .reduce(([p,cats], {value:o}, idxn) => {\r\n              const idxx = rev.findIndex(({value:u}) => o > u);\r\n            const idx = idxx === -1 ? 0 : rev.length - idxx;\r\n            p[idx] += 1;\r\n            cats[idx] = [...cats[idx], o];\r\n            return [p,cats];\r\n          },\r\n        [\r\n          Array.from({length:bins_array.length+1}).fill(0), // counter\r\n          Array.from({length:bins_array.length+1}).fill([]), // values by cat\r\n        ]);\r\n        return { type: ARGUMENTS, value: results.map(value => ({\r\n            value, type: NUMBER\r\n        })), meta: { results, cats } }\r\n    },\r\n    \"F.TEST\": (args, context) => context.functions.FTEST(args, context),\r\n    FTEST: ([{value:n},{value:m}]) => {\r\n        // var anova1 = require( '@stdlib/stats/anova1' );\r\n        // const stats = [...n,...m].map(({value}) => value)\r\n        // anova1( stats, [...[...n].fill(\"A\"), [...m].fill(\"B\")] );\r\n        // return { value: anova1.statistic, type: NUMBER };\r\n        return { type: ERROR, value: \"NOT IMPLEMENTED\" };\r\n    },\r\n    FVSCHEDULE: ([{value:principal},{value:schedule,type}]) => type !== LIST ? {\r\n        type: ERROR,\r\n        value: VVALUE,\r\n        meta: { error: \"Expected FVSCHEDULE's schedule to be of type LIST, found \"+type }\r\n    } : { \r\n        type: schedule.some(({type:t}) => t !== NUMBER && t !== NULL) ? ERROR : NUMBER,\r\n        value: schedule.reduce((p, {value,type:t}) => t !== NUMBER && t !== NULL ? VVALUE : p * (1+(value || 0)), principal)\r\n    },\r\n    GAMMA: ([{value}]) => ({ type: NULL, value }),\r\n    \"GAMMA.DIST\": ([{value}]) => ({ type: NULL, value }),\r\n    GAMMADIST: ([{value}]) => ({ type: NULL, value }),\r\n    \"GAMMA.INV\": ([{value}]) => ({ type: NULL, value }),\r\n    GAMMAINV: ([{value}]) => ({ type: NULL, value }),\r\n    GAMMALN: ([{value}]) => ({ type: NULL, value }),\r\n    \"GAMMALN.PRECISE\": ([{value}]) => ({ type: NULL, value }),\r\n    \r\n    GAUSS: ([{value}]) => ({ type: NULL, value }), // standard normal cumulative distribution - 0.5\r\n    _GCD2: ([{value:xx},{value:yy},...args]) => {\r\n        // todo: Use more efficient alg for lib\r\n        let x = Math.abs(xx);\r\n        let y = Math.abs(yy);\r\n        while(y) {\r\n          var t = y;\r\n          y = x % y;\r\n          x = t;\r\n        }\r\n        return { type: NUMBER, value: x };\r\n    },\r\n    GCD: (args,context) => {\r\n        return args.reduce((p,i) => context.functions._GCD2([p,i],context));\r\n    },\r\n    GEOMEAN: (allargs,context) => {\r\n          const [prod, count] = allargs.reduce(([prod,count], { value, type }) => {\r\n            switch(type) {\r\n              case NULL:\r\n                  return [prod,count];\r\n              case NUMBER:\r\n                return [prod*value,count+1];\r\n              case LIST:\r\n                const {meta:{count:c,prod:p}} = context.functions.GEOMEAN(value,context);\r\n                return [prod*p,count+c];\r\n              default:\r\n                throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in GEOMEAN\");\r\n            }\r\n        }, [1,0]);\r\n        return { type: NUMBER, value: Math.pow(prod, 1/count), meta: { prod, count }};\r\n    },\r\n    GESTEP: ([{value},{value:step}={value:0}]) => ({ type: NUMBER, value: +(value > step) }),\r\n    GETPIVOTDATA: ([{value}]) => ({ type: NULL, value }), // ?? we don't have pivot table currently\r\n    GROWTH: ([{value}]) => ({ type: NULL, value }),//  maybe https://github.com/Tom-Alexander/regression-js or https://www.npmjs.com/package/exponential-regression\r\n    HARMEAN: (allargs,context) => {\r\n          const [sum, count] = allargs.reduce(([sum,count], { value, type }) => {\r\n            switch(type) {\r\n              case NULL:\r\n                  return [sum,count];\r\n              case NUMBER:\r\n                return [sum+1/value,count+1];\r\n              case LIST:\r\n                const {meta:{count:c,sum:p}} = context.functions.HARMEAN(value,context);\r\n                return [sum+p,count+c];\r\n              default:\r\n                throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in HARMEAN\");\r\n            }\r\n        }, [0,0]);\r\n        return { type: NUMBER, value: count/sum, meta: { sum, count }};\r\n    },\r\n    HEX2BIN: ([{value},{value:dec}={value:0}]) => ({ type: STRING, value: parseInt(value,16).toString(2).padStart(dec,\"0\") }),\r\n    HEX2DEC: ([{value}]) => ({ type: NUMBER, value: parseInt(value,16) }),\r\n    HEX2OCT: ([{value},{value:dec}={value:0}]) => ({ type: STRING, value: parseInt(value,16).toString(8).padStart(dec,\"0\") }),\r\n    HLOOKUP: ([lookup_value,table_array,row_index_num,range_lookup={ type: BOOLEAN, value: true }], context) => {\r\n        if(table_array.type === LIST) {\r\n            table_array = { type: MATRIX, value: [table_array.value] }\r\n        }\r\n        if(table_array.type !== MATRIX) {\r\n            throw new Error(\"Expected table_array to be a MATRIX but found \"+table_array.value+\" (\"+table_array.type+\")\");\r\n        }\r\n        \r\n        const idx = table_array.value.findIndex(([i]) => lookup_value.value == i.value ||\r\n            (lookup_value.type === STRING && i.type === STRING && lookup_value.value.toLowerCase() === i.value.toLowerCase())\r\n        );\r\n        if(idx > -1) {\r\n            // Exact match\r\n            return table_array.value[idx][row_index_num.value-1];\r\n        }\r\n        if(!range_lookup.value) {\r\n            return { type: ERROR, value: NAVALUE };\r\n        }\r\n        // Range lookup: Return last values of values that are smaller than criteria\r\n        const searchr = [].concat(table_array.value.map(([i]) => i));\r\n        const { _GREATER } = context.functions;\r\n        let item = { type: ERROR, value: NAVALUE };\r\n        while(searchr.length) {\r\n            if(_GREATER(searchr[0].value, lookup_value.value)) {\r\n                return item;\r\n            }\r\n            const idx = table_array.value[0][0].length - searchr.length;// 0, 1, 2, 3, ....\r\n            item = table_array.value[idx][row_index_num.value-1];\r\n            searchr.shift();\r\n        }\r\n        return item;\r\n    },\r\n\r\n    \"HYPGEOM.DIST\": ([{value}]) => ({ type: NULL, value }), // todo\r\n    HYPGEOMDIST: ([{value}]) => ({ type: NULL, value }), // todo\r\n    IFS: (args, context) => {\r\n        for(let idx = 0;idx < args.length; idx+=2) {\r\n            const {value} = args[idx];\r\n            if(value) {\r\n                return {...args[idx+1]};\r\n            }\r\n        }\r\n        return { type: ERROR, value: NAVALUE };\r\n    },\r\n    _PARSECOMPLEXSTRING: ({value},context) => {\r\n        if(value === \"i\" || value === \"j\") {\r\n            return {i:1, r:0, suffix: value};\r\n        }\r\n        if(value === \"-i\" || value === \"-j\") {\r\n            return {i:-1, r:0, suffix: value[value.length-1]};\r\n        }\r\n        let [r,i] = value.split(\"+\").map(u => u.trim());\r\n        if(r && i && (i.endsWith(\"j\") || i.endsWith(\"i\"))) {\r\n          const fi = i === \"i\" || i === \"j\" ? 1 : parseFloat(i);\r\n          const fr = parseFloat(r);\r\n          return {i:fi, r:fr, suffix: i[i.length-1]};\r\n        }\r\n        [r,i] = value.split(\"-\").map(u => u.trim());\r\n        if(r && i && (i.endsWith(\"j\") || i.endsWith(\"i\"))) {\r\n          const fi = i === \"i\" || i === \"j\" ? -1 : parseFloat(i || \"1\") * -1;\r\n          const fr = parseFloat(r);\r\n          return {i:fi, r:fr, suffix: i[i.length-1]};\r\n        }\r\n        if(value.endsWith(\"j\") || value.endsWith(\"i\")) {\r\n            return {i:parseFloat(value), r:0, suffix: value[value.length-1]};\r\n        }\r\n        const rr = parseFloat(value);\r\n        if(!isNaN(rr)) {\r\n            return {i:0, r:rr, suffix: \"i\"};\r\n        }\r\n        return { type: ERROR, value: \"_PARSECOMPLEX requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(value)}\r\n    },\r\n    _PARSECOMPLEX: ({value,type,meta},context) => {\r\n        if(type === NUMBER) {\r\n            return { i: 0, r: value, suffix: \"i\" };\r\n        }\r\n        const { type: mt, r:r0, i:i0, suffix:s } = meta || {};\r\n        if(mt === COMPLEX_NUMBER) {\r\n            return { i: i0, r: r0, suffix: s };\r\n        }\r\n        return context.functions._PARSECOMPLEXSTRING({value},context)\r\n    },\r\n    IMABS: ([arg],context) => {\r\n        const {r,i,type} = context.functions._PARSECOMPLEX(arg,context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMABS requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(arg.value)}\r\n        }\r\n        return { type: NUMBER, value: Math.sqrt(r*r + i*i) };\r\n    },\r\n    IMAGINARY: ([arg],context) => {\r\n        const {i,type} = context.functions._PARSECOMPLEX(arg,context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMAGINARY requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(arg.value)}\r\n        }\r\n        return { type: NUMBER, value: i };\r\n    },\r\n    IMARGUMENT: ([arg],context) => {\r\n        const {i,r,type} = context.functions._PARSECOMPLEX(arg,context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMARGUMENT requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(arg.value)}\r\n        }\r\n        return { type: NUMBER, value: Math.atan(i/r) };\r\n    },\r\n    IMCONJUGATE: ([arg],context) => {\r\n        const {i,r,type,suffix} = context.functions._PARSECOMPLEX(arg,context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMCONJUGATE requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(arg.value)}\r\n        }\r\n        const ic = i * -1;\r\n        return { type: STRING, value: r+\"+\"+ic+suffix, meta: { type: COMPLEX_NUMBER, r, i:ic, suffix } };\r\n    },\r\n    IMCOS: ([arg],context) => {\r\n        // cosh(-y) cos(x) + i sinh(-y) sin(x)\r\n        const {i,r,type,suffix} = context.functions._PARSECOMPLEX(arg,context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMCOS requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(arg.value)}\r\n        }\r\n        const real = Math.cos(r)*Math.cosh(-i);\r\n        const img = Math.sin(r)*Math.sinh(-i);\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    IMCOSH: ([arg],context) => {\r\n        // cosh(x) cos(y) + i sinh(x) sin(y)\r\n        const {i,r,type,suffix} = context.functions._PARSECOMPLEX(arg,context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMCOSH requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(arg.value)}\r\n        }\r\n        const real = Math.cosh(r)*Math.cos(i);\r\n        const img = Math.sinh(r)*Math.sin(i);\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    IMCOT: ([arg],context) => {\r\n        // (sin(2r) - j sinh(2i)) / (cosh(2i)-cos(2r))\r\n        const {i,r,type,suffix} = context.functions._PARSECOMPLEX(arg,context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMCOT requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(arg.value)}\r\n        }\r\n        const q = Math.cosh(2*i)-Math.cos(2*r);\r\n        const real = Math.sin(2*r)/q;\r\n        const img = Math.sinh(2*i)/q;\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    IMCSC: ([arg],context) => {\r\n        // r =  - 2cosh(i)sin(r) / (cos(2r)-cosh(2i))\r\n        // i = 2cos(r)sinh(i) / (cos(2r)-cosh(2i))\r\n        const {i,r,type,suffix} = context.functions._PARSECOMPLEX(arg,context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMCSC requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(arg.value)}\r\n        }\r\n        const q = Math.cos(2*r)-Math.cosh(2*i);\r\n        const real = -2*Math.cosh(i)*Math.sin(r)/q;\r\n        const img = 2*Math.cos(r)*Math.sinh(i)/q;\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    IMCSCH: ([arg],context) => {\r\n        // r =  - 2sinh(r)cos(i) / (cos(2i)-cosh(2r))\r\n        // i = 2cosh(r)sin(i) / (cos(2r)-cosh(2i))\r\n        const {i,r,type,suffix} = context.functions._PARSECOMPLEX(arg,context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMCSCH requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(arg.value)}\r\n        }\r\n        const q = Math.cos(2*i)-Math.cosh(2*r);\r\n        const real = -2*Math.sinh(r)*Math.cos(i)/q;\r\n        const img = 2*Math.cosh(r)*Math.sin(i)/q;\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    IMDIV: ([x,y],context) => {\r\n        const {i:b,r:a,type:t1,suffix} = context.functions._PARSECOMPLEX(x,context);\r\n        const {i:d,r:c,type:t2} = context.functions._PARSECOMPLEX(y,context)\r\n        if(t1 === ERROR) {\r\n            return { type: ERROR, value: \"IMDIV requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(x.value)}\r\n        }\r\n        if(t2 === ERROR) {\r\n            return { type: ERROR, value: \"IMDIV requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(y.value)}\r\n        }\r\n        //(ac+bd)+(bc-ad)j    /   (c*c+d*d)\r\n        const q = c*c+d*d;\r\n        const real = (a*c+b*d)/q;\r\n        const img = (b*c-a*d)/q\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    IMEXP: ([arg],context) => {\r\n        // w = e^x(cos(y) + i sin(y))\r\n        const {i,r,type,suffix} = context.functions._PARSECOMPLEX(arg,context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMEXP requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(arg.value)}\r\n        }\r\n        const real = Math.exp(r)*Math.cos(i);\r\n        const img = Math.exp(r)*Math.sin(i);\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    IMLN: ([arg],context) => {\r\n        // r = ln(√(x² + y²))\r\n        // i = atan(x/y)\r\n        const {i,r,type,suffix} = context.functions._PARSECOMPLEX(arg,context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMLN requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(arg.value)}\r\n        }\r\n        const real = Math.log(Math.sqrt(r*r+i*i));\r\n        const img = Math.atan(i/r);\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    IMLOG10: (arg,context) => {\r\n        // log10(e)*ln(arg)\r\n        const t = context.functions.IMLN(arg,context);\r\n        if(t.type === ERROR) {\r\n            return t;\r\n        }\r\n        const {r, i, suffix} = t.meta;\r\n        const q = Math.log10(Math.E);\r\n        const real = r*q;\r\n        const img = i*q;\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    IMLOG2: (arg,context) => {\r\n        // log10(e)*ln(arg)\r\n        const t = context.functions.IMLN(arg,context);\r\n        if(t.type === ERROR) {\r\n            return t;\r\n        }\r\n        const {r, i, suffix} = t.meta;\r\n        const q = Math.log2(Math.E);\r\n        const real = r*q;\r\n        const img = i*q;\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    _IMPOWER2: ([x,y],context) => {\r\n        const {i:b,r:a,type:t1,suffix} = context.functions._PARSECOMPLEX(x,context);\r\n        const {i:d,r:c,type:t2} = context.functions._PARSECOMPLEX(y,context)\r\n        if(t1 === ERROR) {\r\n            return { type: ERROR, value: \"IMPOWER requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(x.value)}\r\n        }\r\n        if(t2 === ERROR) {\r\n            return { type: ERROR, value: \"IMPOWER requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(y.value)}\r\n        }\r\n        //(ac-bd)+(ad+bc)j\r\n        const real = (a*c-b*d);\r\n        const img = (b*c+a*d);\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } }; \r\n    },\r\n    IMPOWER: ([arg0,{value:exp}],context) => {\r\n        // e**(x*log(z))\r\n        const t = context.functions.IMLN([arg0],context);\r\n        if(t.type === ERROR) {\r\n            return t;\r\n        }\r\n        const {r, i, suffix} = t.meta;\r\n        return context.functions.IMEXP([{\r\n            type: STRING, value: (r*exp)+\"+\"+(i*exp)+suffix,\r\n            meta: { type: COMPLEX_NUMBER, r:r*exp, i:i*exp, suffix }\r\n        }],context);\r\n    },\r\n    IMPRODUCT: (args,context) => {\r\n        return args.reduce((p,n) => {\r\n            if(p.type === ERROR) {\r\n                return p;\r\n            }\r\n            return context.functions._IMPOWER2([p,n],context);\r\n        });\r\n    },\r\n    IMREAL: ([arg],context) => {\r\n        const {i,r,type,suffix} = context.functions._PARSECOMPLEX(arg,context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMREAL requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(arg.value)}\r\n        }\r\n        return { type: NUMBER, value: r, meta: { type: COMPLEX_NUMBER, r, i:0, suffix } };\r\n    },\r\n    IMSEC: ([arg],context) => {\r\n        // r = 2 cos(r)cosh(i) / cos(2r)+cosh(2i)\r\n        // i = 2 sin(r)sinh(i) / cos(2r)+cosh(2i)\r\n        const {i,r,type,suffix} = context.functions._PARSECOMPLEX(arg,context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMSEC requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(arg.value)}\r\n        }\r\n        const q = Math.cos(2*r)+Math.cosh(2*i);\r\n        const real = 2*Math.cos(r)*Math.cosh(i)/q;\r\n        const img = 2*Math.sin(r)*Math.sinh(i)/q;\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    IMSECH: ([arg],context) => {\r\n        // r = 2 cos(i)cosh(r) / cos(2y)+cosh(2r)\r\n        // i = -2 sin(i)sinh(r) / cos(2y)+cosh(r)\r\n        const {i,r,type,suffix} = context.functions._PARSECOMPLEX(arg,context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMSECH: requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(arg.value)}\r\n        }\r\n        const q = Math.cos(2*i)+Math.cosh(2*r);\r\n        const real = 2*Math.cos(i)*Math.cosh(r)/q;\r\n        const img = -2*Math.sin(i)*Math.sinh(r)/q;\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    IMSIN: ([{value}],context) => {\r\n        // cosh(-y) sin(x) - i sinh(-y) cos(x)\r\n        const {i,r,type,suffix} = context.functions._PARSECOMPLEX({value},context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMCOS requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(value)}\r\n        }\r\n        const real = Math.cos(r)*Math.cosh(-i);\r\n        const img = Math.cos(r)*Math.sinh(-i);\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    IMSINH: ([{value}],context) => {\r\n        const {i,r,type,suffix} = context.functions._PARSECOMPLEX({value},context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMCOS requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(value)}\r\n        }\r\n        const real = Math.cos(i)*Math.sinh(r);\r\n        const img = Math.cosh(r)*Math.sin(i);\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    IMSQRT: ([arg0],context) => context.functions.IMPOWER([arg0,{value:0.5}],context),\r\n    IMSUB: ([x,y],context) => {\r\n        const {i:b,r:a,type:t1,suffix} = context.functions._PARSECOMPLEX(x,context);\r\n        const {i:d,r:c,type:t2} = context.functions._PARSECOMPLEX(y,context)\r\n        if(t1 === ERROR) {\r\n            return { type: ERROR, value: \"IMSUB requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(x.value)}\r\n        }\r\n        if(t2 === ERROR) {\r\n            return { type: ERROR, value: \"IMSUB requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(y.value)}\r\n        }\r\n        const real = a-c;\r\n        const img = b-d\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    _IMSUM2: ([x,y],context) => {\r\n        const {i:b,r:a,type:t1,suffix} = context.functions._PARSECOMPLEX(x,context);\r\n        const {i:d,r:c,type:t2} = context.functions._PARSECOMPLEX(y,context)\r\n        if(t1 === ERROR) {\r\n            return { type: ERROR, value: \"IMSUM requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(x.value)}\r\n        }\r\n        if(t2 === ERROR) {\r\n            return { type: ERROR, value: \"IMSUM requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(y.value)}\r\n        }\r\n        const real = a+c;\r\n        const img = b+d\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    IMSUM: (args,context) => {\r\n        return args.reduce((p,i) => context.functions._IMSUM2([p,i],context));\r\n    },\r\n    IMTAN: ([{value}],context) => {\r\n        // r = sin(2r) / cos(2r)+cosh(2i)\r\n        // i = sinh(2i) / cos(2r)+cosh(2i)\r\n        const {i,r,type,suffix} = context.functions._PARSECOMPLEX({value},context)\r\n        if(type === ERROR) {\r\n            return { type: ERROR, value: \"IMCOS requires the complex number to be entered in the format 'R+I[ij]' where R and I are numbers, found \"+ String(value)}\r\n        }\r\n        const q = Math.cos(2*r)+Math.cosh(2*i);\r\n        const real = Math.sin(2*r)/q;\r\n        const img = Math.sinh(2*i)/q;\r\n        return { type: STRING, value: real+\"+\"+img+suffix, meta: { type: COMPLEX_NUMBER, r:real, i:img, suffix } };\r\n    },\r\n    INFO: ([{value}]) => {\r\n        /*\r\n        \"directory\": Path of the current directory or folder.\r\n        \"numfile\": Number of active worksheets in the open workbooks.\r\n\r\n        \"origin\": Returns the absolute cell reference of the top and leftmost cell visible in the window, based on the current scrolling position, as text prepended with \"$A:\". This value is intended for for Lotus 1-2-3 release 3.x compatibility. The actual value returned depends on the current reference style setting. Using D9 as an example, the return value would be:\r\n        A1 reference style     \"$A:$D$9\".\r\n        R1C1 reference style    \"$A:R9C4\"\r\n\r\n        \"osversion\": Current operating system version, as text.\r\n\r\n        \"recalc\": Current recalculation mode; returns \"Automatic\" or \"Manual\".\r\n\r\n        \"release\": Version of Microsoft Excel, as text.\r\n\r\n        \"system\": Name of the operating environment:\r\n        Macintosh = \"mac\"\r\n        Windows = \"pcdos\"\r\n        */\r\n        switch(value) {\r\n            case \"directory\":\r\n                return { type: STRING, value: window.location+\"\" };\r\n            case \"numfile\":\r\n                return { type: STRING, value: \"To be implemented todo\" };\r\n            case \"origin\":\r\n                return { type: STRING, value: \"$A: todo\" };\r\n            case \"osversion\":\r\n                return { type: STRING, value: navigator.oscpu };\r\n            case \"recalc\":\r\n                return { type: STRING, value: \"todo\" };\r\n            case \"system\":\r\n                return { type: STRING, value: navigator.platform };\r\n            default:\r\n                return navigator[value] ? { type: STRING, value: navigator[value] } : { type: ERROR, value: \"INFO expected a valid kind, but found \"+String(value) };\r\n        }\r\n    },\r\n    INTERCEPT: ([ys,xs],context) => context.functions[\"FORECAST.LINEAR\"]([{value: 0, type: NUMBER},xs,ys],context),\r\n    INTRATE: ([{value}]) => ({ type: NULL, value }), // todo, use fin lib\r\n    IPMT: ([{value}]) => ({ type: NULL, value }), // todo, use fin lib\r\n    IRR: ([{value}]) => ({ type: NULL, value }), // todo, use fin lib\r\n    ISBLANK: ([{value,type}]) => ({ type: BOOLEAN, value: type === NULL && !value }),\r\n    ISERR: ([{value,type}]) => ({ type: BOOLEAN, value: type === ERROR && value !== NAVALUE }), \r\n    ISERROR: ([{value,type}]) => ({ type: BOOLEAN, value: type === ERROR }), \r\n    ISEVEN: ([{value,type}]) => {\r\n        if(type !== NUMBER) {\r\n            return { type: ERROR, value:VVALUE };\r\n        }\r\n        return { type: BOOLEAN, value: Math.floor(value)%2===0 }\r\n    },\r\n    ISFORMULA: ([{formula}]) => ({ type: BOOLEAN, value: formula && formula[0] === \"=\" }),\r\n    ISLOGICAL: ([{type}]) => ({ type: BOOLEAN, value: type === BOOLEAN }),\r\n    ISNA: ([{value}]) => ({ type: BOOLEAN, value: value === NAVALUE }),\r\n    ISNONTEXT: ([{type}]) => ({ type: BOOLEAN, value: type !== STRING }),\r\n    ISNUMBER: ([{type}]) => ({ type: NUBOOLEANLL, value: type === NUMBER }),\r\n    ISODD: ([{value,type}]) => {\r\n        if(type !== NUMBER) {\r\n            return { type: ERROR, value:VVALUE };\r\n        }\r\n        return { type: BOOLEAN, value: Math.floor(value)%2===1 }\r\n    },\r\n    ISREF: ([{type,meta}]) => ({ type: BOOLEAN, value: type !== ERROR && meta && meta.type === CELL }),\r\n    ISTEXT: ([{type}]) => ({ type: BOOLEAN, value: type === STRING }),\r\n    \"ISO.CEILING\": (args,context) => context.functions.CEILING(args,context),\r\n    ISOWEEKNUM: ([a],context) => context.functions.WEEKNUM([a,{value:21,type:NUMBER}],context),\r\n    ISPMT: ([{value:rate},{value:per},{value:nper},{value:pv}]) => {\r\n        const vdecperperiod = pv/nper;\r\n        const remaining = pv-per*vdecperperiod;\r\n        return { type: NUMBER, value: remaining*rate, meta: { reduction_per_period: vdecperperiod, remaining_value: remaining } };\r\n    },\r\n    JIS: ([{value}]) => ({ type: STRING, value: value.split(\"\").map(i =>\r\n        i.charCodeAt(0) < 65248 ? String.fromCharCode(i.charCodeAt(0) + 65248) : i\r\n    ).join(\"\") }),\r\n    KURT: (args,context,start={}) => {\r\n        // algo from https://github.com/compute-io/kurtosis/blob/master/lib/index.js\r\n        const [mean,M2,M3,M4,N] = args.reduce((p, v) => {\r\n          if(p.type === ERROR) {\r\n              return p;\r\n          }\r\n          if(v.type === ERROR) {\r\n              return v;\r\n          }\r\n          const {value,type} = v;\r\n          let [mean,M2,M3,M4,N] = p;\r\n          if(type === LIST) {\r\n              const { meta,type:t,...rest } = context.functions.KURT(value,context,{mean,M2,M3,M4,N});\r\n            if(t === ERROR) {\r\n                return { meta,type,...rest };\r\n            }\r\n            return [meta.mean,meta.M2,meta.M3,meta.M4,meta.N];\r\n          }\r\n          if(type === NUMBER) {\r\n            N += 1;\r\n            const delta = value - mean;\r\n            const delta_n = delta / N;\r\n            const delta_n2 = delta_n * delta_n;\r\n            const term1 = delta * delta_n * (N-1);\r\n            M4 += term1*delta_n2*(N*N - 3*N + 3) + 6*delta_n2*M2 - 4*delta_n*M3;\r\n            M3 += term1*delta_n*(N-2) - 3*delta_n*M2;\r\n            M2 += term1;\r\n            mean += delta_n;\r\n            return [mean,M2,M3,M4,N];\r\n          }\r\n          return [mean,M2,M3,M4,N];\r\n      }, [start.mean||0,start.M2||0,start.M3||0,start.M4||0,start.N||0]);\r\n      // Calculate the population excess kurtosis:\r\n      const g = N*M4 / ( M2*M2 ) - 3;\r\n      // Return the corrected sample excess kurtosis:\r\n      const kurt = (N-1) / ( (N-2)*(N-3) ) * ( (N+1)*g + 6 );\r\n      return { type: NUMBER, value: kurt, meta: { mean,M2,M3,M4,N } };\r\n    },\r\n    _LCM2: ([{value:x,type:t1},{value:y,type:t2}],context) => {\r\n        if(t1 !== NUMBER || t2 !== NUMBER) {\r\n            return { type: ERROR, value: VVALUE, meta: { error: \"Both parameters of _LCM2 need to be numeric, found \"+String(t1)+\"/\"+String(t2) } };\r\n        }\r\n        if(x < 0 || y < 0) {\r\n            return { type: ERROR, value: NUMVALUE, meta: { error: \"Both parameters of _LCM2 need to be >0, found \"+String(x)+\"/\"+String(y) } };\r\n        }\r\n         return {\r\n             type: NUMBER,\r\n            value: (!x || !y) ? 0 : Math.abs((x * y) / context.functions.GCD([{value:x},{value:y}], context).value)\r\n         };\r\n    },\r\n    LCM: (args,context) => {\r\n        return args.reduce((p,i) => context.functions._LCM2([p,i],context));\r\n    },\r\n    LEFT: ([{value:text},{value:num_chars}={value:1}]) => ({ type: STRING, value: text.substring(0,num_chars) }),\r\n    LEFTB: ([{value:str},{value:lengthInBytes}={value:1}]) => {\r\n        // idea from https://stackoverflow.com/questions/11200451/extract-substring-by-utf-8-byte-positions\r\n        const encode_utf8 = s => unescape(encodeURIComponent(s));\r\n        let resultStr = '', bytePos = 0, end = lengthInBytes - 1;\r\n        for (let n = 0; 0 <= end; n++) {\r\n          const ch = str.charCodeAt(n);\r\n          end -= (ch < 128) ? 1 : encode_utf8(str[n]).length;\r\n          resultStr += str[n];\r\n        }\r\n        return { type: STRING, value: resultStr };\r\n    },\r\n    LEN: ([{value}]) => ({ type: NUMBER, value: value.length }),\r\n    LENB: ([{value}]) => ({ type: NUMBER, value: (new TextEncoder().encode(value)).length }),\r\n    LINEST: ([{value}]) => ({ type: NULL, value }), // todo\r\n    LN: ([{value}]) => ({ type: NUMBER, value: Math.log(value) }),\r\n    LOG: ([{value},{value:base}={value:10}]) => ({ type: NUMBER, value: Math.log(value) / Math.log(base) }),\r\n    LOG10: ([{value}]) => ({ type: NUMBER, value: Math.log10(value) }),\r\n    LOGEST: ([{value}]) => ({ type: NULL, value }), // todo\r\n    LOGINV: ([{value}]) => ({ type: NULL, value }), // todo\r\n    \"LOGNORM.DIST\": ([{value}]) => ({ type: NULL, value }), // todo\r\n    LOGNORMDIST: ([{value}]) => ({ type: NULL, value }), // todo\r\n    \"LOGNORM.INV\": ([{value}]) => ({ type: NULL, value }), // todo\r\n    LOOKUP: ([{value:lookup_value,type:t1},{value:lookup_vector,type},{value:result_vector}={}],context) =>  {\r\n        if(type === LIST) {\r\n            // VECTOR FORM\r\n            const idx = lookup_vector.findIndex(({value,type:t2}) =>  lookup_value == value ||\r\n                (t1 === STRING && t2 === STRING && lookup_value.toLowerCase() === value.toLowerCase())\r\n            );\r\n            if(idx) {\r\n                return result_vector ? result_vector[idx] : lookup_vector[idx];\r\n            }\r\n            // Range lookup: Return last values of values that are smaller than criteria\r\n            const searchr = [].concat(lookup_vector);\r\n            const { _GREATER } = context.functions;\r\n            let item = { type: ERROR, value: NAVALUE };\r\n            while(searchr.length) {\r\n                if(_GREATER(searchr[0].value, lookup_value)) {\r\n                    return item;\r\n                }\r\n                const idx = lookup_vector.length - searchr.length;// 0, 1, 2, 3, ....\r\n                item = (result_vector||lookup_vector)[idx];\r\n                searchr.shift();\r\n            }\r\n            return item;\r\n        }\r\n        if(type === MATRIX) {\r\n            // ARRAY FORM\r\n            // If array covers an area that is wider than it is tall -> HLOOKUP\r\n            // If an array is square or is taller than it is wide ->  VLOOKUP\r\n            const f = lookup_vector.length < lookup_vector[0].length ? context.functions.HLOOKUP : context.functions.VLOOKUP;\r\n            const n = lookup_vector.length < lookup_vector[0].length ? lookup_vector.length-1 : lookup_vector[0].length-1;\r\n            return f([{value:lookup_value,type:t1},{value:lookup_vector,type},{value:n,type:NUMBER}],context);\r\n        }\r\n        return { type: ERROR, value: \"Expected LOOKUP's lookup_vector to be LIST or MATRIX, but found \"+String(type) };\r\n    },\r\n    MAXA: (allargs,context) => {\r\n        if(allargs.length === 0) {\r\n            return { type: NUMBER, value: 0 };\r\n        }\r\n        const result = allargs.reduce((max, { value, type }) => {\r\n          switch(type) {\r\n            case STRING:\r\n            case NULL:\r\n            case ERROR:\r\n              return max;\r\n            case DATE:\r\n            case BOOLEAN:\r\n            case NUMBER:\r\n              return max < (+value) ? (+value) : max;\r\n            case LIST:\r\n              const {value:v} = context.functions.MAXA(value,context);\r\n              return max < v? v: max;\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in MAXA\");\r\n         }\r\n       }, -Infinity);\r\n       return { type: NUMBER, value: result };\r\n    },\r\n    _MULTI_IFS: (args, context) => {\r\n        if(args.length < 2) {\r\n            throw new Error(\"Excepted 'criteria_range1, criteria1', but found \"+(args.length?\"'criteria_range1'\":\"no arguments\"));\r\n        }\r\n        if(args.length % 2) { // if 1\r\n            throw new Error(\"Wrong number of arguments, excepted 'criteria_range1, criteria1, [criteria_range2, criteria2]...', but found \"+\r\n            args.map((i, idx) => idx%2?\"criteria\"+Math.ceil((idx+1)/2):\"criteria_range\"+Math.ceil((idx+1)/2)).join(\", \"));\r\n        }\r\n        const [ranges, criteria] = args.reduce(([l1,l2],arg,idx) => \r\n            idx%2?[l1,[...l2, arg]]:[[...l1, arg], l2], // sort into 2 lists, so that [a,1,b,2,c,3]->[[a,b,c],[1,2,3]]\r\n        [[],[]]);\r\n        if(!ranges.every((i,idx,arr) => i.length === arr[0].length)) {\r\n            throw new Error(\"All defined ranges need to have the same length\");\r\n        }\r\n        \r\n        const cfunctions = criteria.map(({value:criterium,type}) => {\r\n          return context.functions._CRITMATCHER([{value:criterium,type}], context);\r\n        });\r\n        return { type: LIST, value: ranges[0].value.map((_, idx) => // pick any range, they're all same length\r\n           ranges.every(({value:r},jdx) => cfunctions[jdx](r[idx]))\r\n        ) }; // returns LIST of [true,false,true,true,...] to filter with\r\n        // todo: re-visit countifs and use this there\r\n    },\r\n    MAXIFS: ([{value:resultv},...args], context) => {\r\n        const {value:bl} = context.functions._MULTI_IFS(args,context);\r\n        const filtered = resultv.filter((__,idx) => bl[idx]);\r\n        return context.functions.MAX(filtered,context);\r\n    },\r\n    MDETERM: ([{value,type}]) => {\r\n        if(type !== MATRIX) {\r\n            return { type: ERROR, value: \"MDETERM expectes its first argument to be a MATRIX, but found \"+String(type) }\r\n        }\r\n        const globalLength = value.length;\r\n        if(value.some(i => i.length !== globalLength)) {\r\n            return { type: ERROR, value: VVALUE, meta: { error: \"MDETERM expectes its first argument to be a square MATRIX of size NxN, but found the matrix not to be squared\" } }\r\n        }\r\n        let nonNumber;\r\n        const hasNonNumber = value.some(i => {\r\n            nonNumber = i.find(({type}) => type !== NUMBER);\r\n            return nonNumber;\r\n        });\r\n        if(hasNonNumber) {\r\n            return { type: ERROR, value: VVALUE, meta: { error: \"MDETERM expectes all elements of the MATRIX to be of type NUMBER, but found \"+String(nonNumber.value)+\" (\"+String(nonNumber.type)+\")\" } }\r\n        }\r\n        // todo: Use more efficient algo from lib\r\n        const det = M => {\r\n            if (M.length==2) {\r\n                return (M[0][0].value*M[1][1].value)-(M[0][1].value*M[1][0].value);\r\n            }\r\n            let answer = 0;\r\n            return M.reduce((p, __, idx) => {\r\n                const sum = Math.pow(-1,idx)*M[0][idx].value*det(deleteRowAndColumn(M,idx)); ;\r\n                return p + sum;\r\n            }, 0);\r\n        }\r\n        const deleteRowAndColumn = (M,index) =>  {\r\n            const temp = M.map(i => i.slice(0));\r\n            temp.splice(0,1); \r\n            temp.forEach(i => i.splice(index,1))\r\n            return temp;\r\n        }\r\n        return {type:NUMBER, value:det(value)};\r\n    },\r\n    MDURATION: ([{value}]) => ({ type: NULL, value }), // todo from fin lib\r\n    MEDIAN: (args,context,w1=1,w2=1) => {\r\n        const { value:count } = context.functions._CELL_COUNTA(args, context);\r\n        const list = args.reduce((p, a) => {\r\n            switch(a.type) {\r\n              case NUMBER:\r\n                  return [...p,a];\r\n              case NULL:\r\n              case DATE:\r\n              case STRING:\r\n              case ERROR:\r\n              case BOOLEAN:\r\n                return p;\r\n              case LIST:\r\n                  const {meta: {list}} = context.functions.MEDIAN(a.value,context);\r\n                  return p.concat(list);\r\n              default:\r\n                throw new Error(\"Disallowed value \"+String(a.value)+\" of type \"+String(a.type)+\" found in MEDIAN\");\r\n           }\r\n        }, []);\r\n        const sorted = list.sort(({value:a},{value:b}) => a-b);\r\n        const middle = count / 2;\r\n        const result = count%2 ? sorted[Math.floor(middle)] : {\r\n            ...sorted[Math.floor(middle)],\r\n            value: (sorted[middle].value*w1 + sorted[middle-1].value*w2)/2\r\n        };\r\n        return { ...result, meta: { list, even: !(count%2), odd: !!(count%2), middle: count%2 ? Math.floor(middle) : middle+.5 } };\r\n    },\r\n    MID: ([{value:text},{value:startnum},{value:num_chars}={value:1}]) => ({ type: STRING, value: text.substring(startnum-1,startnum+num_chars-1) }),\r\n    MIDB: ([{value:text},{value:startnum},{value:lengthInBytes}={value:1}]) => {\r\n        const str = text.substring(startnum-1);\r\n        // idea from https://stackoverflow.com/questions/11200451/extract-substring-by-utf-8-byte-positions\r\n        const encode_utf8 = s => unescape(encodeURIComponent(s));\r\n        let resultStr = '', bytePos = 0, end = lengthInBytes - 1;\r\n        for (let n = 0; 0 <= end; n++) {\r\n          const ch = str.charCodeAt(n);\r\n          end -= (ch < 128) ? 1 : encode_utf8(str[n]).length;\r\n          resultStr += str[n];\r\n        }\r\n        return { type: STRING, value: resultStr };\r\n    },\r\n    MINIFS: ([{value:resultv},...args], context) => {\r\n        const {value:bl} = context.functions._MULTI_IFS(args,context);\r\n        const filtered = resultv.filter((__,idx) => bl[idx]);\r\n        return context.functions.MIN(filtered,context);\r\n    },\r\n    MINA: (allargs,context) => {\r\n        if(allargs.length === 0) {\r\n            return { type: NUMBER, value: 0 };\r\n        }\r\n        const result = allargs.reduce((min, { value, type }) => {\r\n          switch(type) {\r\n            case STRING:\r\n            case NULL:\r\n            case ERROR:\r\n              return min;\r\n            case DATE:\r\n            case BOOLEAN:\r\n            case NUMBER:\r\n              return min > (+value) ? (+value) : min;\r\n            case LIST:\r\n              const {value:v} = context.functions.MINA(value,context);\r\n              return min > v? v: min;\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in MINA\");\r\n         }\r\n       }, Infinity);\r\n       return { type: NUMBER, value: result };\r\n    },\r\n    MINVERSE: ([{value:M,type}]) => {\r\n        // todo: use more efficient algo from lib\r\n        if(type !== MATRIX) {\r\n            return {\r\n              type: ERROR,\r\n              value: VVALUE,\r\n              meta:{error:\"MINVERSE must be called with one argument of type MATRIX, but found \"+String(M)+\" (\"+String(type)+\")\"}\r\n            };\r\n        }\r\n        if(M.some(i => i.length !== M.length)) {\r\n            return {\r\n              type: ERROR,\r\n              value: VVALUE,\r\n              meta:{error:\"MINVERSE must be called with a sqare MATRIX, but found non-sqare MATRIX\"}\r\n            };\r\n        }\r\n        // from http://blog.acipo.com/matrix-inversion-in-javascript/\r\n        let i = 0,\r\n            ii = 0,\r\n            j = 0,\r\n            dim = M.length,\r\n            e = 0,\r\n            t = 0;\r\n        let I = [],\r\n            C = [];\r\n        // Init, including identity\r\n        for (i = 0; i < dim; i += 1) {\r\n            I[I.length] = [];\r\n            C[C.length] = [];\r\n            for (j = 0; j < dim; j += 1) {\r\n                if (i === j) {\r\n                    I[i][j] = 1;\r\n                } else {\r\n                    I[i][j] = 0;\r\n                }\r\n                if (M[i][j].type !== NUMBER) {\r\n                    return {\r\n                        type: ERROR,\r\n                        value: VVALUE,\r\n                        meta: {error:\"MINVERSE's value at \" + String(i) + \"/\" + String(j) + \" is expected to be of type NUMBER, but found \" + String(M[i][j].value) + \" (\" + String(M[i][j].type) + \")\"}\r\n                    }\r\n                }\r\n                C[i][j] = M[i][j].value;\r\n            }\r\n        }\r\n        // do the thing\r\n        for (i = 0; i < dim; i += 1) {\r\n            e = C[i][i];\r\n            if (e === 0) {\r\n                for (ii = i + 1; ii < dim; ii += 1) {\r\n                    if (C[ii][i] !== 0) {\r\n                        for (j = 0; j < dim; j++) {\r\n                            e = C[i][j];\r\n                            C[i][j] = C[ii][j];\r\n                            C[ii][j] = e;\r\n                            e = I[i][j];\r\n                            I[i][j] = I[ii][j];\r\n                            I[ii][j] = e;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                e = C[i][i];\r\n                if (e === 0) {\r\n                    return {\r\n                        type: ERROR,\r\n                        value: NUMVALUE,\r\n                        meta: {\r\n                            error: \"No inverse found!\"\r\n                        }\r\n                    };\r\n                }\r\n            }\r\n            for (j = 0; j < dim; j++) {\r\n                C[i][j] = C[i][j] / e;\r\n                I[i][j] = I[i][j] / e;\r\n            }\r\n            for (ii = 0; ii < dim; ii++) {\r\n                if (ii === i) {\r\n                    continue;\r\n                }\r\n                e = C[ii][i];\r\n                for (j = 0; j < dim; j++) {\r\n                    C[ii][j] -= e * C[i][j];\r\n                    I[ii][j] -= e * I[i][j];\r\n                }\r\n            }\r\n        }\r\n        const IO = I.map(u => u.map(value => ({\r\n            type: NUMBER,\r\n            value\r\n        })))\r\n        return {\r\n            type: MATRIX,\r\n            value: IO\r\n        };\r\n    },\r\n    MIRR: ([{value}]) => ({ type: NULL, value }),// todo use fin lib\r\n    MMULT: ([{value:b,type:t1},{value:c,type:t2}]) => {\r\n        // todo: use more efficient algo from lib\r\n        if(t1 !== MATRIX) {\r\n            return {\r\n              type: ERROR,\r\n              value: VVALUE,\r\n              meta:{error:\"MMULT must be called with one argument of type MATRIX, but found \"+String(b)+\" (\"+String(t1)+\")\"}\r\n            };\r\n        }\r\n        if(t2 !== MATRIX) {\r\n            return {\r\n              type: ERROR,\r\n              value: VVALUE,\r\n              meta:{error:\"MMULT must be called with one argument of type MATRIX, but found \"+String(c)+\" (\"+String(t2)+\")\"}\r\n            };\r\n        }\r\n        if(b.some(i => i.length !== c.length)) {\r\n            const l1 = c[0].length + \"x\" + c.length;\r\n            const l2 = b[0].length + \"x\" + b.length;\r\n            return {\r\n              type: ERROR,\r\n              value: VVALUE,\r\n              meta:{error:\"MMULT must be called with two MATRIXs of NxK and KxM, but found \"+String(l1)+\" and \"+String(l2)}\r\n            };\r\n        }\r\n        // a[i,j] = sum[0..k..n](b[i,k]*c[k,j])\r\n        const a = [];\r\n        const k = c.length;\r\n        for(let i = 0; i < b[0].length; i++) {\r\n          a[i] = [];\r\n          for(let j = 0; j < c.length; j++) {\r\n              let sum = 0;\r\n            for(let t = 0; t < k; t++) {\r\n                console.log(i,k,j,b,c,b[i][t],c[t][j]);\r\n                const {value:x,type:xt} = b[i][t];\r\n                if(xt !== NUMBER) {\r\n                    return {\r\n                      type: ERROR,\r\n                      value: VVALUE,\r\n                      meta:{error:\"MATRIX b supplied to MMULT expected to contain only numeric arguments, but found \"+String(x)+\" (\"+String(xt)+\") at \"+String(i)+\"/\"+String(t)}\r\n                    };\r\n                }\r\n                const {value:y,type:yt} = c[t][j];\r\n                if(yt !== NUMBER) {\r\n                    return {\r\n                      type: ERROR,\r\n                      value: VVALUE,\r\n                      meta:{error:\"MATRIX c supplied to MMULT expected to contain only numeric arguments, but found \"+String(y)+\" (\"+String(yt)+\") at \"+String(t)+\"/\"+String(j)}\r\n                    };\r\n                }\r\n                sum += x*y;\r\n              }\r\n            a[i][j] = { type: NUMBER, value: sum };\r\n          }\r\n        }\r\n        return { type: MATRIX, value: a };\r\n    },\r\n    _MODE_INTERNAL_COUNT: Symbol(\"_MODE_INTERNAL_COUNT\"),\r\n    MODE: (args,context) => {\r\n        const s = context.functions._MODE_INTERNAL_COUNT\r\n        const counts = args.reduce((p, a) => {\r\n            const {type,value} = a;\r\n            switch(type) {\r\n              case NUMBER:\r\n                  return { ...p, [value]: [(p[value] ? p[value][0] : 0) + 1, a] };\r\n              case NULL:\r\n              case DATE:\r\n              case STRING:\r\n              case ERROR:\r\n              case BOOLEAN:\r\n                return p;\r\n              case LIST:\r\n                  const {meta} = context.functions.MEDIAN(value,context);\r\n                  const counts = meta[s];\r\n                  const c = Object.assign({}, p);\r\n                  Object.keys(counts).forEach(k => {\r\n                      const [sum, obj] = counts[k];\r\n                    const esum = c[k] && c[k][0];\r\n                      c[k] = [(esum || 0) + sum, obj];\r\n                  });\r\n                  return c;\r\n              default:\r\n                throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in MEDIAN\");\r\n           }\r\n        }, []);\r\n        const sorted = Object.entries(counts).sort(([__,[a]],[___,[b]]) => b-a);\r\n        const [[key, [sum, obj]]] = sorted;\r\n        const m = new Map(Object.values(counts).map(([v,k]) => [k,v]));\r\n        return { ...obj, meta: { [s]: counts, counts: m, max: sum } };\r\n    },\r\n    \"MODE.MULT\": (args,context) => {\r\n        const {meta} = context.functions.MODE(args,context);\r\n        const {counts,max} = meta;\r\n        const rr = Array.from(counts).filter(([__,c]) => c===max).map(([v]) => v);\r\n        return { type: ARGUMENTS, value: rr, meta };\r\n    }, \r\n    \"MODE.SNGL\": (args,context) => {\r\n        const a = context.functions.MODE(args,context);\r\n        const {meta:{max}} = a;\r\n        if(max < 2) {\r\n            return { type: ERROR, value: NAVALUE, meta: { result: a, error: \"MODE.SNGL expected duplicate values to exists, but found a max-count of \"+String(max) } };\r\n        }\r\n        return a;\r\n    },\r\n    MULTINOMIAL: (allargs,_context) => {\r\n        const [sum,product] = allargs.reduce(([sum,product], { value, type }) => {\r\n          switch(type) {\r\n              case NULL:\r\n            case ERROR:\r\n            case BOOLEAN:\r\n            case STRING:\r\n                return [sum,product];\r\n            case NUMBER:\r\n            case DATE:\r\n              const fac = _context.functions._FACTORIAL([{value}],_context);\r\n              return [sum+value,product*fac];\r\n            case LIST:\r\n                const {meta:{sum:s,product:p}} = _context.functions.MULTINOMIAL(value, _context);\r\n                  return [sum+s,product*p];\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in MULTINOMIAL\");\r\n          }\r\n      }, [0,1]);\r\n      const fact = _context.functions._FACTORIAL([{value:sum}],_context);\r\n      return { type: NUMBER, value: fact/product, meta: { sum,product } };\r\n    },\r\n    MUNIT: ([{type,value}]) => {\r\n        // matrix identity\r\n        if(type !== NUMBER) {\r\n            return {type: ERROR, value: VVALUE, meta: {error: \"MUNIT expected its argument to be NUMBER, but found \"+String(value)+\" (\"+String(type)+\")\"}}\r\n        }\r\n        const t = Math.floor(value);\r\n        const a = [];\r\n        for(let i = 0; i < t; i++) {\r\n            a[i]=[];\r\n          for(let j = 0; j < t; j++) {\r\n            a[i][j] = { type: NUMBER, value: +(j===i) };\r\n          }\r\n        }\r\n        return { type: MATRIX, value: a, meta: { dimension: t } };\r\n    },\r\n    N: ([a]) => {\r\n        const {type,value} = a;\r\n        switch(type) {\r\n            case NUMBER:\r\n            case ERROR:\r\n                return a;\r\n            case BOOLEAN:\r\n                return { type: NUMBER, value: +value };\r\n            case DATE:\r\n                return { type: NUMBER, value: value.getTime() };\r\n            default:\r\n              return { type: NUMBER, value: 0 };\r\n          }\r\n    \r\n    },\r\n    NA: () => ({ type: ERROR, value: NAVALUE  }),\r\n    \"NEGBINOM.DIST\": ([{value}]) => ({ type: NULL, value }), // todo: use math lib\r\n    NEGBINOMDIST: ([{value}]) => ({ type: NULL, value }), // todo: use math lib\r\n    NOMINAL: ([{value:eff},{value:npery}]) => {\r\n        // eff = (1+Nom_rate/npery)**npery - 1\r\n        // (eff + 1)**(1/npery) = 1+Nom_rate/npery\r\n        // ((eff + 1)**(1/npery) - 1) * npery = nom_rate\r\n        const nom_rate = ((eff + 1)**(1/npery) - 1) * npery\r\n        return { type: NUMBER, value: nom_rate };\r\n    },\r\n    \"NORM.DIST\": ([{value}]) => ({ type: NULL, value }), // todo: use math lib\r\n    NORMDIST: ([{value}]) => ({ type: NULL, value }), // todo: use math lib\r\n    NORMINV: ([{value}]) => ({ type: NULL, value }), // todo: use math lib\r\n    \"NORM.INV\": ([{value}]) => ({ type: NULL, value }), // todo: use math lib\r\n    \"NORM.S.DIST\": ([{value}]) => ({ type: NULL, value }), // todo: use math lib\r\n    NORMSDIST: ([{value}]) => ({ type: NULL, value }), // todo: use math lib\r\n    \"NORM.S.INV\": ([{value}]) => ({ type: NULL, value }), // todo: use math lib\r\n    NORMSINV: ([{value}]) => ({ type: NULL, value }), // todo: use math lib\r\n    NPER: ([{value}]) => ({ type: NULL, value }), // todo: use fin lib\r\n    NPV: ([{value:rate},...args],context,startIdx = 1) => {\r\n        // sum(value[i] / (1+rate)**i)\r\n        const [sum,sidx] = args.reduce(([sum,sidx],{type,value}) => {\r\n            switch(type) {\r\n              case NUMBER:\r\n                  return [sum + ( value / (1+rate)**sidx ), sidx + 1];\r\n              case NULL:\r\n              case DATE:\r\n              case STRING:\r\n              case ERROR:\r\n              case BOOLEAN:\r\n                return [sum,sidx];\r\n              case LIST:\r\n                  const {meta:{sum:s,sidx:si}} = context.functions.NPV([{value:rate},...value],context,sidx);\r\n                  return [sum + s, si];\r\n              default:\r\n                throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in MEDIAN\");\r\n           }\r\n        }, [0,startIdx]);\r\n        \r\n        return { type: NUMBER, value: sum, meta: { sum,sidx } };\r\n    },\r\n    NUMBERVALUE: ([{value:text},{value:decimal}={},{value:group}={}]) => {\r\n        const ctext = text.replace(/[ %\\t\\n\\r]/g,\"\");\r\n        if(ctext === \"\") {\r\n            return { type: NUMBER, value: 0 };\r\n        }\r\n        const [dec] = decimal || Intl.NumberFormat()\r\n                .formatToParts(1.1)\r\n                .find(part => part.type === 'decimal')\r\n                .value;\r\n        const [gr] = group || Intl.NumberFormat()\r\n                .formatToParts(10000000)\r\n                .find(part => part.type === 'group')\r\n                .value;\r\n        const [percents] = text.match(/(%)*$/);\r\n        const [inte,deci=\"\",e] = ctext.split(dec);\r\n        if(e) {\r\n            return { type: ERROR, value: VVALUE, meta: {error: \"decimal seperator used more than once in NUMBERVALUE's text-argument; only one usage of \"+String(dec)+\" is allowed\"} };\r\n        }\r\n        if(deci.indexOf(gr) > -1) {\r\n            return { type: ERROR, value: VVALUE, meta: {error: \"group seperator must not be used in NUMBERVALUE's text-argument's *decimal*-part; usage of \"+String(gr)+\" is only allowed in its integer part\"} };\r\n        }\r\n        const cinte = inte.split(gr).join(\"\"); // avoids constructing regex\r\n        const reg = /[^0-9+-]/;\r\n        if(reg.test(cinte) || reg.test(deci)) {\r\n            const ch = cinte.match(reg) || deci.match(reg);\r\n            return { type: ERROR, value: VVALUE, meta: {error: \"NUMBERVALUE's text-argument must not include any other signs but 0-9, +, -, \"+String(dec)+\", \"+String(gr)+\", % and ' ' (space), but found \"+String(ch[0])} };\r\n        }\r\n        const number = parseFloat(cinte+\".\"+deci) / Math.pow(100, percents.length);\r\n        return { type: NUMBER, value: number, meta: { percents: percents.length, decimal: dec, group: gr } };\r\n    },\r\n    OCT2BIN: ([{value},{value:dec}={value:0}]) =>\r\n        ({ type: STRING, value: parseInt(value,8).toString(2).padStart(dec,\"0\") }),\r\n    OCT2DEC: ([{value},{value:dec}={value:0}]) =>\r\n        ({ type: NUMBER, value: parseInt(value,8) }),\r\n    OCT2HEX: ([{value},{value:dec}={value:0}]) =>\r\n        ({ type: STRING, value: parseInt(value,8).toString(16).padStart(dec,\"0\") }),\r\n    ODDFPRICE: ([{value}]) => ({ type: NULL, value }), // todo: use fin lib\r\n    ODDFYIELD: ([{value}]) => ({ type: NULL, value }), // todo: use fin lib\r\n    ODDLPRICE: ([{value}]) => ({ type: NULL, value }), // todo: use fin lib\r\n    ODDLYIELD: ([{value}]) => ({ type: NULL, value }), // todo: use fin lib\r\n    PDURATION: ([{value:rate},{value:pv},{value:fv}]) => {\r\n        // (log(fv) - log(pv)) / log(1+rate)\r\n        const r = (Math.log(fv) - Math.log(pv)) / Math.log(1+rate);\r\n        return { type: NUMBER, value: r };\r\n    },\r\n    PEARSON: ([{value:a,type:t1},{value:b,type:t2}],_context) => {\r\n        if(t1 !== LIST || t2 !== LIST) {\r\n            return {type:ERROR, value: \"PEARSON's arguments must be LISTs, but found \"+String(a)+\" (\"+String(t1)+\") / \"+String(b)+\" (\"+String(t2)+\")\"};\r\n        }\r\n        if(a.length !== b.length) {\r\n            return {type:ERROR, value: \"PEARSON's arguments must have the same length\"};\r\n        }\r\n        // r = sum((x-xbar)*(y-ybar)) / sqrt(sum((x-xbar)**2) * sum((y-ybar)**2))\r\n        // r = u / sqrt( u, k )\r\n        const {value:avga} = _context.functions.AVERAGE(a,_context);\r\n        const {value:avgb} = _context.functions.AVERAGE(b,_context);\r\n        const [u,h,k] = a.reduce(([s1,s2,s3], {value:x},idx) => {\r\n            const {value:y} = b[idx];\r\n            return [\r\n                s1+(x-avga)*(y-avgb),\r\n                s2+(x-avga)*(x-avga),\r\n                s3+(y-avgb)*(y-avgb)\r\n            ];\r\n        }, [0,0,0]);\r\n        return { value: u / Math.sqrt(h * k), type: NUMBER };\r\n    },\r\n    \"PERCENTILE.EXC\": ([{value:arr},{value:k}]) => {\r\n        const sortedarr = arr.sort(({value:a},{value:b}) => a-b);\r\n        const idx = k * (arr.length + 1);\r\n        const idxx = Math.floor(idx);\r\n        if(idxx <= 0 || idxx >= arr.length) {\r\n            return { type: ERROR, value: NAVALUE, meta: { error: \"percentile out of range\", idxx }  };\r\n        }\r\n        const r = idx % 1 !== 0 ? // not whole number\r\n          sortedarr[Math.ceil(idx)-1].value :\r\n          (sortedarr[idx-1].value + sortedarr[idx].value) / 2;\r\n        return { type: NUMBER, value: idx, meta: { idxx, idx, sorted: sortedarr, percentile: r } };\r\n    },\r\n    \"PERCENTILE.INC\": ([{value:arr},{value:k}]) => {\r\n        const sortedarr = arr.sort(({value:a},{value:b}) => a-b);\r\n        const idx = k*(arr.length-1)+1;\r\n        const idxx = Math.floor(idx);\r\n        if(idxx <= 0 || idxx > arr.length) {\r\n            return { type: ERROR, value: NAVALUE, meta: { error: \"percentile out of range\", idxx }  };\r\n        }\r\n        return { type: NUMBER, value: idx, meta: { idxx, idx, sorted: sortedarr } };\r\n    },\r\n    PERCENTILE: (args,context) => context.functions[\"PERCENTILE.INC\"](args,context),\r\n    \"PERCENTRANK.EXC\": ([{value:arr},{value:x},{value:sig}={value:3}],context) => {\r\n        const sortedarr = arr.sort(({value:a},{value:b}) => a-b);//.slice(1,-1)\r\n        if(sortedarr.some(({value:i}) => i === x)) {\r\n            // inclusive -->> '<=' and '>='\r\n            const lt = sortedarr.filter(({value:i}) => i<=x).length;\r\n            const gt = sortedarr.filter(({value:i}) => i>=x).length;\r\n            return { type: NUMBER, value: lt / (lt + gt), meta: { lt,gt,sorted: sortedarr } };\r\n        }\r\n        const ii = sortedarr.findIndex(({value:i}) => i>x);\r\n        const P1 = (ii + 1) / (sortedarr.length + 1);\r\n        const V1 = sortedarr[ii].value;\r\n        const P2 = (ii) / (sortedarr.length + 1);\r\n        const V2 = sortedarr[(ii - 1)].value;\r\n        const P = (x-V2)/(V1-V2);\r\n        const r = P2 + P * (P1-P2);\r\n        \r\n        const r0 = context.functions.ROUND([{value:sig},{value:sig}],context);\r\n        return { type: NUMBER, value: r0, meta: { /*sorted: sortedarr,*/ P1, P2, V1, V2, P } };\r\n    },\r\n    \"PERCENTRANK.INC\": (args,context) => context.functions.PERCENTRANK(args,context),\r\n    PERCENTRANK: ([{value:arr},{value:x},{value:sig}={value:3}],context) => {\r\n        const sortedarr = arr.sort(({value:a},{value:b}) => a-b); //.slice(0,-1)\r\n        /*\r\n        Value present\r\n        Count1 = count of values in Array below than a Value\r\n        Count2 = count of values in Array above than a Value\r\n        PercentRank = Count1 / (Count1 + Count2)\r\n\r\n        Value not present\r\n        PercentRank1 = PercentRank of the minimal value Value1 in Array not less than a Value\r\n        PercentRank2 = PercentRank of the maximal value Value2 in Array not greater than a Value\r\n        PercentRank = (PercentRank1 * (Value1 - Value) + PercentRank2 * (Value - Value2)) / (Value1 - Value2)           \r\n        */\r\n        if(sortedarr.some(({value:i}) => i === x)) {\r\n            const lt = sortedarr.filter(({value:i}) => i<x).length;\r\n            const gt = sortedarr.filter(({value:i}) => i>x).length;\r\n            return { type: NUMBER, value: lt / (lt + gt), meta: { lt,gt,sorted: sortedarr } };\r\n        }\r\n        const ii = sortedarr.findIndex(({value:i}) => i>x);\r\n        const P1 = ii / (sortedarr.length - 1);\r\n        const V1 = sortedarr[ii].value;\r\n        const P2 = (ii - 1) / (sortedarr.length - 1);\r\n        const V2 = sortedarr[(ii - 1)].value;\r\n        const P = (x-V2)/(V1-V2);\r\n        const r = P2 + P * (P1-P2);\r\n        \r\n        const r0 = context.functions.ROUND([{value:sig},{value:sig}],context);\r\n        return { type: NUMBER, value: r0, meta: { sorted: sortedarr, P1, P2, V1, V2, P } };\r\n    },\r\n    PERMUT: ([{value:n},{value:k}],context) => {\r\n        // n!/(n-k)!\r\n        const o = context.functions._FACTORIAL([{value:n}],context);\r\n        const u = context.functions._FACTORIAL([{value:(n-k)}],context);\r\n        return { type: NUMBER, value: o/u }\r\n    },\r\n    PERMUTATIONA: ([{value:t},{value:c}]) => ({ type: NUMBER, value: Math.pow(t,c) }),\r\n    PHI: ([{value}]) => ({ type: NULL, value }), // todo: use stats lib\r\n    PHONETIC: ([{value}]) => ({ type: NULL, value }), //  ah, no, this will require huge dictionaries\r\n    PI: () => ({ type: NUMBER, value: Math.PI }),\r\n    PMT: ([{value}]) => ({ type: NULL, value }), // todo: use fin lib\r\n    \"POISSON.DIST\": ([{value}]) => ({ type: NULL, value }), // todo: use stats lib\r\n    POISSON: ([{value}]) => ({ type: NULL, value }), // todo: use stats lib\r\n    POWER: ([{value:n},{value:p}]) => ({ type: NUMBER, value: Math.pow(n,p) }),\r\n    PPMT: ([{value}]) => ({ type: NULL, value }), // todo: use fin lib\r\n    PRICE: ([{value}]) => ({ type: NULL, value }), // todo: use fin lib\r\n    PRICEDISC: ([{value}]) => ({ type: NULL, value }), // todo: use fin lib\r\n    PRICEMAT: ([{value}]) => ({ type: NULL, value }), // todo: use fin lib\r\n    PROB: ([{value:x_range,type:t1}, {value:prob_range,type:t2}, {value:lower_limit}, {value:upper_limit}={}]) => {\r\n        if(t1 !== LIST || t2 !== LIST) {\r\n            return { type: ERROR, value: \"Expected PROB's first two arguments to be LISTs, but found \"+String(t1)+\"/\"+String(t2) };\r\n        }\r\n        /*\r\n        If any value in prob_range ≤ 0 or if any value in prob_range > 1, PROB returns the #NUM! error value.\r\n        If the sum of the values in prob_range is not equal to 1, PROB returns the #NUM! error value.\r\n        If upper_limit is omitted, PROB returns the probability of being equal to lower_limit.\r\n        If x_range and prob_range contain a different number of data points, PROB returns the #N/A error value.\r\n        */\r\n        const outofrangeprob = prob_range.find(({value:v}) => v<=0 || v>1);\r\n        if(outofrangeprob) {\r\n            return { type: ERROR, value: NUMVALUE, meta: { error: \"PROB's probabilities must be >0 and <= 1, but found \"+String(outofrangeprob.value)+\" (\"+String(outofrangeprob.type)+\")\" } }\r\n        }\r\n        const probsum = prob_range.reduce((s,{value:v}) => s+v,0);\r\n        if(probsum !== 1) {\r\n            return { type: ERROR, value: NUMVALUE, meta: { error: \"PROB's probabilities must add up to 1, but only add up to \"+String(probsum) } }\r\n        }\r\n        if(x_range.length !== prob_range.length) {\r\n            return { type: ERROR, value: NAVALUE, meta: { error: \"PROB's x-list and probabilities must have the same length, but found \"+String(x_range.length)+\"/\"+String(prob_range.length) } }\r\n        }\r\n        \r\n        if(upper_limit != null) {\r\n            const pmap = x_range.map(({value},idx) => ({value,p:prob_range[idx]}));\r\n            const valuesInRange = pmap.filter(({value:v}) => v>=lower_limit&&v<=upper_limit);\r\n            const r = valuesInRange.reduce((p,{p:{value:v}}) => p+v, 0);\r\n            return { type: NUMBER, value: r, meta: { valuesInRange, mode: \"RANGE\" } };\r\n        }\r\n        // find lower_limit\r\n        const idx = x_range.findIndex(({value}) => value===lower_limit);\r\n        return { ...prob_range[idx], meta: { idx, mode: \"MATCH\" } };\r\n    },\r\n    PRODUCT: (allargs, _context) => {\r\n      const result = allargs.reduce((sum, { value, type }) => {\r\n          switch(type) {\r\n              case NULL:\r\n            case BOOLEAN:\r\n                return sum;\r\n            case NUMBER:\r\n            case DATE:\r\n              return sum * value;\r\n            case LIST:\r\n                const {value:product} = _context.functions.PRODUCT(value, _context);\r\n                  return sum * product;\r\n            case STRING:\r\n                const v2 =parseFloat(value);\r\n                return Number.isNaN(v2) ? sum : sum * v2; \r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in SUM\");\r\n          }\r\n      }, 0);\r\n      return { type: NUMBER, value: result };\r\n    },\r\n    PV: ([{value}]) => ({ type: NULL, value }), // todo: use fin-lib\r\n    QUARTILE: (args,context) => context.functions[\"QUARTILE.INC\"](args,context),\r\n    \"QUARTILE.EXC\": ([{value:arr},{value:qrt}],context) => {\r\n        switch(qrt) {\r\n            case 0:\r\n                return context.functions.MIN(arr,context);\r\n            case 2:\r\n                return context.functions.MEDIAN(arr,context);\r\n            case 4:\r\n                return context.functions.MAX(arr,context);\r\n            case 1:\r\n                return context.functions.MEDIAN(arr.slice(0,Math.floor(arr.length/2)),context,1.5,0.5);\r\n            case 3:\r\n                return context.functions.MEDIAN(arr.slice(Math.ceil(arr.length/2)),context,0.5,1.5);\r\n            default:\r\n                return { type: ERROR, value: NUMVALUE, meta: { error: \"Invalid quartile \"+String(qrt)+\" in QUARTILE.EXC, must be <=0 and >=4\" } }\r\n        }\r\n    },\r\n    \"QUARTILE.INC\": ([{value:arr},{value:qrt}],context) => {\r\n        switch(qrt) {\r\n            case 0:\r\n                return context.functions.MIN(arr,context);\r\n            case 2:\r\n                return context.functions.MEDIAN(arr,context);\r\n            case 4:\r\n                return context.functions.MAX(arr,context);\r\n            case 1:\r\n                return context.functions.MEDIAN(arr.slice(0,Math.ceil(arr.length/2)),context,1.5,0.5);\r\n            case 3:\r\n                return context.functions.MEDIAN(arr.slice(Math.floor(arr.length/2)),context,0.5,1.5);\r\n            default:\r\n                return { type: ERROR, value: NUMVALUE, meta: { error: \"Invalid quartile \"+String(qrt)+\" in QUARTILE.INC, must be <=0 and >=4\" } }\r\n        }\r\n    },\r\n    QUOTIENT: ([{value:n},{value:q}]) => ({ type: NUMBER, value: n < 0 ? Math.ceil(n/q) : Math.floor(n/q) }),\r\n    RADIANS: ([{value:d}]) => ({ type: NUMBER, value: d / 180 * Math.PI }),\r\n    RANDARRAY: ([\r\n        {value:rows}={value:1},\r\n        {value:columns}={value:1},\r\n        min={value:0},\r\n        max={value:1},\r\n        {value:whole_number}={value:false}\r\n    ],context) => {\r\n        if(min.value >= max.value) {\r\n            return { type: ERROR, value: VVALUE, meta: { error: \"RANDARRAY's min must be >= max, but found min \"+String(min.value)+\" >= max \"+String(max.value) } }\r\n        }\r\n        const f = whole_number ? \r\n            () => context.functions.RANDBETWEEN([min,max],context) :\r\n            () => ({ type: NUMBER, value: Math.random() * (max.value - min.value) + min.value });\r\n        \r\n        if(rows===1 && columns===1) {\r\n            return f();\r\n        }\r\n        if(rows===1 || columns===1) {\r\n            return { type: LIST, value: Array.from({ length: Math.max(rows,columns) }).map(f), rowspan: rows, colspan: columns };\r\n        }\r\n        return { type: MATRIX, value: Array.from({ length: rows })\r\n            .map(() => Array.from({ length: columns }).map(f)), rowspan: rows, colspan: columns };\r\n    },\r\n    _RANKG: ([{value:search},{value:arr},{value:order}={value:0}],context) => {\r\n        const ref = arr.sort(({value:a},{value:b}) => order ? a-b : b-a)\r\n        const vs = ref\r\n            .map((i,idx,arr) => ({...i, idx: idx+1 }))\r\n            .filter(({value:v}) => v===search)\r\n            .map(({idx})=> ({value:idx,type:NUMBER}));\r\n        return { type: LIST, value: vs };\r\n    },\r\n    \"RANK.AVG\": (args,context) => {\r\n        const {value:vs} = context.functions._RANKG(args,context);\r\n        if(!vs.length) {\r\n            return {type: ERROR, value: NAVALUE , meta: {error: \"RANK.AVG search value was not found in ref\"}}\r\n        }\r\n        return context.functions.AVERAGE(vs,context);\r\n    },\r\n    \"RANK.EQ\": (args,context) => {\r\n        const {value:[r]} = context.functions._RANKG(args,context);\r\n        if(!r) {\r\n            return {type: ERROR, value: NAVALUE , meta: {error: \"RANK.AVG search value was not found in ref\"}}\r\n        }\r\n        return r;\r\n    },\r\n    RANK: (args,context) => context.functions[\"RANK.EQ\"](args,context),\r\n    RATE: ([{value}]) => ({ type: NULL, value }), // todo: use fin-lib\r\n    RECEIVED: ([{value}]) => ({ type: NULL, value }), // todo: use fin-lib\r\n    \"REGISTER.ID\": ([{value}]) => ({ type: NULL, value }), // todo allow dynamic loading of functions into scope\r\n    REPLACE: ([{value:text},{value:startn},{value:numch},{value:newtext}]) => {\r\n        const r = text.substring(0,startn-1) + newtext + text.substring(startn+numch-1);\r\n        return { type: STRING, value: r };\r\n    },\r\n    REPLACEB: ([text,startnum,bytes,{value:newtext}],context) => {\r\n        const {value:search} = context.functions.LEFTB([text,bytes],context);\r\n        const r = text.value.replace(search,newtext);\r\n        return { type: STRING, value: r, meta: { search } };\r\n    },\r\n    REPT: ([{value:t},{value:n}]) => ({ type: STRING, value: Array.from({length:n}).fill(t).join(\"\") }),\r\n    RIGHT: ([{value:text},{value:num_chars}={value:1}]) =>\r\n        ({ type: STRING, value: text.slice(-num_chars) }),\r\n    RIGHTB: ([{value:str},{value:lengthInBytes}={value:1}]) => {\r\n        // idea from https://stackoverflow.com/questions/11200451/extract-substring-by-utf-8-byte-positions\r\n        const encode_utf8 = s => unescape(encodeURIComponent(s));\r\n        let resultStr = '', bytePos = 0, end = lengthInBytes - 1;\r\n        for (let n = 0; 0 <= end; n++) {\r\n          const ch = str.charCodeAt(str.length-n-1);\r\n          end -= (ch < 128) ? 1 : encode_utf8(str[str.length-n-1]).length;\r\n          resultStr = str[str.length-n-1] + resultStr;\r\n        }\r\n        return { type: STRING, value: resultStr };\r\n    },\r\n    ROMAN: ([{value:arabic},{value:mode}={value:0}]) => {\r\n        \r\n        const modes = romannumeralmodes;\r\n        // algo idea from https://www.baeldung.com/java-convert-roman-arabic\r\n        const romanNumerals = Object.entries(modes.get(mode)).sort(([__,a],[___,b]) => b-a); // get a sorted version\r\n        let i = 0;\r\n        let sb = \"\"\r\n        while ((arabic > 0) && (i < romanNumerals.length)) {\r\n            const [roman,value] = romanNumerals[i];\r\n            if (value <= arabic) {\r\n                sb += roman;\r\n                arabic -= value;\r\n            } else {\r\n                i++;\r\n            }\r\n        }\r\n        return { type: STRING, value: sb };\r\n    },\r\n    ROW: ([{value,type,meta={}}={}], ctx) => {\r\n        if(!value) {\r\n            return { type: NUMBER, value: ctx.currentcell.row+1 };\r\n        }\r\n        if(meta.type === CELL) {\r\n            return { type: NUMBER, value: meta.row };\r\n        }\r\n        throw new Error(\"ROW's first argumnet must be a cell-reference (meta.type=CELL)! Found \"+String(value)+\" (\"+String(type)+\"/\"+String(meta.type)+\")\"); // excel actually throws\r\n    },\r\n    ROWS: ([{value,type}]) => {\r\n        if(type === LIST) {\r\n            const {meta: {type:st,row:sc}={}} = value[0];\r\n            const {meta: {type:lt,row:lc}={}} = value[value.length-1];\r\n            if(st === CELL && lt === CELL) {\r\n                return { type: NUMBER, value: lc-sc+1 }\r\n            }\r\n            // case of inline list via {...}-Syntax\r\n            return { type: NUMBER, value: value.length };\r\n        }\r\n        if(type === MATRIX) {\r\n            return { type: NUMBER, value: value.length };\r\n        }\r\n        throw new Error(\"ROWS must be called with LIST or MATRIX. Found \"+String(value)+\" (\"+String(type)+\")\");\r\n    },\r\n    RRI: ([{value:nper},{value:pv},{value:fv}]) => {\r\n        const r = (fv/pv) ** (1/nper) - 1;\r\n        return { type: NUMBER, value: r };\r\n    },\r\n    RSQ: (args,context) => {\r\n        const a = context.functions.PEARSON(args,context);\r\n        const {value,type,...rest} = a;\r\n        return type === NUMBER ? {...a, value: value*value} : a;\r\n    },\r\n    RTD: ([{value:progID},{value:server},...topics]) => ({ type: NULL, value: \"Not implemented\" }),\r\n    SEARCH: ([{value:find_text},{value:within_text},{value:start_num}={value:0}],context) => {\r\n        const reg = context.functions._TOSEARCHSTRING([find_text,false,false],context);\r\n        const idx = within_text.substring(start_num).search(reg);\r\n        return { type: NUMBER, value: idx+1+start_num, meta: { reg } };\r\n    },\r\n    SEARCHB: ([{value:find_text},{value:within_text},{value:start_num}={}],context) => {\r\n        const reg = context.functions._TOSEARCHSTRING([find_text,false,false],context);\r\n        const idx = within_text.substring(start_num).search(reg) + 1;\r\n        const r = (new TextEncoder().encode(within_text.substring(0,idx))).length;\r\n        return { type: NUMBER, value: r };\r\n    },\r\n    SEC: ([{value}]) => ({ type: NUMBER, value: 1/ Math.cos(value) }),\r\n    SECH: ([{value}]) => ({ type: NUMBER, value: 1/ Math.cosh(value) }),\r\n    // rows,[columns],[start],[step]\r\n    SEQUENCE: ([{value:rows},{value:columns}={value:1},{value:start}={value:1},{value:step}={value:1}]) => {\r\n        const f = n => ({ type: NUMBER, value: start+n*step });\r\n        if(rows===1 && columns===1) {\r\n            return f(0);\r\n        }\r\n        if(rows===1 || columns===1) {\r\n            return { type: LIST, value: Array.from({ length: Math.max(rows,columns) }).map((__,idx) => f(idx)), rowspan: rows, colspan: columns };\r\n        }\r\n        return { type: MATRIX, value: Array.from({ length: rows })\r\n            .map((___,jdx) => Array.from({ length: columns }).map((__,idx) => f(idx*jdx))), rowspan: rows, colspan: columns };\r\n    },\r\n    SERIESSUM: ([{value:x},{value:n},{value:m},{value:a}],context) => {\r\n        // i = 0..a.length\r\n        // SUM( a[i] * x**(n+(i-1)*m) )\r\n        const r = a.map(({value:v},idx) => v*x**(n+idx*m)).reduce((p,i) => p+i,0);\r\n        return { type: NUMBER, value: r };\r\n    },\r\n    SHEET: () => ({ type: NUMBER, value: -1, meta: { error: \"Sheets are not numbered\" } }),\r\n    SHEETS: () => ({ type: NUMBER, value: -1, meta: { error: \"Sheets are not enumerable and can only be discovered\" } }),\r\n    SIGN: ([{value}]) => ({ type: NUMBER, value: Math.sign(value) }),\r\n    SIN: ([{value}]) => ({ type: NUMBER, value: Math.sin(value) }),\r\n    SINH: ([{value}]) => ({ type: NUMBER, value: Math.sinh(value) }),\r\n    _SKEW: (allargs,context,xbar,s) => {\r\n        // n / ((n-1)*(n-2)) * SUM(  ( (x[i]-xbar)/s )**3  )\r\n        const [sum,count] = allargs.reduce(([sum,count], { value, type }) => {\r\n          switch(type) {\r\n              case NULL:\r\n            case BOOLEAN:\r\n            case STRING:\r\n            case ERROR:\r\n                return [sum,count];\r\n            case NUMBER:\r\n                const t = ((value-xbar)/s)**3;\r\n                return [sum+t,count+1];\r\n            case LIST:\r\n                const { sum: ms, count: mc } = context.functions._SKEW(value, context, xbar, s).meta;\r\n                return [sum+ms, count + mc];\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in _SKEW\");\r\n          }\r\n      }, [0,0]);\r\n      if(count < 3) {\r\n          return { type: ERROR, value: DIV0, meta: { sum, count } };\r\n      }\r\n      const ft = count/(count-1)/(count-2);\r\n      return { type: NUMBER, value: ft * sum, meta: { sum, count } };\r\n    },\r\n    _SKEWP: (allargs,context,xbar,s) => {\r\n        // (1/n) * sum(  (x[i]-(xbar**3))/s  )\r\n        const [sum,count] = allargs.reduce(([sum,count], { value, type }) => {\r\n          switch(type) {\r\n              case NULL:\r\n            case BOOLEAN:\r\n            case STRING:\r\n            case ERROR:\r\n                return [sum,count];\r\n            case NUMBER:\r\n                const t = ((value-xbar)/s)**3;\r\n                return [sum+t,count+1];\r\n            case LIST:\r\n                const { sum: ms, count: mc } = context.functions._SKEWP(value, context, xbar, s).meta;\r\n                return [sum+ms, count + mc];\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in _SKEW\");\r\n          }\r\n      }, [0,0]);\r\n      return { type: NUMBER, value: sum / count, meta: { sum, count } };\r\n    },\r\n    SKEW: (allargs,context) => {\r\n        const {value:xbar} = context.functions.AVERAGE(allargs, context);\r\n        const { result, ccount } = context.functions._STDEV(allargs, context, xbar).meta;\r\n        const s = Math.sqrt(result/(ccount-1));\r\n        return context.functions._SKEW(allargs, context,xbar,s);;\r\n    },\r\n    \"SKEW.P\": (allargs,context) => {\r\n        // // (1/n) * sum(  (x[i]-xbar)**3/s  )\r\n        const {value:xbar} = context.functions.AVERAGE(allargs, context);\r\n        const { result, ccount } = context.functions._STDEV(allargs, context, xbar).meta;\r\n        const s = Math.sqrt(result/ccount);\r\n        return context.functions._SKEWP(allargs, context,xbar,s);\r\n    },\r\n    SLN: ([{value:cost},{value:salvage},{value:life}]) => ({ type: NUMBER, value: (cost-salvage)/life }),\r\n    _SLOPE: ([{value:y},{value:x}],context,xbar,ybar) => {\r\n        // sum( (x-xbar)*(y-ybar) ) / sum( (x-xbar)**2 )\r\n        const [s1,s2] = x.reduce(([s1,s2], __, idx) => {\r\n            const { value:xv, type:xt } = x[idx];\r\n            const { value:yv, type:yt } = y[idx];\r\n          switch(xt === yt ? xt : false) {\r\n              case NULL:\r\n            case BOOLEAN:\r\n            case STRING:\r\n            case ERROR:\r\n                return [sum,count];\r\n            case NUMBER:\r\n                const a0 = (xv-xbar)*(yv-ybar);\r\n                const b0 = (xv-xbar)*(xv-xbar);\r\n                return [s1+a0,s2+b0];\r\n            case LIST:\r\n                const { s1:a,s2:b } = context.functions._SLOPE([xv,yv], context, xbar,ybar).meta;\r\n                return [s1+a,s2+b];\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(xv)+\" of type \"+String(xt)+\" found in SLOPE\");\r\n          }\r\n          }, [0,0]);\r\n        return { type: NUMBER, value: s1/s2, meta: { s1,s2 } };\r\n    },\r\n    SLOPE: (args,context) => {\r\n        // sum( (x-xbar)*(y-ybar) ) / sum( (x-xbar)**2 )\r\n        const [{value:y},{value:x}] = args;\r\n        const {value:ybar} = context.functions.AVERAGE(y, context);\r\n        const {value:xbar} = context.functions.AVERAGE(x, context);\r\n        return context.functions._SLOPE(args,context,xbar,ybar);\r\n    },\r\n    SORT: ([{value:arr,type,...rest},{value:sortidx}={value:1},{value:order}={value:1},{value:bycol}={value:false}],context) => {\r\n        // array -> type === LIST|MATRIX\r\n        // [sortidx] -> row or col to sort by\r\n        // [order] -> 1=default=asc | -1=des\r\n        // [bycol] -> false=default=by row=top2bottom\r\n        // ....\r\n        if(type === LIST) {\r\n            arr = [arr];\r\n        }\r\n        if(!bycol) {\r\n            const sortby = arr[sortidx-1];\r\n            if(sortidx>arr.length) {\r\n                return { type: ERROR, value: \"Invalid sort_index encountered in SORT - the given MATRIX does not have such column\" };\r\n            }\r\n            const sorted = arr.map(i => i\r\n                .map((i,idx) => ({...i,meta: Object.assign(i.meta||{},{oidx:idx})}))\r\n                .sort(({meta:{oidx:a}},{meta:{oidx:b}}) => {\r\n                    return order * (sortby[a].value - sortby[b].value);\r\n                })\r\n            );\r\n            if(type === LIST) {\r\n                return Object.assign(rest,{type,value:sorted[0]})\r\n            }\r\n            return Object.assign(rest,{type,value:sorted});\r\n        } \r\n        if(arr.some(i => i.length < sortidx)) {\r\n          return { type: ERROR, value: \"Invalid sort_index encountered in SORT - the given MATRIX does not have such column\" };\r\n        }\r\n        const transposed = arr[0].map((col, idx) => arr.map(row => row[idx]));\r\n        const sortby = transposed[sortidx-1];\r\n\r\n        const sorted = transposed.map(i => i\r\n        .map((i,idx) => ({...i,meta: Object.assign(i.meta||{},{oidx:idx})}))\r\n        .sort(({meta:{oidx:a}},{meta:{oidx:b}}) => {\r\n        return order * (sortby[a].value - sortby[b].value);\r\n        })\r\n        );\r\n        const back = sorted[0].map((col, idx) => sorted.map(row => row[idx]));\r\n        if(type === LIST) {\r\n            return Object.assign(rest,{type,value:back.map(i => i[0])});\r\n        }\r\n        return Object.assign(rest,{type,value:back});\r\n    },\r\n    SORTBY: ([{value:arr,type,...rest},...criteria]) => {\r\n        const sortby = criteria.map(({value:v}) => v).filter((__,idx) => !(idx%2));\r\n        if(type !== LIST) {\r\n            return {type: ERROR, value: \"SORTBY expected a LIST, but found \"+String(arr)+\" (\"+String(type)+\")\"};\r\n        }\r\n        if(sortby.length < 1) {\r\n            return { type: ERROR, value: \"SORTBY requires at least 1 criterium\" };\r\n        }\r\n        const sorted = arr\r\n        .map((i,idx) => ({...i,meta: Object.assign(i.meta||{},{oidx:idx})}))\r\n        .sort(({meta:{oidx:a}},{meta:{oidx:b}}) => {\r\n            for(let idx = 0; idx < sortby.length; idx++) {\r\n                const criterium = sortby[idx];\r\n                const order = criteria[idx*2+1] ? criteria[idx+1].value : 1;\r\n                const xy = order * (criterium[a].value - criterium[b].value)\r\n                if(xy) { // if not a tie (xy=0)\r\n                    return xy; // return order\r\n                }\r\n                // else go to next criterium\r\n            }\r\n            return 0;\r\n        });\r\n         return Object.assign(rest,{type,value:sorted});\r\n    },\r\n    SQRT: ([{value}]) => value >=0 ? { type: NUMBER, value: Math.sqrt(value) } : { type: ERROR, value: NUMVALUE  },\r\n    SQRTPI: ([{value}]) => value >=0 ? { type: NUMBER, value: Math.sqrt(value*Math.PI) } : { type: ERROR, value: NUMVALUE  },\r\n    STANDARDIZE: ([{value:x},{value:mean},{value:s}]) => s >=0 ? { type: NUMBER, value: (x-mean)/s } : { type: ERROR, value: NUMVALUE, meta: { error: \"STANDARDIZE's Standard_dev must be >= 0\" } },\r\n    _STDEV: (allargs, context, xbar) => {\r\n        // todo: unclear when values are ignored vs when they throw vs when they count\r\n      const [result,ccount] = allargs.reduce(([sum,count], { value, type }) => {\r\n          switch(type) {\r\n              case NULL:\r\n            case BOOLEAN:\r\n            case STRING:\r\n            case ERROR:\r\n                return [sum, count];\r\n            case NUMBER:\r\n                return [sum + (value-xbar)*(value-xbar),count+1];\r\n            case LIST:\r\n                const { result, ccount } = context.functions._STDEV(value, context, xbar).meta;\r\n                return [sum+result, count+ccount ];\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in AVERAGE\");\r\n          }\r\n      }, [0,0]);\r\n      return { type: NUMBER, value: result/ccount, meta: { result, ccount } };\r\n    },\r\n    _STDEVA: (allargs, context, xbar) => {\r\n        // todo: unclear when values are ignored vs when they throw vs when they count\r\n      const [result,ccount] = allargs.reduce(([sum,count], { value, type }) => {\r\n          switch(type) {\r\n              case NULL:\r\n            case ERROR:\r\n                return [sum, count];\r\n            case BOOLEAN:\r\n                return [sum+(+value), count+1]\r\n            case STRING:\r\n                const v2 = parseFloat(value);\r\n                if(Number.isNaN(v2)) {\r\n                    throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in _STDEVA\");\r\n                }\r\n                return [sum + v2, count+1]; \r\n            case NUMBER:\r\n                return [sum + (value-xbar)*(value-xbar),count+1];\r\n            case LIST:\r\n                const { result, ccount } = context.functions._STDEVA(value, context, xbar).meta;\r\n                return [sum+result, count+ccount ];\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in _STDEVA\");\r\n          }\r\n      }, [0,0]);\r\n      return { type: NUMBER, value: result/ccount, meta: { result, ccount } };\r\n    },\r\n    STDEV: (allargs, context) => {\r\n        const {value:xbar} = context.functions.AVERAGE(allargs, context)\r\n        const { result, ccount } = context.functions._STDEV(allargs, context, xbar).meta;\r\n        return { type: NUMBER, value: Math.sqrt(result/(ccount-1)), meta: { result, ccount } };\r\n    },\r\n    \"STDEV.P\": (allargs, context) => context.functions.STDEVP(allargs, context),\r\n    \"STDEV.S\": (allargs, context) => context.functions.STDEV(allargs, context),\r\n    STDEVA: (allargs, context) => {\r\n        const {value:xbar} = context.functions.AVERAGE(allargs, context)\r\n        const { result, ccount } = context.functions._STDEVA(allargs, context, xbar).meta;\r\n        return { type: NUMBER, value: Math.sqrt(result/(ccount-1)), meta: { result, ccount } };\r\n    },\r\n    STDEVP: (allargs, context) => {\r\n        const {value:xbar} = context.functions.AVERAGE(allargs, context)\r\n        const { result, ccount } = context.functions._STDEV(allargs, context, xbar).meta;\r\n        return { type: NUMBER, value: Math.sqrt(result/ccount), meta: { result, ccount } };\r\n    },\r\n    STDEVPA: (allargs, context) => {\r\n        const {value:xbar} = context.functions.AVERAGE(allargs, context)\r\n        const { result, ccount } = context.functions._STDEVA(allargs, context, xbar).meta;\r\n        return { type: NUMBER, value: Math.sqrt(result/ccount), meta: { result, ccount } };\r\n    },\r\n    _STEYX: ([{value:y},{value:x}],context,xbar,ybar) => {\r\n        // sum( (x-xbar)*(y-ybar) ) / sum( (x-xbar)**2 )\r\n        const [s1,s2,s3,count] = x.reduce(([s1,s2,s3,count], __, idx) => {\r\n            const { value:xv, type:xt } = x[idx];\r\n            const { value:yv, type:yt } = y[idx];\r\n          switch(xt === yt ? xt : false) {\r\n              case NULL:\r\n            case BOOLEAN:\r\n            case STRING:\r\n            case ERROR:\r\n                return [s1,s2,s3,count];\r\n            case NUMBER:\r\n                const a0 = (xv-xbar)*(yv-ybar);\r\n                const b0 = (xv-xbar)*(xv-xbar);\r\n                const c0 = (yv-ybar)*(yv-ybar);\r\n                return [s1+a0,s2+b0,s3+c0,count+1];\r\n            case LIST:\r\n                const { s1:a,s2:b, s3: c, count:u } = context.functions._STEYX([xv,yv], context, xbar,ybar).meta;\r\n                return [s1+a,s2+b,s3+c,count+u];\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(xv)+\" of type \"+String(xt)+\" found in _STEYX\");\r\n          }\r\n          }, [0,0,0,0]);\r\n        const value = Math.sqrt(  1/(count-2) * (  s3 - s1*s1/s2  )  );\r\n        return { type: NUMBER, value, meta: { s1,s2, s3, count } };\r\n    },\r\n    STEYX: (args,context) => {\r\n        // sum( (x-xbar)*(y-ybar) ) / sum( (x-xbar)**2 )\r\n        const [{value:y},{value:x}] = args;\r\n        const {value:ybar} = context.functions.AVERAGE(y, context);\r\n        const {value:xbar} = context.functions.AVERAGE(x, context);\r\n       return context.functions._STEYX(args,context,xbar,ybar);\r\n    },\r\n    _FILTERTYPE: (allargs, context, ...types) => {\r\n        const [{ key, recurse = [LIST], ignore = [], error = [], allow = [], subelement = (({value:v}) => v), subelementreverse = ((value,t) => ({...t,value})) }, ...ttypes] = types;\r\n        const result = allargs.filter(t => {\r\n            const type = key(t);\r\n            if(allow.indexOf(type) > -1) return true;\r\n            if(ignore.indexOf(type) > -1) return false;\r\n\r\n            if(error.indexOf(type) > -1) {\r\n              const e = new Error(\"Disallowed type \"+String(type)+\" found in _FILTERTYPE\");\r\n              e.object = t;\r\n            }\r\n\r\n            if(recurse.indexOf(type) > -1) {\r\n                return true; // we filter these by stuff inside the value\r\n            }\r\n            return allow.length === 0; // if there is a whitelist, all other values are disallowed by default\r\n        }).map(t => {\r\n            const type = key(t);\r\n            if(recurse.indexOf(type) > -1) {\r\n                return subelementreverse(context.functions._FILTERTYPE(subelement(t), context, ...types),t);\r\n            }\r\n            return t;\r\n        });\r\n        if(ttypes.length > 0) {\r\n            return context.functions._FILTERTYPE(result, context, ...ttypes);\r\n        }\r\n          return result;\r\n    },\r\n    SUBTOTAL: ([{value:mode},...args],context) => {\r\n        const xmode = \"\"+mode;\r\n        const mapping = {\r\n          \"1\": context.functions.AVERAGE,\r\n          \"2\": context.functions.COUNT,\r\n          \"3\": context.functions.COUNTA,\r\n          \"4\": context.functions.MAX,\r\n          \"5\": context.functions.MIN,\r\n          \"6\": context.functions.PRODUCT,\r\n          \"7\": context.functions.STDEV,\r\n          \"8\": context.functions.STDEVP,\r\n          \"9\": context.functions.SUM,\r\n          \"10\": context.functions.VAR,\r\n          \"11\": context.functions.VARP,\r\n          \"101\": context.functions.AVERAGE,\r\n          \"102\": context.functions.COUNT,\r\n          \"103\": context.functions.COUNTA,\r\n          \"104\": context.functions.MAX,\r\n          \"105\": context.functions.MIN,\r\n          \"106\": context.functions.PRODUCT,\r\n          \"107\": context.functions.STDEV,\r\n          \"108\": context.functions.STDEVP,\r\n          \"109\": context.functions.SUM,\r\n          \"110\": context.functions.VAR,\r\n          \"111\": context.functions.VARP\r\n        };\r\n        if(!mapping[xmode]) {\r\n            return { type: ERROR, value: \"UNexpected value for mode '\"+String(xmode)+\"' found in SUBTOTAL\" };\r\n        }\r\n        const filters = [{\r\n            key: ({type}) => type,\r\n            ignore: [NULL]\r\n        }, {\r\n            key: ({meta:{type}={}}) => type,\r\n            ignore: [SUBTOTAL]\r\n        }];\r\n        if(xmode.startsWith(\"10\")) {\r\n            // ignore hidden\r\n            filters.push({\r\n              key: ({meta:{visibility:type}={}}) => type,\r\n              ignore: [HIDDEN]\r\n          });\r\n        }\r\n        const filtered = context.functions._FILTERTYPE(args, context, ...filters)\r\n        const {meta={},...rest} = mapping[xmode](filtered,context);\r\n        return Object.assign(rest,{meta:{...meta,type:SUBTOTAL}});\r\n    },\r\n    SUMIF: ([{value:range,type:t1},{value:criteria,type},{value:xsumrange}={}], context) => {\r\n        if(t1 !== LIST) {\r\n          throw new Error(\"SUMIF must be supplied a LIST, found value \"+value+\" of type \"+t1);\r\n        }\r\n        const f = context.functions._CRITMATCHER([{value:criteria,type}], context);\r\n        const sumrange = xsumrange || range;\r\n        const filterd = sumrange.filter((__,idx) => f(range[idx]));\r\n        const {meta={},...rest} = context.functions.SUM(filterd,context);\r\n        return Object.assign(rest,{meta:{...meta,matches:filterd}});\r\n    },\r\n    SUMIFS: ([{value:sumrange},...args], context) => {\r\n        if(args.length < 2) {\r\n            throw new Error(\"Excepted 'criteria_range1, criteria1', but found \"+(args.length?\"'criteria_range1'\":\"no arguments\"));\r\n        }\r\n        if(args.length % 2) { // if 1\r\n            throw new Error(\"Wrong number of arguments, excepted 'criteria_range1, criteria1, [criteria_range2, criteria2]...', but found \"+\r\n            args.map((i, idx) => idx%2?\"criteria\"+Math.ceil((idx+1)/2):\"criteria_range\"+Math.ceil((idx+1)/2)).join(\", \"));\r\n        }\r\n        const [ranges, criteria] = args.reduce(([l1,l2],arg,idx) => \r\n            idx%2?[l1,[...l2, arg]]:[[...l1, arg], l2], // sort into 2 lists, so that [a,1,b,2,c,3]->[[a,b,c],[1,2,3]]\r\n        [[],[]]);\r\n        if(ranges.some(({value:i}) => i.length !== sumrange.length)) {\r\n            throw new Error(\"All defined ranges must have the same length (\"+ranges[0].value.length+\") as it's sumrange (\"+sumrange.length+\")\");\r\n        }\r\n        \r\n        const cfunctions = criteria.map(({value:criterium,type}) => {\r\n          return context.functions._CRITMATCHER([{value:criterium,type}], context);\r\n        });\r\n        const filtered = sumrange\r\n            .filter((s, idx) => \r\n                ranges\r\n                .every(({value:v},jdx) => cfunctions[jdx](v[idx]))\r\n            );\r\n        const {meta={},...rest} = context.functions.SUM(filtered,context);\r\n        return Object.assign(rest,{meta:{...meta,matches:filtered}});\r\n    },\r\n    SUMSQ: (allargs, context) => {\r\n      const result = allargs.reduce((sum, { value, type }) => {\r\n          switch(type) {\r\n              case NULL:\r\n                return sum;\r\n            case NUMBER:\r\n              return sum + value*value;\r\n            case LIST:\r\n              const {value:s} = context.functions.SUM(value, context);\r\n              return sum+s;\r\n            default:\r\n              throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in SUM\");\r\n          }\r\n      }, 0);\r\n      return { type: NUMBER, value: result };\r\n    },\r\n    SUMX2MY2: ([{value:x},{value:y}],context) => {\r\n        const r = x.reduce((p, __, idx) => {\r\n            const { value:xv, type:xt } = x[idx];\r\n            const { value:yv, type:yt } = y[idx];\r\n          switch(xt === yt ? xt : false) {\r\n              case NULL:\r\n            case BOOLEAN:\r\n            case STRING:\r\n            case ERROR:\r\n                return p;\r\n            case NUMBER:\r\n                return p + (xv*xv-yv*yv);\r\n            case LIST:\r\n                const { value } = context.functions.SUMX2MY2([xv,yv], context);\r\n                return p+value;\r\n            default:\r\n              throw new Error(\"Disallowed value \"+xv+\" of type \"+xt+\" found in SUMX2MY2\");\r\n          }\r\n          }, 0);\r\n        return { type: NUMBER, value: r };\r\n    },\r\n    SUMX2PY2: ([{value:x},{value:y}],context) => {\r\n        const r = x.reduce((p, __, idx) => {\r\n            const { value:xv, type:xt } = x[idx];\r\n            const { value:yv, type:yt } = y[idx];\r\n          switch(xt === yt ? xt : false) {\r\n              case NULL:\r\n            case BOOLEAN:\r\n            case STRING:\r\n            case ERROR:\r\n                return p;\r\n            case NUMBER:\r\n                return p + (xv*xv+yv*yv);\r\n            case LIST:\r\n                const { value } = context.functions.SUMX2PY2([xv,yv], context);\r\n                return p+value;\r\n            default:\r\n              throw new Error(\"Disallowed value \"+xv+\" of type \"+xt+\" found in SUMX2PY2\");\r\n          }\r\n          }, 0);\r\n        return { type: NUMBER, value: r };\r\n    },\r\n    SUMXMY2: ([{value:x},{value:y}],context) => {\r\n        const r = x.reduce((p, __, idx) => {\r\n            const { value:xv, type:xt } = x[idx];\r\n            const { value:yv, type:yt } = y[idx];\r\n          switch(xt === yt ? xt : false) {\r\n              case NULL:\r\n            case BOOLEAN:\r\n            case STRING:\r\n            case ERROR:\r\n                return p;\r\n            case NUMBER:\r\n                return p + (xv-yv)*(xv-yv);\r\n            case LIST:\r\n                const { value } = context.functions.SUMX2PY2([xv,yv], context);\r\n                return p+value;\r\n            default:\r\n              throw new Error(\"Disallowed value \"+xv+\" of type \"+xt+\" found in SUMX2PY2\");\r\n          }\r\n          }, 0);\r\n        return { type: NUMBER, value: r };\r\n    },\r\n    SWITCH: ([{value:sswitch},...args]) => {\r\n        let elsev = undefined;\r\n        if(args.length % 2) {\r\n            elsev = {...args.pop()};\r\n        }\r\n        const [ranges, criteria] = args.reduce(([l1,l2],arg,idx) => \r\n            idx%2?[l1,[...l2, arg]]:[[...l1, arg], l2], // sort into 2 lists, so that [a,1,b,2,c,3]->[[a,b,c],[1,2,3]]\r\n        [[],[]]);\r\n        const idx = ranges.findIndex(({value:v}) => sswitch === v || sswitch.valueOf() === v.valueOf());\r\n        return criteria[idx] ? {...criteria[idx]} : (elsev || { type: ERROR, value: NAVALUE });\r\n    },\r\n    // cost, salvage, life, per\r\n    SYD: ([{value:cost},{value:salvage},{value:life},{value:per}]) => {\r\n        // (cost-salvage)*(life-per+1)*2   /   life*(life+1)\r\n        return { type: NUMBER, value: (cost-salvage)*(life-per+1)*2 / (life*(life+1)) }\r\n    },\r\n    T: ([{value,type}]) => ({ type: STRING, value: type === STRING ? value : \"\" }),\r\n    TAN: ([{value}]) => ({ type: NUMBER, value: Math.tan(value) }),\r\n    TANH: ([{value}]) => ({ type: NUMBER, value: Math.tanh(value) }),\r\n    TBILLEQ: ([{value}]) => ({ type: NULL, value }), // todo either figure out or use fin lib\r\n    TBILLPRICE: ([{value}]) => ({ type: NULL, value }), // see above - need to figure out / re-use 360 year calc\r\n    TBILLYIELD: ([{value}]) => ({ type: NULL, value }), // see above\r\n    \"T.DIST\": ([{value}]) => ({ type: NULL, value }), // todo use math lib\r\n    \"T.DIST.2T\": ([{value}]) => ({ type: NULL, value }), // todo use math lib\r\n    \"T.DIST.RT\": ([{value}]) => ({ type: NULL, value }), // todo use math lib\r\n    TDIST: ([{value}]) => ({ type: NULL, value }), // todo use math lib\r\n    TEXT: ([{value},{value:format}]) => {\r\n        // well.... we might just need another parser to parse all the format options\r\n        // positive;negative;zero;text\r\n        // Strings need to be in quotes\r\n        // Characters not in quotes:\r\n        // [\"$\", \"+\", \"-\", \"/\", \"(\", \")\", \":\", \"!\", \"^\", \"&\", \"'\", \"~\", \"{\", \"}\", \"<\", \">\", \"=\", \" \"]\r\n        // # = N || \"\"\r\n        // 0 = N || \"0\"\r\n        // ? = N || \" \"\r\n        // @ = Text\r\n        // color: [Black] [Blue] [Cyan] [Green] [Magenta] [Red] [White] [Yellow]\r\n        // conditions: [Blue][<=100]\r\n        // % = N*100%\r\n        // / = fraction\r\n        // (E– | E+ | e– | e+) (0 | #) = scientific notation\r\n        // date and time -> https://support.office.com/en-us/article/number-format-codes-5026bbd6-04bc-48cd-bf33-80f18b4eae68\r\n        // 0#,0# = 1000 seperator\r\n        // 0#,$ = N / 1000\r\n        // todo\r\n    },\r\n    TEXTJOIN: ([{value:delimiter},{value:ignore_empty},...allargs],context) => {\r\n        //delimiter, ignore_empty, text1, [text2]\r\n        const result = allargs.reduce((sum, { value, type }) => {\r\n          if(ignore_empty && (value === \"\" || value == null)) {\r\n              return sum;\r\n          }\r\n          switch(type) {\r\n            case NULL:\r\n            case NUMBER:\r\n            case STRING:\r\n            case BOOLEAN:\r\n                console.log(\"!\",sum,value);\r\n                return [...sum,value];\r\n            case LIST:\r\n                console.log(\"!\",sum,value);\r\n                const {list:s} = context.functions.TEXTJOIN([{value:delimiter},{value:ignore_empty},...value], context).meta;\r\n                return [...sum,...s];\r\n            default:\r\n                throw new Error(\"Disallowed value \"+String(value)+\" of type \"+String(type)+\" found in TEXTJOIN\");\r\n         }\r\n        }, []);\r\n      return { type: STRING, value: result.join(delimiter), meta: { list: result } };\r\n    },\r\n    \"T.INV\": ([{value}]) => ({ type: NULL, value }), // todo: Use math lib\r\n    \"T.INV.2T\": ([{value}]) => ({ type: NULL, value }), // todo: Use math lib\r\n    TINV: ([{value}]) => ({ type: NULL, value }), // todo: Use math lib\r\n    TREND: ([{value:y},{value:x},{value:new_x},{value:bis0}={value:false}],context) => {\r\n        // sum( (x-xbar)*(y-ybar) ) / sum( (x-xbar)**2 )\r\n        if(!x) {\r\n            x = y.map((__,idx) => ({type:NUMBER,value:idx+1}));\r\n        }\r\n        if(!new_x) {\r\n            new_x = x;\r\n        }\r\n        const {value:ybar} = context.functions.AVERAGE(y, context);\r\n        const {value:xbar} = context.functions.AVERAGE(x, context);\r\n        const { value: m } = context.functions._SLOPE([{value:y},{value:x}],context,xbar,ybar);\r\n        const b = bis0 ? 0 : ybar - m * xbar;\r\n        const result = new_x.map(({value,...r}) => ({\r\n            ...r,\r\n            value: value*m + b\r\n        }));\r\n        return { type: new_x.type, value: result, meta: { m, b } };\r\n    },\r\n    TRIMMEAN: ([{value:arr},{value:perc}],context) => {\r\n        const excludes = Math.round(arr.length * perc / 2);\r\n        const narr = arr.sort(({value:a},{value:b}) => b-a).slice(excludes, -excludes);\r\n        console.log(arr.length,perc,arr.length * perc, excludes,narr);\r\n        return context.functions.AVERAGE(narr,context);\r\n    },\r\n    TRUE: () => ({ type: BOOLEAN, value: true }),\r\n    \"T.TEST\": ([{value}]) => ({ type: NULL, value }),// todo: USe math-lib\r\n    TTEST: ([{value}]) => ({ type: NULL, value }),// todo: USe math-lib\r\n    TYPE: ([{type}]) => {\r\n        const mapping = {\r\n          NUMBER: 1,\r\n          DATE: 1,\r\n          NULL: 1, // Apperently empty cells are type number....\r\n          STRING: 2,\r\n          BOOLEAN: 4,\r\n          ERROR: 16,\r\n          LIST: 64,\r\n          MATRIX: 64,\r\n          ARGUMENTS: 64\r\n        }\r\n        return {type:NUMBER, value:mapping[type]};\r\n    },\r\n    UNICHAR: ([{value}]) => ({ type: STRING, value: String.fromCharCode(value) }),\r\n    UNICODE: ([{value}]) => ({ type: NUMBER, value: value.charCodeAt(0) }),\r\n    _FILTERUNIQUE: ([arr,exactly_once]) => {\r\n        const rootMap = new Map();\r\n        // filter duplicates\r\n        let filtered = arr.filter(line => {\r\n          let map = rootMap;\r\n          let found = true;\r\n          for(const {value:item} of line) {\r\n            if(!map.has(item)) {\r\n              found = false;\r\n              map2 = new Map();\r\n              map.set(item, map2);\r\n              map = map2\r\n            } else {\r\n                map = map.get(item);\r\n            }\r\n          }\r\n          if(exactly_once) {\r\n            if(map.has(\"line\")) {\r\n              map.get(\"line\").duplicate = true;\t\r\n            }\r\n            else {\r\n              map.set(\"line\",line)\r\n            }\r\n          }\r\n          return !found;\r\n        });\r\n        if(exactly_once) {\r\n            filtered = filtered.filter(i => !i.duplicate);\r\n        }\r\n        return filtered;\r\n    },\r\n    UNIQUE: ([{value:arr,type,...rest},{value:bycol}={value:false},{value:exactly_once}={value:false}],context) => {\r\n        if(type === LIST) {\r\n            arr = [arr];\r\n        }\r\n        // Note: LIST type hasn't got a reliable way of checking direction\r\n        // Code hence assumes, list is {1,2,3}, even when it actually was {1;2;3}\r\n        if(bycol) {\r\n            const filtered = context.functions._FILTERUNIQUE([arr,exactly_once]);\r\n            if(type === LIST) {\r\n                return Object.assign(rest,{type,value:filtered[0]})\r\n            }\r\n            return Object.assign(rest,{type,value:filtered});\r\n        }\r\n        const transposed = arr[0].map((col, idx) => arr.map(row => row[idx]));\r\n        const filtered = context.functions._FILTERUNIQUE([transposed,exactly_once]);\r\n        const back = filtered[0].map((col, idx) => filtered.map(row => row[idx]));\r\n        if(type === LIST) {\r\n            return Object.assign(rest,{type,value:back[0]});\r\n        }\r\n        return Object.assign(rest,{type,value:back});\r\n    },\r\n    VAR: (allargs, context) => {\r\n        const {value:xbar} = context.functions.AVERAGE(allargs, context)\r\n        const { result, ccount } = context.functions._STDEV(allargs, context, xbar).meta;\r\n        return { type: NUMBER, value: result/(ccount-1), meta: { result, ccount } };\r\n    },\r\n    \"VAR.P\": (allargs, context) => context.functions.VARP(allargs, context),\r\n    \"VAR.S\": (allargs, context) => context.functions.VAR(allargs, context),\r\n    VARA: (allargs, context) => {\r\n        const {value:xbar} = context.functions.AVERAGE(allargs, context)\r\n        const { result, ccount } = context.functions._STDEVA(allargs, context, xbar).meta;\r\n        return { type: NUMBER, value: result/(ccount-1), meta: { result, ccount } };\r\n    },\r\n    VARP: (allargs, context) => {\r\n        const {value:xbar} = context.functions.AVERAGE(allargs, context)\r\n        const { result, ccount } = context.functions._STDEV(allargs, context, xbar).meta;\r\n        return { type: NUMBER, value: result/ccount, meta: { result, ccount } };\r\n    },\r\n    VARPA: (allargs, context) => {\r\n        const {value:xbar} = context.functions.AVERAGE(allargs, context)\r\n        const { result, ccount } = context.functions._STDEVA(allargs, context, xbar).meta;\r\n        return { type: NUMBER, value: result/ccount, meta: { result, ccount } };\r\n    },\r\n    VDB: ([{value}]) => ({ type: NULL, value }), // todo: Clarify using DDB\r\n    WEBSERVICE: ([{value}]) => {\r\n        // warning: Can all any address!!\r\n        return fetch(value).then(i => i.text()).then(value => ({type:STRING,value}));\r\n    },\r\n    WEIBULL: ([{value}]) => ({ type: NULL, value }), // todo understand / use math lib\r\n    \"WEIBULL.DIST\": ([{value}]) => ({ type: NULL, value }), // todo understand / use math lib\r\n    XIRR: ([{value}]) => ({ type: NULL, value }), // todo, iterative technique, maybe using https://en.wikipedia.org/wiki/Non-linear_least_squares / gauss-newton?\r\n    XLOOKUP: ([lookup,arr,{value:retrunarr},\r\n                ifnotfound={type:ERROR,value:NAVALUE},\r\n                match_mode,\r\n                search_mode], context) => {\r\n        const a = context.functions.XMATCH([lookup,arr,match_mode,search_mode],context);\r\n        const {value:idx,type} = a;\r\n        if(type === ERROR) {\r\n            return ifnotfound;\r\n        }\r\n        let r = retrunarr[idx];\r\n        if(!r || r.length === 0) {\r\n            return ifnotfound;\r\n        }\r\n        return Array.isArray(r) ? { value: r, type: LIST } : r;\r\n           \r\n    },\r\n    XMATCH: ([{value:lookup},{value:arr},\r\n                {value:match_mode}={value:0},\r\n                {value:search_mode}={value:1}], context) => {\r\n        // todo: Implement search modes 2 and -2 (binary serach)\r\n        const searchMethods = {\r\n            \"0\": (arr,lookup) => {\r\n                const xarr = search_mode > 0 ? arr : arr.reverse();\r\n                // .sort(({value:a},{value:b}) => {\r\n                //    return (a-b)*search_mode\r\n                //});\r\n                return xarr.findIndex(({value}) => value===lookup);\r\n            },\r\n            // -1 - Exact match. If none found, return the next smaller item.\r\n            \"-1\": (xarr,lookup) => {\r\n                // for now, we ignore search_mode as it actually doesn't do anything\r\n                const { _GREATER, _SMALLER } = context.functions;\r\n                if(search_mode > 0) {\r\n                  for(let i = 0; i < xarr.length; i++) {\r\n                      if(searchr[i].value === lookup) {\r\n                          return i;\r\n                      }\r\n                      if(_GREATER(searchr[i].value, lookup)) {\r\n                          return i-1;\r\n                      }\r\n                  }\r\n                  return -1;\r\n                }\r\n                for(let i = xarr.length-1; i >= 0; i--) {\r\n                    if(searchr[i].value === lookup) {\r\n                        return i;\r\n                    }\r\n                    if(_SMALLER(searchr[i].value, lookup)) {\r\n                        return i;\r\n                    }\r\n                }\r\n                return -1;\r\n            },\r\n            \"1\": (xarr,lookup) => {\r\n                const { _GREATER, _SMALLER } = context.functions;\r\n                if(search_mode > 0) {\r\n                  for(let i = 0; i < xarr.length; i++) {\r\n                      if(searchr[i].value === lookup) {\r\n                          return i;\r\n                      }\r\n                      if(_GREATER(searchr[i].value, lookup)) {\r\n                          return i;\r\n                      }\r\n                  }\r\n                  return -1;\r\n                }\r\n                for(let i = xarr.length-1; i >= 0; i--) {\r\n                    if(searchr[i].value === lookup) {\r\n                        return i;\r\n                    }\r\n                    if(_SMALLER(searchr[i].value, lookup)) {\r\n                        return i-1;\r\n                    }\r\n                }\r\n                return -1;\r\n            },\r\n            \"2\": (arr,lookup) => {\r\n                const xarr = search_mode > 0 ? arr : arr.reverse();\r\n                const reg = context.functions._TOSEARCHSTRING([\r\n                    lookup\r\n                ], context)\r\n                return xarr.findIndex(({value}) => reg.test(value))\r\n            }\r\n        };\r\n        const idx = searchMethods[match_mode+\"\"](arr,lookup);\r\n        return idx < 0 ? {type:ERROR,value:NAVALUE} : {type:NUMBER, value:idx};\r\n    },\r\n    XNPV: ([{value}]) => ({ type: NULL, value }), // todo use fin lib\r\n    YIELD: ([{value}]) => ({ type: NULL, value }), // todo use fin lib\r\n    YIELDDISC: ([{value}]) => ({ type: NULL, value }), // todo use fin lib\r\n    YIELDMAT: ([{value}]) => ({ type: NULL, value }), // todo use fin lib\r\n    \"Z.TEST\": ([{value}]) => ({ type: NULL, value }), // todo use math lib\r\n    ZTEST: ([{value}]) => ({ type: NULL, value }), // todo use math lib\r\n    \r\n    \r\n    // CUSTOM\r\n    JSON: ([{value}]) => ({ type: ANY, value: JSON.parse(value) }),\r\n    JSONPATH: ([{value,type},{value:path}]) => {\r\n        if(type === STRING) {\r\n            value = JSON.parse(value);\r\n        }\r\n        const pathx = path.replace(/\\[([0-9]*)\\]/g,\".$1\").split(\".\");\r\n        const r = pathx.reduce((p,i) => p[i],value);\r\n        return { type: ANY, value: r, meta: { path: pathx, value } };\r\n    },\r\n}\r\n\r\nexport default functions;","import functionDefinitions from \"./functions\";\nimport {\n  CELL,\n  STR_ESCAPED,\n  STR_PLAIN,\n  AGGREGATE,\n  SUBTOTAL,\n  NUMBER,\n  COMPLEX_NUMBER,\n  LIST,\n  MATRIX,\n  STRING,\n  ANY,\n  BOOLEAN,\n  FUNCTION,\n  ARGUMENTS,\n  NULL,\n  ARRAY,\n  ERROR,\n  DATE,\n  TIME,\n  DATETIME,\n  TRACE,\n  CELL_TRACE,\n  HYPERLINK,\n  NAVALUE,\n  VVALUE,\n  REFVALUE,\n  NUMVALUE,\n  DIV0,\n  NULLE,\n  NAMEE,\n  GETTINGDATA,\n  INLINE,\n  HIDDEN,\n  NATURALREF,\n  CIRCULAR,\n  CC2Currency\n} from \"./types\";\n\nexport default /*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function() {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n          literal: function(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n\n          \"class\": function(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array\n                ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n\n          any: function(expectation) {\n            return \"any character\";\n          },\n\n          end: function(expectation) {\n            return \"end of input\";\n          },\n\n          other: function(expectation) {\n            return expectation.description;\n          }\n        };\n\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g,  '\\\\\"')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function classEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\]/g, '\\\\]')\n        .replace(/\\^/g, '\\\\^')\n        .replace(/-/g,  '\\\\-')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n          i, j;\n\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n\n    var peg$FAILED = {},\n\n        peg$startRuleFunctions = { Start: peg$parseStart },\n        peg$startRuleFunction  = peg$parseStart,\n\n        peg$c0 = \"\",\n        peg$c1 = function() { return { type: NULL, value: null } },\n        peg$c2 = \"=\",\n        peg$c3 = peg$literalExpectation(\"=\", false),\n        peg$c4 = function(exp) { return exp; },\n        peg$c5 = \"'\",\n        peg$c6 = peg$literalExpectation(\"'\", false),\n        peg$c7 = function(str) { return { type: STRING, value: text().substring(1), meta: { type: STR_ESCAPED } }; },\n        peg$c8 = /^[^'=+\\-*\\/&<>\\^]/,\n        peg$c9 = peg$classExpectation([\"'\", \"=\", \"+\", \"-\", \"*\", \"/\", \"&\", \"<\", \">\", \"^\"], true, false),\n        peg$c10 = function() { return { type: STRING, value: text(), meta: { type: STR_PLAIN } } },\n        peg$c11 = peg$anyExpectation(),\n        peg$c12 = \"<>\",\n        peg$c13 = peg$literalExpectation(\"<>\", false),\n        peg$c14 = \"<=\",\n        peg$c15 = peg$literalExpectation(\"<=\", false),\n        peg$c16 = \">=\",\n        peg$c17 = peg$literalExpectation(\">=\", false),\n        peg$c18 = \"<\",\n        peg$c19 = peg$literalExpectation(\"<\", false),\n        peg$c20 = \">\",\n        peg$c21 = peg$literalExpectation(\">\", false),\n        peg$c22 = function(head, tail) {\n              return tail.reduce(function(result, element) {\n                if (element[1] === \"=\") { return stdop(result, element[3], (x,y)=>x==y, BOOLEAN, \"==\") }\n                if (element[1] === \"<\") { return stdop(result, element[3], (x,y)=>x<y, BOOLEAN, \"<\") }\n                if (element[1] === \">\") { return stdop(result, element[3], (x,y)=>x>y, BOOLEAN, \">\") }\n                if (element[1] === \"<=\") { return stdop(result, element[3], (x,y)=>x<=y, BOOLEAN, \"<=\") }\n                if (element[1] === \">=\") { return stdop(result, element[3], (x,y)=>x>=y, BOOLEAN, \">=\") }\n                if (element[1] === \"<>\") { return stdop(result, element[3], (x,y)=>x!=y, BOOLEAN, \"<>\") }\n              }, head);\n            },\n        peg$c23 = \"&\",\n        peg$c24 = peg$literalExpectation(\"&\", false),\n        peg$c25 = function(head, tail) {\n              return tail.reduce(function(result, element) {\n                if (element[1] === \"&\") { return stdop(result, element[3], (x,y)=>\"\"+x+y, STRING, \"&\") }\n              }, head);\n            },\n        peg$c26 = \"+\",\n        peg$c27 = peg$literalExpectation(\"+\", false),\n        peg$c28 = \"-\",\n        peg$c29 = peg$literalExpectation(\"-\", false),\n        peg$c30 = function(head, tail) {\n              return tail.reduce(function(result, element) {\n                if (element[1] === \"+\") { return stdop(result, element[3], (x,y)=>x+y, NUMBER, \"+\") }\n                if (element[1] === \"-\") { return stdop(result, element[3], (x,y)=>x-y, NUMBER, \"-\") }\n              }, head);\n            },\n        peg$c31 = \"*\",\n        peg$c32 = peg$literalExpectation(\"*\", false),\n        peg$c33 = \"/\",\n        peg$c34 = peg$literalExpectation(\"/\", false),\n        peg$c35 = function(head, tail) {\n              return tail.reduce(function(result, element) {\n                if (element[1] === \"*\") { return stdop(result, element[3], (x,y)=>x*y, NUMBER, \"*\") }\n                if (element[1] === \"/\") { return stdop(result, element[3], (x,y)=>x/y, NUMBER, \"/\") }\n              }, head);\n            },\n        peg$c36 = \"^\",\n        peg$c37 = peg$literalExpectation(\"^\", false),\n        peg$c38 = function(head, tail) {\n              return tail.reduce(function(result, element) {\n                if (element[1] === \"^\") {\n                \treturn stdop(result, element[3], (x,y)=>Math.pow(x,y), NUMBER, \"^\");\n                }\n              }, head);\n            },\n        peg$c39 = \"{\",\n        peg$c40 = peg$literalExpectation(\"{\", false),\n        peg$c41 = \";\",\n        peg$c42 = peg$literalExpectation(\";\", false),\n        peg$c43 = function(inner, x) { return x; },\n        peg$c44 = \"}\",\n        peg$c45 = peg$literalExpectation(\"}\", false),\n        peg$c46 = function(inner, rows) {\n            const Cell_Trace = inner.map(i => i[CELL_TRACE] || []);\n            if(!rows.length) {\n            \treturn { type: LIST, value: inner, meta: { type: INLINE }, [CELL_TRACE]: [].concat(...Cell_Trace) };\n            }\n        \treturn { type: MATRIX, value: [inner, ...rows], meta: { type: INLINE }, [CELL_TRACE]: [].concat(...Cell_Trace) };\n        },\n        peg$c47 = \",\",\n        peg$c48 = peg$literalExpectation(\",\", false),\n        peg$c49 = function(member, x) {return x;},\n        peg$c50 = function(member, members) { return [member || { type: NULL }, ...members]; },\n        peg$c51 = \"(\",\n        peg$c52 = peg$literalExpectation(\"(\", false),\n        peg$c53 = \")\",\n        peg$c54 = peg$literalExpectation(\")\", false),\n        peg$c55 = function(expr) { return expr; },\n        peg$c56 = \"TRUE\",\n        peg$c57 = peg$literalExpectation(\"TRUE\", false),\n        peg$c58 = function() { return { type: BOOLEAN, value: true, [CELL_TRACE]: [] } },\n        peg$c59 = \"FALSE\",\n        peg$c60 = peg$literalExpectation(\"FALSE\", false),\n        peg$c61 = function() { return { type: BOOLEAN, value: false, [CELL_TRACE]: [] } },\n        peg$c62 = /^[a-zA-Z]/,\n        peg$c63 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false),\n        peg$c64 = /^[a-zA-Z0-9_]/,\n        peg$c65 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"_\"], false, false),\n        peg$c66 = function() { return text(); },\n        peg$c67 = \"!\",\n        peg$c68 = peg$literalExpectation(\"!\", false),\n        peg$c69 = function(t) { return { sheet: t }; },\n        peg$c70 = \"[\",\n        peg$c71 = peg$literalExpectation(\"[\", false),\n        peg$c72 = /^[a-zA-Z0-9_.]/,\n        peg$c73 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"_\", \".\"], false, false),\n        peg$c74 = \"]\",\n        peg$c75 = peg$literalExpectation(\"]\", false),\n        peg$c76 = function(t, s) { return { ...s, workbook: t } },\n        peg$c77 = \"\\\\'\",\n        peg$c78 = peg$literalExpectation(\"\\\\'\", false),\n        peg$c79 = /^[^']/,\n        peg$c80 = peg$classExpectation([\"'\"], true, false),\n        peg$c81 = function() { return text().replace(/\\\\'/g, \"'\"); },\n        peg$c82 = function(t) { return { sheet: t }  },\n        peg$c83 = \"\\\\]\",\n        peg$c84 = peg$literalExpectation(\"\\\\]\", false),\n        peg$c85 = /^[^\\]]/,\n        peg$c86 = peg$classExpectation([\"]\"], true, false),\n        peg$c87 = function() { return text().replace(/\\\\\\]/g, \"]\"); },\n        peg$c88 = function(t1) { return text().replace(/\\\\'/g, \"'\"); },\n        peg$c89 = function(t1, t2) { return { sheet: t2, workbook: t1 }  },\n        peg$c90 = \"$\",\n        peg$c91 = peg$literalExpectation(\"$\", false),\n        peg$c92 = /^[A-Z]/,\n        peg$c93 = peg$classExpectation([[\"A\", \"Z\"]], false, false),\n        peg$c94 = /^[1-9]/,\n        peg$c95 = peg$classExpectation([[\"1\", \"9\"]], false, false),\n        peg$c96 = /^[0-9]/,\n        peg$c97 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n        peg$c98 = function(loc, abscol, col, absrow) { return parseInt(text(), 10); },\n        peg$c99 = function(loc, abscol, col, absrow, row) {\n            const c = col.reduce((sum, char) => sum*26+char.charCodeAt(0)-64, 0);\n            const { row: crow, col: ccol } = currentcell;\n            // loc:(CellSheetWorkbook)?\n            const locx = loc || {};\n            let contextu = context;\n            if(locx.workbook) {\n            \tcontextu = contextu.getWorkbook(locx.workbook);\n            }\n            if(locx.sheet) {\n            \tcontextu = contextu.getWorkbook(locx.sheet);\n            }\n            const carg = { ...locx, row: row-1, col: c-1, type: NATURALREF };\n            const v = contextu.getRow(row-1, carg).getCol(c-1, carg) || { value: null, type: \"ERROR\" };\n            const inheritedCellTrace = v[CELL_TRACE] || [];\n            const result = {\n            \t...v,\n            \ttype: v.type,\n                meta: { ...locx, type: CELL, row: row, col: c, absrow: absrow === \"$\", abscol: abscol === \"$\" },\n                value: v.value,\n                [CELL_TRACE]: inheritedCellTrace.concat([{row: row, col: c}]),\n            };\n            return result;\n        },\n        peg$c100 = \"R\",\n        peg$c101 = peg$literalExpectation(\"R\", false),\n        peg$c102 = \"C\",\n        peg$c103 = peg$literalExpectation(\"C\", false),\n        peg$c104 = function(loc, row, col) {\n            const { row: crow, col: ccol } = currentcell;\n            let r = row.absolute ? row.cell : crow + row.cell;\n            let c = col.absolute ? col.cell : ccol + col.cell;\n            \n            // loc:(CellSheetWorkbook)?\n            const locx = loc || {};\n            let contextu = context;\n            if(locx.workbook) {\n            \tcontextu = contextu.getWorkbook(locx.workbook);\n            }\n            if(locx.sheet) {\n            \tcontextu = contextu.getWorkbook(locx.sheet);\n            }\n            const carg = { ...locx, row: r-1, col: c-1, type: NATURALREF };\n            const v = contextu.getRow(r-1, carg).getCol(c-1, carg) || { value: null, type: \"ERROR\" };\n            const inheritedCellTrace = v[CELL_TRACE] || [];\n            return {\n            \t...v,\n            \ttype: v.type,\n                meta: { ...locx, type: CELL, row: r, col: c, absrow: row.absolute, abscol: col.absolute, notation: \"R1C1\" },\n                value: v.value,\n                [CELL_TRACE]: inheritedCellTrace.concat([{row: row, col: c}]),\n            };\n        },\n        peg$c105 = function() { return parseInt(text(), 10); },\n        peg$c106 = function(cell) {\n        \t\t\t\treturn { cell, absolute: true };\n        \t\t\t},\n        peg$c107 = function(cell) {\n        \t\t\t\treturn { cell, absolute: false };\n        \t\t\t},\n        peg$c108 = \":\",\n        peg$c109 = peg$literalExpectation(\":\", false),\n        peg$c110 = function(loc, start, end) {\n            \n            \t// loc:(CellSheetWorkbook)?\n                const locx = loc || {};\n                let contextu = context;\n                if(locx.workbook) {\n                    contextu = contextu.getWorkbook(locx.workbook);\n                }\n                if(locx.sheet) {\n                    contextu = contextu.getWorkbook(locx.sheet);\n                }\n                const meta = { ...locx, type: NATURALREF };\n              const results = [];\n              const cellTrace = []\n            \tfor(var row = start.meta.row; row <= end.meta.row; row++) {\n                  const t = [];\n                  for(var col = start.meta.col; col <= end.meta.col; col++) {\n                      const v = contextu.getRow(row-1,{...meta, row: row-1, col: col-1}).getCol(col-1,{...meta, row: row-1, col: col-1}) || { value: null, type: \"ERROR\" };\n                      cellTrace.push(...(v[CELL_TRACE] || []));\n                      t.push({ ...v, meta: { ...locx, type: CELL, row, col } });\n                  }\n                  results.push(t);\n                }\n                \n                if(results.length === 1) {\n                \treturn { type: LIST, value: results[0], meta, [CELL_TRACE]: cellTrace }\n                }\n                if(results.every(r => r.length === 1)) {\n                \treturn { type: LIST, value: results.map(i => i[0]), meta, [CELL_TRACE]: cellTrace }\n                }\n                return { type: MATRIX, value: results, meta, [CELL_TRACE]: cellTrace }\n            },\n        peg$c111 = function(arg0, y) { return y; },\n        peg$c112 = function(arg0) { return { type: NULL, value: undefined } },\n        peg$c113 = function(arg0, t) { return t; },\n        peg$c114 = function(arg0, args) { return { type: ARGUMENTS, value: [arg0, ...args] } },\n        peg$c115 = /^[a-zA-Z0-9.]/,\n        peg$c116 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \".\"], false, false),\n        peg$c117 = function() { return text() },\n        peg$c118 = function(name, arg0, y) { return y; },\n        peg$c119 = function(name, arg0) { return { type: NULL, value: undefined } },\n        peg$c120 = function(name, arg0, t) { return t; },\n        peg$c121 = function(name, arg0, args) {\n        \tif(functions[name]) {\n            \tconst allargs = [arg0, ...args].map(i => i || { type: NULL, [CELL_TRACE]: [] });\n                const cellTrace = allargs.reduce((p, i) => p.concat(i[CELL_TRACE] || []), []);\n                try {\n                \tconst func = functions[name];\n                    \n                \tconst v = func(allargs, { ...ctx, currentcell, name, raw: text(), allowUnsafe, functions, table: context, parser: parser, [CELL_TRACE]: cellTrace });\n                    if(!v) {\n                    \tthrow new Error(\"Function '\"+name+\"' did not return a result! Check the implementation!\");\n                    }\n                    v[TRACE] = {\n                        function: name,\n                    \targuments: allargs\n                    };\n                    v[CELL_TRACE] = cellTrace.concat(v[CELL_TRACE] || []);\n                    return v;\n                } catch(e) {\n                \tconst initialError = allargs.find((e) => e && (e.type === ERROR));\n                    const r = { type: ERROR, value: (initialError && initialError.value) || e.name+' in '+name+': \"'+e.message+'\"', meta: {  error_value: initialError, internal_error: e } }\n                    r[CELL_TRACE] = cellTrace;\n                    return r;\n                }\n            }\n            if(functions[name.toUpperCase()]) {\n            \treturn { type: ERROR, value: NAMEE, meta: { error: \"Unknown function \"+name+\". Did you mean \"+name.toUpperCase()+\"?\" } };\n            }\n            const simiar = Object.keys(functions).find(fnc => fnc.toUpperCase() === name.toUpperCase());\n            if(simiar) {\n            \treturn { type: ERROR, value: NAMEE, meta: { error: \"Unknown function \"+name+\". Did you mean \"+simiar+\"?\" } };\n            }\n            // todo find close names\n            return { type: ERROR, value: NAMEE, meta: { error: \"Unknown function \"+name } };\n        },\n        peg$c122 = \" \",\n        peg$c123 = peg$literalExpectation(\" \", false),\n        peg$c124 = function(a, b) {\n            if(a.type !== LIST || b.type !== LIST) {\n            \tthrow new Error(\"An intersection between anything else but LISTs is currently not supported. Expected LIST, LIST, found \"+a.type+\", \"+b.type); \n            }\n            const v = a.value.filter(i => b.value.some(j => j.meta.row === i.meta.row && j.meta.col === i.meta.col));\n            const cellTrace = [].concat(...v.map(i => i[CELL_TRACE] || []));\n            return {\n            \ttype: LIST,\n              value: v,\n              meta: { type: NATURALREF },\n              [CELL_TRACE]: cellTrace\n            }\n        },\n        peg$c125 = function(loc) { return text(); },\n        peg$c126 = function(loc, start) { return text(); },\n        peg$c127 = function(loc, start, end) {\n            \tif(start !== end) {\n                \tthrow new Error(\"Infinite row-ranges can't span multiple columns \\\"\"+start+\":\"+end+\"\\\"\")\n                }\n                // loc:(CellSheetWorkbook)?\n                const locx = loc || {};\n                let contextu = context;\n                if(locx.workbook) {\n                    contextu = contextu.getWorkbook(locx.workbook);\n                }\n                if(locx.sheet) {\n                    contextu = contextu.getWorkbook(locx.sheet);\n                }\n                const c = start.split(\"\").reduce((sum, char) => sum*26+char.charCodeAt(0)-64, 0);\n                const meta = { ...locx, type: NATURALREF };\n                const v = contextu.getCol(c-1,meta).all({ col: c-1 }, meta);\n                const cellTrace = [{ col: c, row: \"*\" }].concat(...v.map(i => i[CELL_TRACE] || []));\n                return { type: LIST, value: v, meta, [CELL_TRACE]: cellTrace };\n            },\n        peg$c128 = function(loc, start, end) {\n            \tif(start !== end) {\n                \tthrow new Error(\"Infinite row-ranges can't span multiple columns \\\"\"+start+\":\"+end+\"\\\"\")\n                }\n                // loc:(CellSheetWorkbook)?\n                const locx = loc || {};\n                let contextu = context;\n                if(locx.workbook) {\n                    contextu = contextu.getWorkbook(locx.workbook);\n                }\n                if(locx.sheet) {\n                    contextu = contextu.getWorkbook(locx.sheet);\n                }\n                const r = parseInt(start, 10);\n                const meta = { ...contextu, type: NATURALREF };\n                const v = contextu.getRow(r-1,meta).all({ row: r-1 },meta);\n                const cellTrace = [{ row: r, col: \"*\" }].concat(...v.map(i => i[CELL_TRACE] || []));\n                return { type: LIST, value: v, meta, [CELL_TRACE]: cellTrace };\n            },\n        peg$c129 = function(x) { return x; },\n        peg$c130 = function(unsafestart, unsafeend) {\n            \tconst results = [];\n                let start = unsafestart;\n                if(unsafestart.type === ERROR && unsafestart.value === CIRCULAR) {\n                \tstart = {...unsafestart.meta, meta: unsafestart.meta};\n                }\n                let end = unsafeend;\n                if(unsafeend.type === ERROR && unsafeend.value === CIRCULAR) {\n                \tend = {...unsafeend.meta, meta: unsafeend.meta};\n                }\n                let contextu = context;\n                const loc = {};\n                if(start.meta.workbook) {\n                    contextu = contextu.getWorkbook(start.meta.workbook);\n                    loc.workbook = start.meta.workbook; // Avoid keys with undefined values\n                }\n                if(start.meta.sheet) {\n                    contextu = contextu.getWorkbook(start.meta.sheet);\n                    loc.sheet = start.meta.sheet; // Avoid keys with undefined values\n                }\n                const cellTrace = [];\n         \t\t  let circularFlag = false;\n            \tfor(let row = start.meta.row; row <= end.meta.row; row++) {\n                  const t = [];\n                  for(let col = start.meta.col; col <= end.meta.col; col++) {\n                      const v = contextu.getRow(row-1, {...loc,type: NATURALREF}).getCol(col-1, {...loc,type: NATURALREF}) || { value: null, type: \"ERROR\" };\n                      cellTrace.push(...(v[CELL_TRACE] || []));\n                      cellTrace.push({ row, col })\n                      if(v.type === ERROR && v.value === CIRCULAR) {\n                      \tcircularFlag = true;\n                      }\n                      t.push({ ...v, meta: { ...start.meta, type: CELL, row, col } });\n                      \n                  }\n                  results.push(t);\n                }\n                \n                if(results.length === 1) {\n                  const result = { type: LIST, value: results[0], rowspan: 1, colspan: results[0].length, meta: { ...loc, type: NATURALREF }, [CELL_TRACE]: cellTrace };\n                  if(circularFlag) {\n                        return { type: ERROR, value: CIRCULAR, meta: result, [CELL_TRACE]: cellTrace };\n                    }\n                  return result;\n                }\n                if(results.every(r => r.length === 1)) {\n                  const result = { type: LIST, value: results.map(i => i[0]), rowspan: results.length, colspan: 1, meta: { ...loc, type: NATURALREF }, [CELL_TRACE]: cellTrace };\n                  if(circularFlag) {\n                        return { type: ERROR, value: CIRCULAR, meta: result, [CELL_TRACE]: cellTrace };\n                    }\n                  return result;\n                }\n                const result = {\n                  type: MATRIX,\n                    value: results,\n                    get rowspan() { return results.length }, \n                    get colspan() { return results[0].length },\n                    meta: { ...loc, type: NATURALREF },\n                    [CELL_TRACE]: cellTrace\n               };\n               if(unsafestart.type === ERROR && unsafestart.value === CIRCULAR) {\n                  return { ...unsafestart, type: ERROR, value: CIRCULAR, meta: result, [CELL_TRACE]: cellTrace };\n                }\n               if(circularFlag) {\n                 return { type: ERROR, value: CIRCULAR, meta: result, [CELL_TRACE]: cellTrace };\n               }\n               \n                if(unsafeend.type === ERROR && unsafeend.value === CIRCULAR) {\n                  return { ...unsafeend, type: ERROR, value: CIRCULAR, meta: result, [CELL_TRACE]: cellTrace };\n                }\n                return result;\n            },\n        peg$c131 = \"\\\"\\\"\",\n        peg$c132 = peg$literalExpectation(\"\\\"\\\"\", false),\n        peg$c133 = function() {return { type: STRING, value: \"\", meta: { empty: true } }},\n        peg$c134 = \"\\\"\",\n        peg$c135 = peg$literalExpectation(\"\\\"\", false),\n        peg$c136 = \"\\\\\\\"\",\n        peg$c137 = peg$literalExpectation(\"\\\\\\\"\", false),\n        peg$c138 = /^[^\"]/,\n        peg$c139 = peg$classExpectation([\"\\\"\"], true, false),\n        peg$c140 = function() { return text().replace(/\\\\\\\"/g, \"\\\"\"); },\n        peg$c141 = function(t) {return { type: STRING, value: t } },\n        peg$c142 = peg$otherExpectation(\"number\"),\n        peg$c143 = function(num) { return num; },\n        peg$c144 = \".\",\n        peg$c145 = peg$literalExpectation(\".\", false),\n        peg$c146 = \"%\",\n        peg$c147 = peg$literalExpectation(\"%\", false),\n        peg$c148 = function(percent) { return { type: NUMBER, value: (percent === \"%\" ? 0.01 : 1) * parseFloat(text(), 10) }; },\n        peg$c149 = peg$otherExpectation(\"whitespace\"),\n        peg$c150 = /^[ \\t\\n\\r]/,\n        peg$c151 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1 }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildStructuredError(\n        [peg$otherExpectation(description)],\n        input.substring(peg$savedPos, peg$currPos),\n        location\n      );\n    }\n\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildSimpleError(message, location);\n    }\n\n    function peg$literalExpectation(text, ignoreCase) {\n      return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description: description };\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos], p;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column\n        };\n\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(\n        peg$SyntaxError.buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parseStart() {\n      var s0;\n\n      s0 = peg$parseEquasion();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseEscaped();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseNum();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseStatic();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseEmpty();\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseEmpty() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      s1 = peg$c0;\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseEquasion() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s1 = peg$c2;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseExpression();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c4(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseEscaped() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 39) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c6); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseString();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c7(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseStatic() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (peg$c8.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c9); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseString();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseString() {\n      var s0, s1;\n\n      s0 = [];\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c11); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (input.length > peg$currPos) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c11); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseExpression() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      s0 = peg$currPos;\n      s1 = peg$parseYExpression();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s5 = peg$c2;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c3); }\n          }\n          if (s5 === peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c12) {\n              s5 = peg$c12;\n              peg$currPos += 2;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c13); }\n            }\n            if (s5 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c14) {\n                s5 = peg$c14;\n                peg$currPos += 2;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c15); }\n              }\n              if (s5 === peg$FAILED) {\n                if (input.substr(peg$currPos, 2) === peg$c16) {\n                  s5 = peg$c16;\n                  peg$currPos += 2;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c17); }\n                }\n                if (s5 === peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 60) {\n                    s5 = peg$c18;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c19); }\n                  }\n                  if (s5 === peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 62) {\n                      s5 = peg$c20;\n                      peg$currPos++;\n                    } else {\n                      s5 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseYExpression();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s5 = peg$c2;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c3); }\n            }\n            if (s5 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c12) {\n                s5 = peg$c12;\n                peg$currPos += 2;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c13); }\n              }\n              if (s5 === peg$FAILED) {\n                if (input.substr(peg$currPos, 2) === peg$c14) {\n                  s5 = peg$c14;\n                  peg$currPos += 2;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c15); }\n                }\n                if (s5 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 2) === peg$c16) {\n                    s5 = peg$c16;\n                    peg$currPos += 2;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c17); }\n                  }\n                  if (s5 === peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 60) {\n                      s5 = peg$c18;\n                      peg$currPos++;\n                    } else {\n                      s5 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c19); }\n                    }\n                    if (s5 === peg$FAILED) {\n                      if (input.charCodeAt(peg$currPos) === 62) {\n                        s5 = peg$c20;\n                        peg$currPos++;\n                      } else {\n                        s5 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseYExpression();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c22(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseYExpression() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      s0 = peg$currPos;\n      s1 = peg$parseXExpression();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 38) {\n            s5 = peg$c23;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c24); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseXExpression();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 38) {\n              s5 = peg$c23;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c24); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseXExpression();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c25(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseXExpression() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      s0 = peg$currPos;\n      s1 = peg$parseXTerm();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 43) {\n            s5 = peg$c26;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c27); }\n          }\n          if (s5 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 45) {\n              s5 = peg$c28;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c29); }\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseXTerm();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 43) {\n              s5 = peg$c26;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c27); }\n            }\n            if (s5 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 45) {\n                s5 = peg$c28;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c29); }\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseXTerm();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c30(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseXTerm() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      s0 = peg$currPos;\n      s1 = peg$parseTerm();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s5 = peg$c31;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c32); }\n          }\n          if (s5 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s5 = peg$c33;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c34); }\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseTerm();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 42) {\n              s5 = peg$c31;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c32); }\n            }\n            if (s5 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 47) {\n                s5 = peg$c33;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c34); }\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseTerm();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c35(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseTerm() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      s0 = peg$currPos;\n      s1 = peg$parseFactor();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 94) {\n            s5 = peg$c36;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c37); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseFactor();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 94) {\n              s5 = peg$c36;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c37); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseFactor();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c38(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseList() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s1 = peg$c39;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c40); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseInnerList();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 59) {\n            s5 = peg$c41;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c42); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseInnerList();\n            if (s6 !== peg$FAILED) {\n              peg$savedPos = s4;\n              s5 = peg$c43(s2, s6);\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 59) {\n              s5 = peg$c41;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c42); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseInnerList();\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s4;\n                s5 = peg$c43(s2, s6);\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 125) {\n              s4 = peg$c44;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c45); }\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c46(s2, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseInnerList() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$parseTrue();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseFalse();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseStr();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseNum();\n          }\n        }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s4 = peg$c47;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseTrue();\n          if (s5 === peg$FAILED) {\n            s5 = peg$parseFalse();\n            if (s5 === peg$FAILED) {\n              s5 = peg$parseStr();\n              if (s5 === peg$FAILED) {\n                s5 = peg$parseNum();\n              }\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c49(s1, s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s4 = peg$c47;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c48); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseTrue();\n            if (s5 === peg$FAILED) {\n              s5 = peg$parseFalse();\n              if (s5 === peg$FAILED) {\n                s5 = peg$parseStr();\n                if (s5 === peg$FAILED) {\n                  s5 = peg$parseNum();\n                }\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s4 = peg$c49(s1, s5);\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c50(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseFactor() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c51;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseExpression();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c53;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c54); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c55(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseList();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseFunction();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseIdentifyFunction();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseIntersection();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parseTrue();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parseFalse();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseFiniteRangeR1C1();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parseR1C1Cell();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parseInfiniteRangeAZ();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parseInfiniteRange09();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parseFiniteRange();\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$parseCell();\n                              if (s0 === peg$FAILED) {\n                                s0 = peg$parseStr();\n                                if (s0 === peg$FAILED) {\n                                  s0 = peg$parseNum();\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseTrue() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 4) === peg$c56) {\n          s2 = peg$c56;\n          peg$currPos += 4;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c57); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c58();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseFalse() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c59) {\n          s2 = peg$c59;\n          peg$currPos += 5;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c60); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c61();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseCellSheetWorkbook() {\n      var s0;\n\n      s0 = peg$parseWorkbooksheetquote();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseSheetquote();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseWorkbooksheet();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseSheet();\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseSheet() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c62.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c63); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        if (peg$c64.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c65); }\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          if (peg$c64.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c65); }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c66();\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 33) {\n          s2 = peg$c67;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c68); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c69(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseWorkbooksheet() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c70;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c71); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        if (peg$c62.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c63); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          if (peg$c72.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c73); }\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c72.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c73); }\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s2;\n            s3 = peg$c66();\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s3 = peg$c74;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c75); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseSheet();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c76(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseSheetquote() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 39) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c6); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = [];\n        if (input.substr(peg$currPos, 2) === peg$c77) {\n          s4 = peg$c77;\n          peg$currPos += 2;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c78); }\n        }\n        if (s4 === peg$FAILED) {\n          if (peg$c79.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c80); }\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (input.substr(peg$currPos, 2) === peg$c77) {\n              s4 = peg$c77;\n              peg$currPos += 2;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c78); }\n            }\n            if (s4 === peg$FAILED) {\n              if (peg$c79.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c80); }\n              }\n            }\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s2;\n          s3 = peg$c81();\n        }\n        s2 = s3;\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 39) {\n            s3 = peg$c5;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c6); }\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 33) {\n              s4 = peg$c67;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c68); }\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c82(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseWorkbooksheetquote() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 39) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c6); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 91) {\n          s2 = peg$c70;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c71); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = [];\n          if (input.substr(peg$currPos, 2) === peg$c83) {\n            s5 = peg$c83;\n            peg$currPos += 2;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c84); }\n          }\n          if (s5 === peg$FAILED) {\n            if (peg$c85.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c86); }\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              if (input.substr(peg$currPos, 2) === peg$c83) {\n                s5 = peg$c83;\n                peg$currPos += 2;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c84); }\n              }\n              if (s5 === peg$FAILED) {\n                if (peg$c85.test(input.charAt(peg$currPos))) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                }\n              }\n            }\n          } else {\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c87();\n          }\n          s3 = s4;\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 93) {\n              s4 = peg$c74;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c75); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$currPos;\n              s6 = [];\n              if (input.substr(peg$currPos, 2) === peg$c77) {\n                s7 = peg$c77;\n                peg$currPos += 2;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c78); }\n              }\n              if (s7 === peg$FAILED) {\n                if (peg$c79.test(input.charAt(peg$currPos))) {\n                  s7 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c80); }\n                }\n              }\n              if (s7 !== peg$FAILED) {\n                while (s7 !== peg$FAILED) {\n                  s6.push(s7);\n                  if (input.substr(peg$currPos, 2) === peg$c77) {\n                    s7 = peg$c77;\n                    peg$currPos += 2;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c78); }\n                  }\n                  if (s7 === peg$FAILED) {\n                    if (peg$c79.test(input.charAt(peg$currPos))) {\n                      s7 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s7 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c80); }\n                    }\n                  }\n                }\n              } else {\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s5;\n                s6 = peg$c88(s3);\n              }\n              s5 = s6;\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 39) {\n                  s6 = peg$c5;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c6); }\n                }\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 33) {\n                    s7 = peg$c67;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c68); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c89(s3, s5);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseCell() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseCellSheetWorkbook();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 36) {\n            s3 = peg$c90;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c91); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            if (peg$c92.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c93); }\n            }\n            if (s5 !== peg$FAILED) {\n              while (s5 !== peg$FAILED) {\n                s4.push(s5);\n                if (peg$c92.test(input.charAt(peg$currPos))) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c93); }\n                }\n              }\n            } else {\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 36) {\n                s5 = peg$c90;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c91); }\n              }\n              if (s5 === peg$FAILED) {\n                s5 = null;\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$currPos;\n                if (peg$c94.test(input.charAt(peg$currPos))) {\n                  s7 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c95); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = [];\n                  if (peg$c96.test(input.charAt(peg$currPos))) {\n                    s9 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s9 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c97); }\n                  }\n                  while (s9 !== peg$FAILED) {\n                    s8.push(s9);\n                    if (peg$c96.test(input.charAt(peg$currPos))) {\n                      s9 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c97); }\n                    }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s6;\n                    s7 = peg$c98(s2, s3, s4, s5);\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c99(s2, s3, s4, s5, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseR1C1Cell() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseCellSheetWorkbook();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 82) {\n            s3 = peg$c100;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c101); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseR1C1CellAbs();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 67) {\n                s5 = peg$c102;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c103); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseR1C1CellAbs();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c104(s2, s4, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseR1C1CellAbs() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c70;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c71); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        if (peg$c94.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c95); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          if (peg$c96.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c97); }\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c96.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c97); }\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s2;\n            s3 = peg$c105();\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s3 = peg$c74;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c75); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c106(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        if (peg$c94.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c95); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c96.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c97); }\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c96.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c97); }\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c105();\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c107(s1);\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseFiniteRangeR1C1() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseCellSheetWorkbook();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseR1C1Cell();\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 58) {\n              s4 = peg$c108;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c109); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseR1C1Cell();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c110(s2, s3, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseIdentifyFunction() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s2 = peg$c51;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c52); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseExpression();\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$currPos;\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s7 = peg$c47;\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c48); }\n              }\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parse_();\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$currPos;\n                  s10 = peg$parseExpression();\n                  if (s10 !== peg$FAILED) {\n                    peg$savedPos = s9;\n                    s10 = peg$c111(s3, s10);\n                  }\n                  s9 = s10;\n                  if (s9 === peg$FAILED) {\n                    s9 = peg$currPos;\n                    s10 = peg$c0;\n                    if (s10 !== peg$FAILED) {\n                      peg$savedPos = s9;\n                      s10 = peg$c112(s3);\n                    }\n                    s9 = s10;\n                  }\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$parse_();\n                    if (s10 !== peg$FAILED) {\n                      peg$savedPos = s5;\n                      s6 = peg$c113(s3, s9);\n                      s5 = s6;\n                    } else {\n                      peg$currPos = s5;\n                      s5 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s7 = peg$c47;\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse_();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$currPos;\n                    s10 = peg$parseExpression();\n                    if (s10 !== peg$FAILED) {\n                      peg$savedPos = s9;\n                      s10 = peg$c111(s3, s10);\n                    }\n                    s9 = s10;\n                    if (s9 === peg$FAILED) {\n                      s9 = peg$currPos;\n                      s10 = peg$c0;\n                      if (s10 !== peg$FAILED) {\n                        peg$savedPos = s9;\n                        s10 = peg$c112(s3);\n                      }\n                      s9 = s10;\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parse_();\n                      if (s10 !== peg$FAILED) {\n                        peg$savedPos = s5;\n                        s6 = peg$c113(s3, s9);\n                        s5 = s6;\n                      } else {\n                        peg$currPos = s5;\n                        s5 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s5;\n                      s5 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c53;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c54); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c114(s3, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseFunction() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c62.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c63); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        if (peg$c115.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c116); }\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          if (peg$c115.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c116); }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c117();\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s3 = peg$c51;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c52); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseExpression();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$currPos;\n              s7 = peg$parse_();\n              if (s7 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s8 = peg$c47;\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                }\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parse_();\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$currPos;\n                    s11 = peg$parseExpression();\n                    if (s11 !== peg$FAILED) {\n                      peg$savedPos = s10;\n                      s11 = peg$c118(s1, s4, s11);\n                    }\n                    s10 = s11;\n                    if (s10 === peg$FAILED) {\n                      s10 = peg$currPos;\n                      s11 = peg$c0;\n                      if (s11 !== peg$FAILED) {\n                        peg$savedPos = s10;\n                        s11 = peg$c119(s1, s4);\n                      }\n                      s10 = s11;\n                    }\n                    if (s10 !== peg$FAILED) {\n                      s11 = peg$parse_();\n                      if (s11 !== peg$FAILED) {\n                        peg$savedPos = s6;\n                        s7 = peg$c120(s1, s4, s10);\n                        s6 = s7;\n                      } else {\n                        peg$currPos = s6;\n                        s6 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$currPos;\n                s7 = peg$parse_();\n                if (s7 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s8 = peg$c47;\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parse_();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$currPos;\n                      s11 = peg$parseExpression();\n                      if (s11 !== peg$FAILED) {\n                        peg$savedPos = s10;\n                        s11 = peg$c118(s1, s4, s11);\n                      }\n                      s10 = s11;\n                      if (s10 === peg$FAILED) {\n                        s10 = peg$currPos;\n                        s11 = peg$c0;\n                        if (s11 !== peg$FAILED) {\n                          peg$savedPos = s10;\n                          s11 = peg$c119(s1, s4);\n                        }\n                        s10 = s11;\n                      }\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parse_();\n                        if (s11 !== peg$FAILED) {\n                          peg$savedPos = s6;\n                          s7 = peg$c120(s1, s4, s10);\n                          s6 = s7;\n                        } else {\n                          peg$currPos = s6;\n                          s6 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s6;\n                        s6 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s6 = peg$c53;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c121(s1, s4, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseIntersection() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseXFiniteRange();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s3 = peg$c122;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c123); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseXFiniteRange();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse_();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c124(s2, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseInfiniteRangeAZ() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseCellSheetWorkbook();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = [];\n          if (peg$c92.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c93); }\n          }\n          if (s5 !== peg$FAILED) {\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              if (peg$c92.test(input.charAt(peg$currPos))) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c93); }\n              }\n            }\n          } else {\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c125(s2);\n          }\n          s3 = s4;\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 58) {\n              s4 = peg$c108;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c109); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$currPos;\n              s6 = [];\n              if (peg$c92.test(input.charAt(peg$currPos))) {\n                s7 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c93); }\n              }\n              if (s7 !== peg$FAILED) {\n                while (s7 !== peg$FAILED) {\n                  s6.push(s7);\n                  if (peg$c92.test(input.charAt(peg$currPos))) {\n                    s7 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c93); }\n                  }\n                }\n              } else {\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s5;\n                s6 = peg$c126(s2, s3);\n              }\n              s5 = s6;\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c127(s2, s3, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseInfiniteRange09() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseCellSheetWorkbook();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (peg$c94.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c95); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            if (peg$c96.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c97); }\n            }\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              if (peg$c96.test(input.charAt(peg$currPos))) {\n                s6 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c97); }\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s4 = peg$c125(s2);\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 58) {\n              s4 = peg$c108;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c109); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$currPos;\n              if (peg$c94.test(input.charAt(peg$currPos))) {\n                s6 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c95); }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = [];\n                if (peg$c96.test(input.charAt(peg$currPos))) {\n                  s8 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c97); }\n                }\n                while (s8 !== peg$FAILED) {\n                  s7.push(s8);\n                  if (peg$c96.test(input.charAt(peg$currPos))) {\n                    s8 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c97); }\n                  }\n                }\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s5;\n                  s6 = peg$c126(s2, s3);\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c128(s2, s3, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseFiniteRange() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseXFiniteRange();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c129(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseXFiniteRange() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseCell();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s2 = peg$c108;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c109); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseCell();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c130(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseStr() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c131) {\n        s1 = peg$c131;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c132); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c133();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s2 = peg$c134;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c135); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$currPos;\n            s4 = [];\n            if (input.substr(peg$currPos, 2) === peg$c136) {\n              s5 = peg$c136;\n              peg$currPos += 2;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c137); }\n            }\n            if (s5 === peg$FAILED) {\n              if (peg$c138.test(input.charAt(peg$currPos))) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c139); }\n              }\n            }\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              if (input.substr(peg$currPos, 2) === peg$c136) {\n                s5 = peg$c136;\n                peg$currPos += 2;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c137); }\n              }\n              if (s5 === peg$FAILED) {\n                if (peg$c138.test(input.charAt(peg$currPos))) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c139); }\n                }\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s4 = peg$c140();\n            }\n            s3 = s4;\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 34) {\n                s4 = peg$c134;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c135); }\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parse_();\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c141(s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseNum() {\n      var s0, s1, s2, s3;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseNumber();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c143(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c142); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseNumber() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s1 = peg$c26;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c27); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s1 = peg$c28;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c29); }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c96.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c97); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c96.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c97); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s4 = peg$c144;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c145); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            if (peg$c96.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c97); }\n            }\n            if (s6 !== peg$FAILED) {\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                if (peg$c96.test(input.charAt(peg$currPos))) {\n                  s6 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c97); }\n                }\n              }\n            } else {\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 37) {\n              s4 = peg$c146;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c147); }\n            }\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c148(s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1;\n\n      peg$silentFails++;\n      s0 = [];\n      if (peg$c150.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c151); }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c150.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c151); }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c149); }\n      }\n\n      return s0;\n    }\n        \n        const stdop = (a,b,op,returntype,operation) => {\n        \tconst {value:left,type:tleft,meta:{type:lstype}={}} = a;\n            const {value:right,type:tright,meta:{type:rstype}={}} = b;\n            if(tleft === ERROR) {\n                const e = new Error(left.description);\n                e.value = a;\n                throw e;\n            }\n            if(tright === ERROR) {\n                const e = new Error(right.description);\n                e.value = b;\n                throw e;\n            }\n            const Cell_Trace = [...(a[CELL_TRACE] || []),...(b[CELL_TRACE] || [])];\n            const meta = {\n            \tleft: a.meta||{},\n                right: b.meta||{},\n                operation\n            };\n                if(tleft === LIST && tright === NUMBER) {\n                \treturn { type: LIST, value: left.map(({\n                    \tvalue,\n                        meta:m = {},\n                        ...rest\n                    }, idx) => ({\n                    \t...rest,\n                        type: returntype,\n                        value: op(value,right),\n                        meta: Object.assign(meta,{item: m,idx}),\n                        [CELL_TRACE]: Cell_Trace\n                    })) }\n                }\n                if(tleft === NUMBER && tright === LIST) {\n                \treturn { type: LIST, value: right.map(({\n                    \tvalue,\n                        meta:m = {},\n                        ...rest\n                    },idx) => ({\n                    \t...rest,\n                        type: returntype,\n                        value: op(left,value),\n                        meta: Object.assign(meta,{item: m,idx}),\n                        [CELL_TRACE]: Cell_Trace\n                    })) }\n                }\n                if(tleft === LIST && tright === LIST) {\n                \treturn {\n                    \ttype: LIST,\n                        value: left.map(({value,...rest},idx) => ({\n                        \t...rest,\n                            ...right[idx],\n                            meta: {\n                            \t...meta,\n                                item: {\n                                \tleft: rest.meta||{},\n                                    right: right[idx].meta\n                                },\n                                idx,\n                            },\n                            type: returntype,\n                            value: op(value,right[idx].value),\n                            [CELL_TRACE]: Cell_Trace\n                        }))\n                    }\n                    // todo: Maybe distiguish by natural vs inline list?\n                }\n            \treturn { ...a, ...b, type: returntype, value: op(left,right), meta, [CELL_TRACE]: Cell_Trace };\n        };\n        \n        const functions = functionDefinitions;\n        \n        // dynamic, from the outside\n    \tlet xcontext = options._context;\n        let currentcell = options._currentcell;\n        let calledBy = options._calledBy || [];\n        let parser = options._self;\n        const allowUnsafe = options.allowUnsafe || false;\n        \n    \t// static, internal\n        const ccd= calledBy.concat([currentcell]);\n        const ctx = { calledBy: ccd };\n        const context = {\n        \tgetWorkbook: (workbookName) => context,\n        \tgetSheet: (sheetName) => context,\n        \tgetRow: (row) => \n              ({ \n                getCol: (col) => {\n                \t\n                  if(ccd.some(({ row: r, col: c }) => row === r && col === c)) {\n                   return { type: ERROR, value: CIRCULAR, chain: [{col, row}].concat(ccd), meta: {} };\n                  } \n                  return xcontext.getRow(row, ctx).getCol(col, ctx)\n                }, \n                all: () => {\n                  const find = ccd.find(({ row: r }) => row === r);\n                  if(find) {\n                   return { type: ERROR, value: CIRCULAR, chain: [find].concat(ccd), meta: {} };\n                  } \n                  return xcontext.getRow(row, ctx).all(ctx);\n                }\n              }),\n            getCol: (col) => \n              ({ \n                getRow: (row) => {\n                  if(ccd.some(({ row: r, col: c }) => row === r && col === c)) {\n                   return { type: ERROR, value: CIRCULAR, chain: [{col, row}].concat(ccd), meta: {} };\n                  } \n                  return xcontext.getCol(col, ctx).getRow(row, ctx);\n                }, \n                all: () => {\n                  const find = ccd.find(({ col: c }) => col === c);\n                  if(find) {\n                   return { type: ERROR, value: CIRCULAR, chain: [find].concat(ccd), meta: {} };\n                  } \n                  return xcontext.getCol(col, ctx).all(ctx);\n                } \n              })\n        }\n        \n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n\n      throw peg$buildStructuredError(\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    CELL,\n    STR_ESCAPED,\n    STR_PLAIN,\n    AGGREGATE,\n    SUBTOTAL,\n    NUMBER,\n    COMPLEX_NUMBER,\n    LIST,\n    MATRIX,\n    STRING,\n    ANY,\n    BOOLEAN,\n    FUNCTION,\n    ARGUMENTS,\n    NULL,\n    ARRAY,\n    ERROR,\n    DATE,\n    TIME,\n    DATETIME,\n    TRACE,\n    CELL_TRACE,\n    HYPERLINK,\n    NAVALUE,\n    VVALUE,\n    REFVALUE,\n    NUMVALUE,\n    DIV0,\n    NULLE,\n    NAMEE,\n    GETTINGDATA,\n    INLINE,\n    HIDDEN,\n    NATURALREF,\n    CIRCULAR,\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n})();\n","import defaultParser from \"./index.js\";\r\n\r\nconst CELL_ACTION = Symbol(\"CELL_ACTION\");\r\n\r\nclass EventTarget {\r\n  constructor() {\r\n    this.listeners = {};\r\n  }\r\n\r\n  addEventListener(type, callback, useCaptureOptions) {\r\n    if (!(type in this.listeners)) {\r\n      this.listeners[type] = [];\r\n    }\r\n    this.listeners[type].push([callback, useCaptureOptions]);\r\n    return this.removeEventListener.bind(\r\n      this,\r\n      type,\r\n      callback,\r\n      useCaptureOptions\r\n    );\r\n  }\r\n\r\n  removeEventListener(type, callback, useCaptureOptions) {\r\n    if (!(type in this.listeners)) {\r\n      return;\r\n    }\r\n    var stack = this.listeners[type];\r\n    for (let cbsarr of stack) {\r\n      const [cb, uco] = cbsarr;\r\n      if (cb === callback) {\r\n        const useCaptureOptionsKeys = Object.keys(useCaptureOptions);\r\n        const ucoKeys = Object.keys(uco);\r\n        if (\r\n          useCaptureOptionsKeys.length === ucoKeys.length &&\r\n          useCaptureOptionsKeys.every(\r\n            (k) => useCaptureOptionsKeys[k] === ucoKeys[k]\r\n          )\r\n        ) {\r\n          stack.splice(i, 1);\r\n          return;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  dispatchEvent(event) {\r\n    if (!(event.type in this.listeners)) {\r\n      return true;\r\n    }\r\n    const stack = this.listeners[event.type].slice();\r\n\r\n    for (let [cb, useCaptureOptions = {}] of stack) {\r\n      const {\r\n        capture = useCaptureOptions === true,\r\n        once = false,\r\n        passive = false,\r\n      } = useCaptureOptions;\r\n      cb.call(this, event, {\r\n        capture,\r\n        once,\r\n        passive,\r\n      });\r\n      if (once) {\r\n        this.removeEventListener(event.type, cb, useCaptureOptions);\r\n      }\r\n    }\r\n    return !event.defaultPrevented;\r\n  }\r\n}\r\n\r\nexport class Table extends EventTarget {\r\n  constructor({ parser = defaultParser } = { parser: defaultParser }) {\r\n    super();\r\n    this.cells = [];\r\n    this.parser = parser;\r\n  }\r\n\r\n  register(cell) {\r\n      this.cells.push(cell);\r\n  }\r\n}\r\nexport const globalTable = new Table();\r\n\r\nconst findCell = ({ row: r, col: c }) => ({ row, col }) => row === r && col === c;\r\nconst noop = () => undefined;\r\n\r\nexport class Cell extends EventTarget {\r\n  // *one per Input*\r\n  constructor({ name, onUpdate = () => null, table = globalTable, row, col, _value = \"\", formula = \"\", allowUnsafe = false }) {\r\n    super();\r\n    this.references = [];\r\n    this.lastRun = null;\r\n    this.expression = \"\";\r\n    this.name = name || `${String.fromCharCode(65+col)}${row+1}`; // eg A1 // todo: parse for sheet etc\r\n    this.onUpdate = onUpdate;\r\n    this.table = table;\r\n    this.table.register(this);\r\n    this.row = row;\r\n    this.col = col;\r\n    this.value = { value: _value, type: this.table.parser.NULL };\r\n    this.formula = formula;\r\n    this.onTableChange = this.onTableChange.bind(this);\r\n    this.refresh = this.refresh.bind(this);\r\n    this.update = this.update.bind(this);\r\n    this.destroy = this.destroy.bind(this);\r\n    this.allowUnsafe = allowUnsafe;\r\n\r\n    this.onDestroy = this.table.addEventListener(CELL_ACTION, this.onTableChange);\r\n  }\r\n\r\n  destroy() {\r\n      this.dispatchEvent({ type: \"destroy\" })\r\n      this.onDestroy();\r\n  }\r\n\r\n  refresh(obj) {\r\n    this._update(undefined, obj);\r\n  }\r\n\r\n  update(e) {\r\n    this._update(e.target.value)\r\n  }\r\n\r\n  _update(e = this.formula, { calledBy: cldby } = {}) {\r\n    const cellFinder = {\r\n      getCell: ({ row, col }, { calledBy }) =>\r\n        this.table.cells.find(findCell({ row, col })).value,\r\n      getRow: (row, { calledBy }) => ({\r\n        getCol: (col, { calledBy }) =>\r\n          this.table.cells.find(findCell({ row, col })).value,\r\n        all: ({ calledBy }, { calledBy: cb2 } = {}) =>\r\n          this.table\r\n            .filter(({ row: r }) => row === r)\r\n            .map(({ value }) => value),\r\n      }),\r\n      getCol: (col, { calledBy }) => ({\r\n        getRow: (row, { calledBy }) =>\r\n          this.table.cells.find(findCell({ row, col })).value,\r\n        all: ({ calledBy }, { calledBy: cb2 } = {}) =>\r\n          this.table.cells\r\n            .filter(({ col: c }) => col === c)\r\n            .map(({ value }) => value),\r\n      }),\r\n    };\r\n    console.log(`Updating cell ${this.name} value with `, cldby)\r\n    const meta = {\r\n      _context: cellFinder,\r\n      _currentcell: { row: this.row, col: this.col }, // cell this formula is in\r\n      _calledBy: cldby || [],\r\n      allowUnsafe: this.allowUnsafe\r\n    };\r\n\r\n    let r;\r\n    try {\r\n        r = this.table.parser.parse(e, {\r\n            ...meta,\r\n            _self: (exp, ctx) =>  this.table.parser.parse(exp, {\r\n                ...meta,\r\n                //...ctx,\r\n            }),\r\n        });\r\n    } catch(e) {\r\n        r = e.value || e;\r\n    }\r\n    if(r instanceof Error) {\r\n        // real Error;\r\n        console.error(`Formula ${e} returned unexpected error`, r);\r\n        r = { type: \"Runtime Error\", value: `${r.name}: ${r.message}` };\r\n        // todo: All dispatches\r\n    }\r\n    this.value = r;\r\n    this.formula = e;\r\n    this.references = r && r[this.table.parser.CELL_TRACE] || [];\r\n    const evtData = { value: this.value, formula: this.formula, meta: { row: this.row, col: this.col, cell: this, calledBy: this.references } };\r\n    this.table.dispatchEvent({ type: CELL_ACTION, ...evtData });\r\n    this.table.dispatchEvent({ type: \"change\", ...evtData });\r\n    const update = { value: this.value, formula: this.formula };\r\n    this.onUpdate.call(this, update, this);\r\n    this.dispatchEvent({ type: \"change\", ...evtData });\r\n    return update;\r\n  }\r\n\r\n  subscribe(observer, maybeOnError, maybeOnComplete) {\r\n    const onNext = observer.next || observer;\r\n    const onError = observer.error|| maybeOnError || noop;\r\n    const onComplete = observer.complete|| maybeOnComplete || noop;\r\n    const unsub1 = this.addEventListener(\"change\", (evt) => {\r\n        onNext(evt);\r\n    });\r\n    const unsub2 = this.addEventListener(\"destroy\", (evt) => {\r\n        onComplete();\r\n    });\r\n\r\n    let closed = false;\r\n    const subscription = {\r\n        unsubscribe: () => {\r\n            unsub1();\r\n            unsub2();\r\n            closed = true;\r\n        },\r\n        get closed() { return closed; }\r\n    };\r\n    if(observer.start) {\r\n        observer.start(subscription);\r\n    }\r\n\r\n    return subscription;\r\n  }\r\n\r\n  onTableChange(evt) {\r\n    if(evt.type === CELL_ACTION) {\r\n        if(evt.meta.row === this.row && evt.meta.col === this.col) { // self\r\n            return;\r\n        }\r\n        console.log(this.name, this.references)\r\n        // if the changed cell is something that is referenced from this cell\r\n        if(this.references.some(({ row, col }) => (row === \"*\" || evt.meta.row === (row-1)) && (col === \"*\" || (col-1) === evt.meta.col))) { // Warning: references is in 1-based format!! // todo trace in parser and correct\r\n            if(evt.value.value === this.table.parser.CIRCULAR) {\r\n                this.value = evt.value;\r\n                return;\r\n            }\r\n            this.refresh({ calledBy: evt.meta.calledBy || [] });\r\n        }\r\n    }\r\n  }\r\n\r\n  \r\n}\r\n\r\nexport default { Table, globalTable, Cell };\r\n\r\n","<script>\r\n\timport { onDestroy } from 'svelte';\r\n    import { Cell } from \"../../util.js\";\r\n\r\n    export let col;\r\n    export let row;\r\n    let cell = new Cell({ onUpdate: (__, c) => {\r\n        cell = c;\r\n        // cell.table.parser -> has all the constants to customize errors\r\n        const logv = typeof cell.value.value === 'symbol' ? cell.value.value.toString() : cell.value.value;\r\n        console.log(`Cell ${row},${col} updated; ${logv}`, );\r\n    }, row, col, allowUnsafe: true });\r\n\r\n    let displayValue = \"\"\r\n    $: {\r\n        displayValue = typeof cell.value.value === 'symbol' ? cell.value.value.toString() : cell.value.value;\r\n\r\n    }\r\n    \r\n    onDestroy(cell.destroy);\r\n\r\n    \r\n</script>\r\n\r\n<div class=\"cell\">\r\n    <input class=\"formula\" data-row={row} data-col={col} value={cell.formula || \"\"} on:change={cell.update}>\r\n    <input class=\"value\" tabindex='-1' readonly data-row={row} data-col={col} value={displayValue} >\r\n</div>\r\n\r\n<style type=\"text/scss\">\r\n    .cell {\r\n        position: relative;\r\n        & > input.value {\r\n            opacity: 1;\r\n            position: absolute;\r\n            top: 0;\r\n            left: 0;\r\n            pointer-events: none;\r\n        }\r\n        & > input.formula {\r\n            opacity: 0;\r\n        }\r\n        & > input.formula:focus {\r\n            opacity: 1;\r\n        }\r\n        & > input.formula:focus + input.value {\r\n            opacity: 0;\r\n        }\r\n    }\r\n</style>","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body,\n\tprops: {}\n});\n\nexport default app;"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","i","length","d","element","name","document","createElement","text","data","createTextNode","space","attr","attribute","value","removeAttribute","getAttribute","setAttribute","current_component","set_current_component","component","onDestroy","Error","get_current_component","$$","on_destroy","push","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","flushing","seen_callbacks","Set","flush","update","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","outros","transition_in","block","local","delete","transition_out","o","c","mount_component","on_mount","m","new_on_destroy","map","filter","destroy_component","make_dirty","then","fill","init","options","instance","create_fragment","not_equal","props","parent_component","prop_values","bound","context","Map","callbacks","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteComponent","[object Object]","this","$destroy","type","index","indexOf","splice","CELL","Symbol","STR_ESCAPED","STR_PLAIN","AGGREGATE","SUBTOTAL","NUMBER","COMPLEX_NUMBER","LIST","MATRIX","STRING","ANY","BOOLEAN","FUNCTION","ARGUMENTS","NULL","ARRAY","ERROR","DATE","TIME","DATETIME","TRACE","CELL_TRACE","HYPERLINK","NAVALUE","VVALUE","REFVALUE","NUMVALUE","DIV0","NULLE","NAMEE","GETTINGDATA","INLINE","HIDDEN","NATURALREF","CIRCULAR","BESSEL","romannumeral_classic","I","IV","V","IX","X","XL","L","XC","C","CD","D","CM","M","romannumeral_baseSet","romannumeral_mode1","LD","VL","romannumeral_mode2","XD","romannumeral_mode3","VD","romannumeral_simplified","ID","romannumeral_extended","Mↁ","ↁ","Mↂ","ↂ","ↂↇ","ↇ","ↂↈ","ↈ","romannumeral_romanSymbols","Ⅰ","Ⅱ","Ⅲ","Ⅳ","Ⅴ","Ⅵ","Ⅶ","Ⅷ","Ⅸ","Ⅹ","Ⅺ","Ⅻ","ⅩⅬ","Ⅼ","ⅩⅭ","Ⅽ","ⅭⅮ","Ⅾ","ⅭⅯ","Ⅿ","romannumeralmodes","Dↁ","Cↂ","Cↁ","ↁↇ","Mↇ","Lↁ","Dↇ","Xↁ","Cↇ","Xↂ","Vↁ","Iↁ","Iↂ","Vↂ","Lↇ","Xↇ","Xↈ","Lↈ","Vↇ","Iↇ","Iↈ","Vↈ","IM","VM","Ⅾↁ","Ⅽↂ","Ⅽↁ","Ⅼↁ","Ⅹↁ","Ⅹↂ","Ⅴↁ","Ⅰↁ","Ⅰↂ","Ⅴↂ","Ⅿↇ","Ⅾↇ","Ⅽↇ","Ⅼↇ","Ⅹↇ","Ⅹↈ","Ⅼↈ","Ⅴↇ","Ⅰↇ","Ⅰↈ","Ⅴↈ","ⅠⅯ","ⅤⅯ","weight","g","sg","lbm","u","ozm","grain","cwt","shweight","uk_cwt","lcwt","hweight","stone","ton","uk_ton","LTON","brton","mi","Nmi","in","ft","yd","ang","ell","ly","parsec","pc","Picapt","Pica","pica","survey_mi","time","yr","day","hr","mn","min","sec","s","press","Pa","atm","at","mmHg","psi","Torr","force","N","dyn","dy","lbf","pond","energy","J","e","cal","eV","ev","HPh","hh","Wh","wh","flb","BTU","btu","power","HP","h","PS","W","w","magn","T","ga","temperature","cel","F","fah","K","kel","Rank","Reau","tsp","tspm","tbs","oz","cup","pt","us_pt","uk_pt","qt","uk_qt","gal","uk_gal","lt","ang3","ang^3","barrel","bushel","ft3","ft^3","in3","in^3","ly3","ly^3","m3","m^3","mi3","mi^3","yd3","yd^3","Nmi3","Nmi^3","Picapt3","Picapt^3","Pica3","Pica^3","GRT","regton","MTON","area","uk_acre","us_acre","ang2","ar","ft2","ft^2","ha","in2","in^2","ly2","ly^2","m2","m^2","Morgen","mi2","mi^2","Nmi2","Nmi^2","Picapt2","Pica2","Pica^2","Picapt^2","yd2","yd^2","computer","bit","byte","speed","admkn","kn","m/h","m/hr","m/s","m/sec","mph","prefixes","Yi","Zi","Ei","Pi","Ti","Gi","Mi","ki","Y","Z","E","P","G","k","da","n","f","z","y","functions","_TOSEARCHSTRING","string","start","end","casesensitive","RegExp","replace","_GREATER","_SMALLER","_EQUAL","_GREATER_OR_EQUAL","_SMALLER_OR_EQUAL","SUM","allargs","result","reduce","sum","String","AVERAGE","console","log","ccount","count","meta","_CELL_COUNT","_context","Number","isNaN","parseFloat","_CELL_COUNTA","COUNT","args","COUNTA","COUNTBLANK","range","IF","iff","thenn","elsee","TRIM","v","trim","MAX","max","Infinity","MIN","CONCATENATE","join","SUBSTITUTE","oldText","newText","nthAppearance","match","pos","original","VALUE","arg","EXACT","UPPER","toUpperCase","LOWER","toLowerCase","PROPER","split","word","charAt","slice","LEFT","numChars","RIGHT","MID","startNum","AND","OR","XOR","NOT","IFERROR","iserror","valueiferror","IFNA","SUMPRODUCT","arg0","every","idx","RAND","Math","random","RANDBETWEEN","floor","ROUND","num","dec","round","pow","ROUNDUP","ceil","ROUNDDOWN","MROUND","FLOOR","CEILING","INT","TRUNC","EVEN","ODD","MOD","SMALL","sort","LARGE","COUNTIF","t1","criteria","_CRITMATCHER","criterium","cf",">=","substring","<=","<>",">","<","=","matcher","test","COUNTIFS","ranges","l1","l2","arr","cfunctions","_","r","jdx","VLOOKUP","lookup_value","table_array","col_index_num","range_lookup","findIndex","searchr","concat","item","shift","INDEX","array","row_num","column_num","MATCH","lookup_array","match_type","INDIRECT","ref_text","a1","parsed","parser","OFFSET","reference","offsetrows","offsetcols","height","width","functioncontext","topleft","top","row","left","col","heightvalue","rowspan","widthvalue","colspan","results","errorflag","t","getRow","getCol","partial_results","TRANSPOSE","ccol","crow","currentcell","values","__","link_location","friendly_name","href","FV","rate","nper","pmt","pv","YEAR","MONTH","DAY","Date","DATEVALUE","TEXT","TODAY","NOW","date","getDate","getMonth","getFullYear","EOMONTH","monthsdiff","WEEKDAY","return_type","modes","1","2","3","11","12","13","14","15","16","17","getDay","WEEKNUM","UTC","dayNum","getUTCDay","setUTCDate","getUTCDate","yearStart","getUTCFullYear","modemap","dayNum2","DATEDIF","start_date","end_date","unit","abs","MD","YM","YD","valueOf","EDATE","months","setMonth","YEARFRAC","base","0","sFeb","eFeb","Y1","Y2","M1","M2","D1","D2","startYear","endYear","div","Actual/actual","Actual/360","Actual/365","4","European 30/360","30/360","30/360 Bond Basis","30A/360","30/360 US","30U/360","30E/360","30/360 ICMA","30S/360","Eurobond basis (ISDA 2006)","Special German","30E/360 ISDA","Eurobond basis (ISDA 2000)","Actual/Actual ISDA","currentYear","leapDays","regularDays","s0","e0","days","Actual/Actual","Act/Act","Act/365","Act/365 Fixed","A/365 Fixed","A/365F","English","Act/360","A/360","French","Actual/364","Actual/Actual AFB","sy","fullYears","setFullYear","years","1/1","WORKDAY","holidays","hollidaylist","setDate","some","dt","WORKDAY.INTL","weekend","weekenddays","weekendmap","5","6","7","message","NETWORKDAYS","NETWORKDAYS.INTL","hours","minutes","seconds","TIMEVALUE","time_text","HOUR","getHours","MINUTE","getMinutes","SECOND","getSeconds","ABS","ACCRINT","issue","first_interest","settlement","par","frequency","basis","calc_method","ACCRINTM","ACOS","acos","ACOSH","acosh","ACOT","ATAN","ACOTH","ATANH","function_num","8","9","10","18","19","ufunction","uarguments","hidden","initialError","find","error_value","internal_error","ADDRESS","abs_num","sheet_text","fromCharCode","AMORDEGRC","AMORLINC","ARABIC","roman","totalValue","prev","current","romanToArabic","AREAS","includes","ASC","charCodeAt","ASIN","asin","ASINH","asinh","atan","ATAN2","atan2","atanh","AVEDEV","_args","avg","derivations","deviations","AVERAGEA","AVERAGEIF","function","SUMIF","AVERAGEIFS","SUMIFS","BAHTTEXT","Intl","NumberFormat","numberingSystem","style","currency","format","BASE","decimal","minlength","toString","padStart","_BESSEL","XT","typeNT","bessel","NT","TYPE","func","BESSELI","BESSELJ","BESSELK","BESSELY","BETADIST","x","valye","alpha","beta","BETA.DIST","cumulative","BETAINV","BETA.INV","BIN2DEC","parseInt","BIN2HEX","BIN2OCT","BINOMDIST","BINOM.DIST","BINOM.DIST.RANGE","x1","x2","chance","BINOM.INV","BITAND","BITLSHIFT","BITOR","BITRSHIFT","BITXOR","CALL","allowUnsafe","ff","xtype","self","global","window","cellTrace","argnames","argvalues","Function","exec","error","CEILING.MATH","CEILING.PRECISE","info_type","CELL_FUNCTION","location","CHAR","CHIDIST","CHIINV","CHITEST","CHISQ.DIST","CHISQ.DIST.RT","CHISQ.INV","CHISQ.INV.RT","CHISQ.TEST","CHOOSE","CLEAN","CODE","COLUMN","COLUMNS","st","sc","lc","_FACTORIAL_CACHE","_FACTORIAL_i","_FACTORIAL","COMBIN","COMBINA","COMPLEX","t2","suffix","CONCAT","rv","p0","CONFIDENCE","sd","jstat","normalci","CONFIDENCE.NORM","CONFIDENCE.T","tci","CONVERT","to","matchCat","cat","xfrom","xp","xp2","yfrom","yp","yp2","ip","keys","fromto","pf","catname","entries","Speed","Information","Area","Volume","Temperature","Magnetism","Power","Energy","Force","Pressure","Time","Distance","Weight and mass","multiplicatorFrom","multiplicatorTo","fromUnit","toUnit","CORREL","xf","yf","xbar","ybar","ab","a2","b2","absum","a2sum","b2sum","sqrt","COS","cos","COSH","cosh","COT","tan","COTH","tanh","COUPDAYBS","COUPDAYS","COUPDAYSNC","COUPNCD","COUPNUM","COUPPCD","_COVAR","sp","COVAR","COVARIANCE.P","COVARIANCE.S","CRITBINOM","functinos","CSC","sin","CSCH","sinh","CUBEKPIMEMBER","CUBEMEMBER","CUBEMEMBERPROPERTY","CUBERANKEDMEMBER","CUBESET","CUBESETCOUNT","CUBEVALUE","CUMIPMT","CUMPRINC","_DATABASE","database","headersv","headers","db","j","cheadersv","crit","cheaders","critas","key","cri","op","field","matches","DAVERAGE","selected","fieldname","DAYS","d1","d2","date1","date2","getTime","DAYS360","method","d1d","d2d","d1m","d2m","lastDayOfD1Month","lastDayOfD2Month","DB","cost","salvage","life","period","month","urate","totaldepprior","DBCS","DCOUNT","dbmeta","DCOUNTA","DDB","factor","_DEC2X","excel","DEC2BIN","DEC2HEX","DEC2OCT","DECIMAL","DEGREES","PI","DELTA","n1","n2","DEVSQ","DGET","DISC","DMAX","DMIN","DOLLAR","ammount","display","DOLLARDE","frac","intp","fracp","toFixed","DOLLARFR","DPRODUCT","PRODUCT","DSTDEV","DSTDEVP","DSUM","DURATION","DVAR","VAR","DVARP","VARP","EFFECT","nominal_rate","npery","ENCODEURL","encodeURIComponent","ERF","ERF.PRECISE","ERFC","ERFC.PRECISE","ERROR.TYPE","EUROCONVERT","EXP","EXPON.DIST","lambda","EXPONDIST","_FACT","counter","pro","neg","FACT","FACTDOUBLE","FACTN","FALSE","F.DIST","FDIST","F.DIST.RT","FILTER","_data","boollist","bttype","defaultt","filtereddata","FILTERXML","xml","xpath","oDOM","DOMParser","parseFromString","evaluator","XPathEvaluator","attempt","xpathtype","createExpression","evaluate","XPathResult","STRING_TYPE","NUMBER_TYPE","BOOLEAN_TYPE","FIND","find_text","within_text","start_num","FINDB","TextEncoder","encode","F.INV","F.INV.RT","FINV","FUNCTIONS","FISHER","FISHERINV","FIXED","number","nocomma","defaultOptions","resolvedOptions","locale","useGrouping","FLOOR.MATH","FLOOR.PRECISE","FORECAST","FORECAST.ETS","FORECAST.ETS.CONFINT","FORECAST.ETS.SEASONALITY","FORECAST.ETS.STAT","FORECAST.LINEAR","kx","ky","ax","ay","nr","dr","FORMULATEXT","formula","FREQUENCY","data_array","bins_array","rev","reverse","cats","idxn","idxx","F.TEST","FTEST","FVSCHEDULE","principal","schedule","GAMMA","GAMMA.DIST","GAMMADIST","GAMMA.INV","GAMMAINV","GAMMALN","GAMMALN.PRECISE","GAUSS","_GCD2","xx","yy","GCD","GEOMEAN","prod","GESTEP","step","GETPIVOTDATA","GROWTH","HARMEAN","HEX2BIN","HEX2DEC","HEX2OCT","HLOOKUP","row_index_num","HYPGEOM.DIST","HYPGEOMDIST","IFS","_PARSECOMPLEXSTRING","endsWith","rr","_PARSECOMPLEX","mt","r0","i0","IMABS","IMAGINARY","IMARGUMENT","IMCONJUGATE","ic","IMCOS","real","img","IMCOSH","IMCOT","q","IMCSC","IMCSCH","IMDIV","IMEXP","exp","IMLN","IMLOG10","log10","IMLOG2","log2","_IMPOWER2","IMPOWER","IMPRODUCT","IMREAL","IMSEC","IMSECH","IMSIN","IMSINH","IMSQRT","IMSUB","_IMSUM2","IMSUM","IMTAN","INFO","navigator","oscpu","platform","INTERCEPT","ys","xs","INTRATE","IPMT","IRR","ISBLANK","ISERR","ISERROR","ISEVEN","ISFORMULA","ISLOGICAL","ISNA","ISNONTEXT","ISNUMBER","NUBOOLEANLL","ISODD","ISREF","ISTEXT","ISO.CEILING","ISOWEEKNUM","ISPMT","per","vdecperperiod","remaining","reduction_per_period","remaining_value","JIS","KURT","mean","M3","M4","delta","delta_n","delta_n2","term1","_LCM2","LCM","num_chars","LEFTB","str","lengthInBytes","resultStr","unescape","LEN","LENB","LINEST","LN","LOG","LOG10","LOGEST","LOGINV","LOGNORM.DIST","LOGNORMDIST","LOGNORM.INV","LOOKUP","lookup_vector","result_vector","MAXA","_MULTI_IFS","MAXIFS","resultv","bl","filtered","MDETERM","globalLength","nonNumber","det","deleteRowAndColumn","temp","MDURATION","MEDIAN","w1","w2","list","sorted","middle","even","odd","startnum","MIDB","MINIFS","MINA","MINVERSE","ii","dim","MIRR","_MODE_INTERNAL_COUNT","counts","obj","esum","NA","NEGBINOM.DIST","NEGBINOMDIST","NORM.DIST","NORMDIST","NORMINV","NORM.INV","NORM.S.DIST","NORMSDIST","NORM.S.INV","NORMSINV","NPER","sidx","formatToParts","part","percents","cinte","reg","deci","ODDFPRICE","ODDFYIELD","ODDLPRICE","ODDLYIELD","avga","avgb","s1","s2","sortedarr","PERCENTILE","sig","P1","V1","P2","V2","PERCENTRANK.INC","PERCENTRANK","PERMUTATIONA","PHI","PHONETIC","PMT","POISSON.DIST","POISSON","POWER","PPMT","PRICE","PRICEDISC","PRICEMAT","prob_range","valuesInRange","lower_limit","x_range","PV","QUARTILE","QUOTIENT","RADIANS","rows","whole_number","columns","order","search","vs","RANK","RATE","RECEIVED","REGISTER.ID","startn","REPT","sb","fv","RTD","server","SEC","SHEET","SHEETS","SIGN","SIN","SINH","mc","SLN","xv","xt","yv","yt","bycol","assign","oidx","transposed","SQRT","SQRTPI","STANDARDIZE","STDEV.P","STDEVP","STDEV.S","s3","recurse","ignore","allow","xmode","STDEV","101","102","103","104","105","106","107","108","109","110","111","mapping","filterd","TAN","TANH","TBILLEQ","TBILLPRICE","TBILLYIELD","T.DIST","T.DIST.2T","T.DIST.RT","TDIST","T.INV","T.INV.2T","TINV","new_x","perc","excludes","TRUE","T.TEST","TTEST","UNICHAR","UNICODE","found","map2","_FILTERUNIQUE","_STDEV","VAR.P","VAR.S","_STDEVA","VDB","WEIBULL","WEIBULL.DIST","XIRR","retrunarr","ifnotfound","match_mode","lookup","xarr","XNPV","YIELD","YIELDDISC","YIELDMAT","Z.TEST","JSON","pathx","expected","constructor","ctor","prototype","expectation","escapedParts","parts","classEscape","hex","literalEscape","ch","descriptions","SyntaxError","peg$SyntaxError","parse","input","peg$startRuleFunctions","peg$c3","peg$literalExpectation","peg$c6","peg$c8","peg$c9","peg$c11","peg$c13","peg$c15","peg$c17","peg$c19","peg$c21","peg$c24","peg$c27","peg$c29","peg$c32","peg$c34","peg$c37","peg$c40","peg$c42","peg$c43","peg$c45","peg$c48","peg$c49","member","peg$c52","peg$c54","peg$c57","peg$c60","peg$c62","peg$c63","peg$classExpectation","peg$c64","peg$c65","peg$c66","peg$c68","peg$c71","peg$c72","peg$c73","peg$c75","peg$c78","peg$c79","peg$c80","peg$c84","peg$c85","peg$c86","peg$c91","peg$c92","peg$c93","peg$c94","peg$c95","peg$c96","peg$c97","peg$c101","peg$c103","peg$c105","peg$c109","peg$c111","peg$c112","peg$c113","peg$c115","peg$c116","peg$c118","peg$c119","peg$c120","peg$c123","peg$c125","loc","peg$c126","peg$c132","peg$c135","peg$c137","peg$c138","peg$c139","peg$c142","peg$otherExpectation","peg$c145","peg$c147","peg$c149","peg$c150","peg$currPos","peg$savedPos","peg$posDetailsCache","peg$maxFailPos","peg$maxFailExpected","ignoreCase","line","details","column","startPosDetails","peg$computePosDetails","startPos","offset","endPos","endPosDetails","peg$parseStart","peg$FAILED","s4","s5","s6","s7","stdop","peg$c46","s8","s10","s11","arguments","peg$c121","s9","peg$c124","contextu","peg$c110","locx","peg$c127","peg$c128","peg$parseCellSheetWorkbook","abscol","carg","inheritedCellTrace","peg$c99","absolute","cell","peg$c104","unsafeend","getWorkbook","circularFlag","unsafestart","peg$c130","peg$silentFails","lstype","right","Cell_Trace","calledBy","ccd","getSheet","peg$computeLocation","useCaptureOptions","cbsarr","uco","useCaptureOptionsKeys","stack","event","capture","once","passive","super","cells","references","lastRun","expression","onUpdate","table","register","_value","onTableChange","refresh","destroy","dispatchEvent","findCell","_currentcell","_calledBy","cldby","CELL_ACTION","maybeOnComplete","onNext","next","onComplete","observer","unsub1","unsub2","handler","addEventListener","removeEventListener","Cell","logv"],"mappings":"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"}